<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sigma The Game</title>
    <style>
        /* --- Google Font Import --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
    
        /* --- Global Styles --- */
        :root {
    /* Core Colors */
    --bg-color: #1a1a24;
    --text-color: #f0f0f5;
    --primary-color: #ffcc00; /* Gold */
    --secondary-color: #4a90ff; /* Mana Blue - slightly more vibrant */
    --accent-color: #ff5252; /* Enemy Red - more saturated */
    --player-color: #50e050; /* Player Green - more natural */
    --card-bg: #2d2d3d; /* Darker card background with a hint of blue */
    --rare-color: #d966ff; /* Purple for rare upgrades - more vivid */
    
    /* UI Element Colors */
    --ui-dark: #252532;
    --ui-medium: #35354a;
    --ui-light: #45455a;
    --ui-highlight: rgba(255, 255, 255, 0.1);
    
    /* Status Effect Colors */
    --poison-color: #9c27b0;
    --heal-color: #66bb6a;
    --block-color: #29b6f6;
    
    /* Card Rarities */
    --common-glow: rgba(255, 255, 255, 0.4);
    --uncommon-glow: rgba(30, 255, 0, 0.5);
    --rare-glow: rgba(0, 112, 221, 0.5);
    --epic-glow: rgba(163, 53, 238, 0.6);
    --legendary-glow: rgba(255, 128, 0, 0.6);
    
    /* Animation Speeds */
    --anim-fast: 0.2s;
    --anim-medium: 0.5s;
    --anim-slow: 1s;
    
    /* Dimensions */
    --card-width: 140px;
    --card-height: 210px;
    --border-radius: 12px;
}

/* Base Elements */
body {
    font-family: 'Segoe UI', 'Roboto', sans-serif;
    color: var(--text-color);
    max-width: 900px;
    margin: 10px auto;
    padding: 15px;
    overflow-x: hidden;
    background-color: var(--bg-color);
    position: relative;
    
    /* Animated Background */
    background: 
        radial-gradient(circle at 20% 30%, rgba(60, 60, 120, 0.15) 0%, transparent 60%),
        radial-gradient(circle at 80% 70%, rgba(100, 25, 80, 0.1) 0%, transparent 60%),
        linear-gradient(135deg, #151520, #1d1d2b, #151520, #252535);
    background-size: 400% 400%;
    animation: gradientShift 35s ease infinite;
}

/* Star particles in background */
body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-image: 
        radial-gradient(1px 1px at 50px 100px, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0)),
        radial-gradient(1px 1px at 150px 300px, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0)),
        radial-gradient(1px 1px at 300px 50px, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0)),
        radial-gradient(1px 1px at 400px 250px, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0)),
        radial-gradient(1px 1px at 500px 100px, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0)),
        radial-gradient(1px 1px at 50% 80%, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0)),
        radial-gradient(2px 2px at 70% 90%, rgba(255, 204, 0, 0.5), rgba(255, 204, 0, 0)),
        radial-gradient(2px 2px at 30% 20%, rgba(255, 204, 0, 0.5), rgba(255, 204, 0, 0));
    pointer-events: none;
    z-index: -1;
}

@keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}

/* Typography */
h1, h2 {
    text-align: center;
    color: var(--primary-color);
    text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
    letter-spacing: 1px;
    margin-bottom: 15px;
}

h1 {
    font-size: 2.2em;
}

h2 {
    margin-top: 20px;
    font-size: 1.5em;
}

/* Main Container */
.game-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    background-color: rgba(29, 29, 40, 0.75);
    padding: 20px;
    border-radius: var(--border-radius);
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
}

.game-container::after {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(to right, 
                               transparent, 
                               rgba(255, 204, 0, 0.5), 
                               transparent);
    opacity: 0.7;
}

/* Stats Container */
.stats-container {
    display: flex;
    justify-content: space-around;
    background-color: var(--ui-dark);
    padding: 10px 15px;
    border-radius: 10px;
    font-size: 13px;
    border: 1px solid var(--ui-light);
    flex-wrap: wrap;
    gap: 12px;
    box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
}

.stats-column {
    display: flex;
    flex-direction: column;
    gap: 4px;
    align-items: center;
    position: relative;
}

.stats-column::after {
    content: '';
    position: absolute;
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    width: 0;
    height: 2px;
    background: var(--primary-color);
    transition: width var(--anim-medium) ease;
}

.stats-column:hover::after {
    width: 100%;
}

/* Battle Area */
.battle-area {
    display: flex;
    justify-content: space-between;
    align-items: flex-start;
    gap: 25px;
    margin: 20px 0;
    position: relative;
}

/* Add a decorative line between player and enemy */
.battle-area::before {
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 2px;
    background: linear-gradient(to right, 
                               transparent, 
                               rgba(255, 255, 255, 0.3), 
                               transparent);
    transform: translateY(-50%);
    opacity: 0.5;
}

/* Player Display */
.player-display {
    flex: 1;
    background: linear-gradient(to bottom, 
                              rgba(37, 58, 41, 0.9), 
                              rgba(37, 58, 41, 0.7));
    padding: 18px;
    border-radius: var(--border-radius);
    border: 1px solid var(--player-color);
    box-shadow: 0 0 15px rgba(80, 224, 80, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 220px;
    transition: all var(--anim-medium) ease;
    position: relative;
    overflow: hidden;
}

.player-display::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center, 
                               rgba(80, 224, 80, 0.1), 
                               transparent 70%);
    opacity: 0.7;
    pointer-events: none;
}

.player-display:hover {
    box-shadow: 0 0 20px rgba(80, 224, 80, 0.5);
    transform: translateY(-3px);
}

.player-name {
    font-size: 22px;
    font-weight: bold;
    margin-bottom: 10px;
    color: var(--player-color);
    letter-spacing: 1px;
    text-shadow: 0 0 5px rgba(80, 224, 80, 0.5);
}

.player-gold {
    font-size: 15px;
    margin-bottom: 10px;
    color: gold;
    font-weight: bold;
    text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
    display: flex;
    align-items: center;
    gap: 5px;
}

#petContainer {
    position: absolute;
    left: 60px; /* links vom Spieler – bleibt gleich */
    top: 90px;
    display: flex;
    flex-direction: column; /* untereinander */
    align-items: center;
    gap: 10px; /* Abstand zwischen Pets */
    z-index: 20; /* sicher über Hintergrund */
}

.pet-tooltip-wrapper {
    position: relative;
    display: flex;
    flex-direction: column; /* Tooltip über oder unter Bild */
    align-items: center;
}

.pet-image {
    width: 70px;
    height: 70px;
    background-color: rgba(0, 0, 0, 0.2);
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    border: 3px solid var(--player-color);
    border-radius: var(--border-radius);
    image-rendering: pixelated;
    transition: all var(--anim-medium) ease;
    box-shadow: 0 0 15px rgba(80, 224, 80, 0.2);
    position: relative;
    pointer-events: auto;
    overflow: hidden;
}

.pet-image.wobble {
    animation: petWobble 0.4s ease-in-out;
}

.pet-tooltip {
    display: none;
    position: absolute;
    bottom: 110%;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    white-space: nowrap;
    z-index: 1000;
    pointer-events: none;
}

.pet-tooltip-wrapper:hover .pet-tooltip {
    display: block;
}


@keyframes petWobble {
  0%   { transform: translateY(0px); }
  25%  { transform: translateY(-4px); }
  50%  { transform: translateY(4px); }
  75%  { transform: translateY(-4px); }
  100% { transform: translateY(0px); }
}

.player-image {
    width: 110px;
    height: 110px;
    background-color: rgba(0, 0, 0, 0.2);
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    border: 3px solid var(--player-color);
    border-radius: var(--border-radius);
    image-rendering: pixelated;
    margin-bottom: 12px;
    transition: all var(--anim-medium) ease;
    box-shadow: 0 0 15px rgba(80, 224, 80, 0.2);
    position: relative;
    overflow: hidden;
}

.player-image::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(
        to right,
        transparent,
        rgba(255, 255, 255, 0.2),
        transparent
    );
    transform: skewX(-25deg);
    animation: shimmer 5s infinite;
}

@keyframes shimmer {
    0% { left: -100%; }
    50% { left: 150%; }
    100% { left: 150%; }
}

.player-image.is-active {
    animation: playerPulse 3s ease-in-out infinite, gentleBob 4s ease-in-out infinite;
}

@keyframes playerPulse {
    0%, 100% { box-shadow: 0 0 15px rgba(80, 224, 80, 0.2); }
    50% { box-shadow: 0 0 25px rgba(80, 224, 80, 0.6); }
}

.player-stats {
    width: 92%;
    text-align: left;
}

/* Enemy Container */
.enemy-container {
    flex: 1;
    background: linear-gradient(to bottom, 
                              rgba(58, 37, 37, 0.9), 
                              rgba(58, 37, 37, 0.7));
    padding: 18px;
    border-radius: var(--border-radius);
    border: 1px solid var(--accent-color);
    box-shadow: 0 0 15px rgba(255, 82, 82, 0.3);
    display: flex;
    flex-direction: column;
    align-items: center;
    min-width: 220px;
    position: relative;
    transition: all var(--anim-medium) ease;
    overflow: hidden;
}

.enemy-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center, 
                               rgba(255, 82, 82, 0.1), 
                               transparent 70%);
    opacity: 0.7;
    pointer-events: none;
}

.enemy-container:hover {
    box-shadow: 0 0 20px rgba(255, 82, 82, 0.5);
    transform: translateY(-3px);
}

.enemy-name {
    font-size: 22px;
    font-weight: bold;
    margin-bottom: 10px;
    color: var(--accent-color);
    letter-spacing: 1px;
    text-shadow: 0 0 5px rgba(255, 82, 82, 0.5);
}

.monster-image {
    width: 110px;
    height: 110px;
    margin-bottom: 12px;
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    border-radius: var(--border-radius);
    border: 3px solid var(--accent-color);
    box-shadow: 0 0 15px rgba(255, 82, 82, 0.2);
    transition: transform var(--anim-medium);
    image-rendering: pixelated;
    position: relative;
    overflow: hidden;
}

.monster-image::after {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 50%;
    height: 100%;
    background: linear-gradient(
        to right,
        transparent,
        rgba(255, 255, 255, 0.15),
        transparent
    );
    transform: skewX(-25deg);
    animation: shimmer 6s infinite;
}

.monster-image:hover {
    transform: scale(1.05) rotate(2deg);
}

.monster-image.is-active {
    animation: enemyPulse 3s ease-in-out infinite, gentleEnemyBob 4s ease-in-out infinite;
}

@keyframes enemyPulse {
    0%, 100% { box-shadow: 0 0 15px rgba(255, 82, 82, 0.2); }
    50% { box-shadow: 0 0 25px rgba(255, 82, 82, 0.6); }
}

@keyframes gentleEnemyBob {
    0%, 100% { transform: translateY(0) rotate(0deg); }
    50% { transform: translateY(-5px) rotate(2deg); }
}

.enemy-stats-display {
    width: 92%;
    text-align: left;
}

.enemy-info {
    margin-top: 12px;
    font-size: 12px;
    color: #eee;
    text-align: center;
    padding: 10px;
    background-color: rgba(0, 0, 0, 0.25);
    border-radius: 8px;
    width: 92%;
    min-height: 30px;
    border: 1px solid rgba(255, 82, 82, 0.2);
}

/* Monster Traits */
.monster-traits {
    display: flex;
    gap: 6px;
    justify-content: center;
    margin-top: 10px;
    flex-wrap: wrap;
}

.monster-trait {
    background-color: rgba(60, 60, 60, 0.6);
    border-radius: 10px;
    padding: 4px 9px;
    font-size: 11px;
    color: var(--primary-color);
    border: 1px solid rgba(255, 204, 0, 0.3);
    box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
    position: relative;
    cursor: help;
    transition: all var(--anim-fast) ease;
}

.monster-trait:hover {
    background-color: rgba(80, 80, 80, 0.7);
    border-color: var(--primary-color);
    transform: translateY(-2px);
}

.monster-trait:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 130%;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.9);
    color: #fff;
    padding: 8px 10px;
    border-radius: 6px;
    white-space: normal;
    text-align: center;
    font-size: 11px;
    width: max-content;
    max-width: 200px;
    z-index: 1000;
    box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    animation: tooltipFadeIn var(--anim-fast) ease-out;
}

.monster-trait:hover::before {
    content: "";
    position: absolute;
    bottom: 120%;
    left: 50%;
    transform: translateX(-50%);
    border-width: 6px;
    border-style: solid;
    border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
    z-index: 1001;
    animation: tooltipFadeIn var(--anim-fast) ease-out;
}

@keyframes tooltipFadeIn {
    from { opacity: 0; transform: translateX(-50%) translateY(10px); }
    to { opacity: 1; transform: translateX(-50%) translateY(0); }
}

/* Health & Mana Bars */
.health-bar, .mana-bar {
    height: 20px;
    background-color: rgba(50, 50, 60, 0.8);
    border-radius: 10px;
    margin: 6px 0;
    overflow: hidden;
    width: 100%;
    border: 1px solid rgba(0, 0, 0, 0.3);
    box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
    position: relative;
}

.health-fill, .mana-fill {
    height: 100%;
    transition: width 0.6s cubic-bezier(0.22, 1, 0.36, 1);
    position: relative;
    overflow: hidden;
}

.health-fill::before, .mana-fill::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0));
    border-radius: 10px 10px 0 0;
}

/* Dynamic glow effect on health change */
@keyframes healthChange {
    0% { box-shadow: 0 0 12px rgba(255, 200, 0, 0.7); }
    100% { box-shadow: 0 0 0 rgba(255, 200, 0, 0); }
}

.health-bar.changed {
    animation: healthChange 1s ease-out;
}

#playerHealthBar .health-fill {
    background: linear-gradient(to right, #3e9c35, var(--player-color));
    box-shadow: 0 0 8px rgba(80, 224, 80, 0.5);
}

#enemyHealthBar .health-fill {
    background: linear-gradient(to right, #c92a2a, var(--accent-color));
    box-shadow: 0 0 8px rgba(255, 82, 82, 0.5);
}

.mana-fill {
    background: linear-gradient(to right, #1a73e8, var(--secondary-color));
    box-shadow: 0 0 8px rgba(74, 144, 255, 0.5);
}

/* Animate bar text */
@keyframes valueChangeUp {
    0% { transform: translateY(0); opacity: 1; }
    50% { transform: translateY(-20px); opacity: 0; }
    51% { transform: translateY(20px); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
}

@keyframes valueChangeDown {
    0% { transform: translateY(0); opacity: 1; }
    50% { transform: translateY(20px); opacity: 0; }
    51% { transform: translateY(-20px); opacity: 0; }
    100% { transform: translateY(0); opacity: 1; }
}

.stat-text {
    font-size: 13px;
    margin-top: 6px;
    transition: all var(--anim-medium) ease;
}

.stat-text.changed-up {
    animation: valueChangeUp 0.6s ease-out;
}

.stat-text.changed-down {
    animation: valueChangeDown 0.6s ease-out;
}

/* Enemy Minions */
.enemy-minions {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
    margin-bottom: 12px;
}

.minion-box {
    background: linear-gradient(to bottom, #3d3d3d, #2d2d2d);
    border: 1px solid #666;
    border-radius: 8px;
    padding: 8px;
    text-align: center;
    width: 65px;
    font-size: 11px;
    color: white;
    transition: all var(--anim-fast) ease;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
    position: relative;
    overflow: hidden;
}

.minion-box:hover {
    transform: translateY(-3px) scale(1.05);
    border-color: var(--accent-color);
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
}

.minion-box::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.2), transparent 70%);
    opacity: 0;
    transition: opacity var(--anim-fast) ease;
    pointer-events: none;
}

.minion-box:hover::after {
    opacity: 1;
}

.minion-image {
    width: 40px;
    height: 40px;
    margin: 0 auto 5px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    image-rendering: pixelated;
    transition: transform var(--anim-fast) ease;
}

.minion-box:hover .minion-image {
    transform: scale(1.1) rotate(5deg);
}
    
/* Hand Cards Area */
.card-hand-container {
    margin-bottom: 20px;
    position: relative;
}

.card-hand {
    display: flex;
    justify-content: center;
    gap: 12px;
    flex-wrap: wrap;
    min-height: 250px;
    padding: 15px 0;
    background-color: rgba(0, 0, 0, 0.15);
    border-radius: var(--border-radius);
    border: 1px dashed rgba(255, 255, 255, 0.2);
    position: relative;
    overflow: visible;
    perspective: 1000px;
}

.card-hand::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(ellipse at center, 
                               rgba(255, 204, 0, 0.05), 
                               transparent 70%);
    pointer-events: none;
}

/* Card Hand Toolbar */
.card-hand-toolbar {
    display: flex;
    justify-content: center;
    gap: 12px;
    margin-bottom: -8px;
    position: relative;
    z-index: 2;
}

.card-hand-action-wrapper {
    display: flex;
    justify-content: center;
    gap: 25px;
    align-items: flex-start;
    margin-top: 15px;
}

/* Card Styling */
.card {
    width: var(--card-width);
    height: var(--card-height);
    background: linear-gradient(135deg, #383850, var(--card-bg));
    border-radius: 15px;
    display: flex;
    flex-direction: column;
    padding: 12px;
    cursor: pointer;
    position: relative;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 3px 6px 12px rgba(0, 0, 0, 0.4), inset 0 0 8px rgba(255, 255, 255, 0.05);
    transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                box-shadow 0.3s ease, 
                border-color 0.3s ease,
                opacity 0.3s ease;
    transform-origin: center bottom;
    overflow: hidden;
    z-index: 1;
}

/* Card inner glow effect */
.card::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, 
                              rgba(255, 255, 255, 0.1) 0%, 
                              rgba(255, 255, 255, 0) 50%);
    pointer-events: none;
    z-index: -1;
}

/* Card hover highlight effect */
.card::after {
    content: '';
    position: absolute;
    top: -150%;
    left: -150%;
    width: 400%;
    height: 400%;
    background: radial-gradient(ellipse at center, 
                              rgba(255, 204, 0, 0.4), transparent 70%);
    opacity: 0;
    transition: opacity var(--anim-medium) ease;
    pointer-events: none;
    z-index: -1;
}

.card:hover {
    transform: translateY(-20px) scale(1.08);
    box-shadow: 0 15px 25px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.15);
    border-color: var(--primary-color);
    z-index: 10;
}

.card:hover::after {
    opacity: 0.2;
}

/* Card position adjustment for fan effect */
.card-hand .card:nth-child(odd) {
    transform: rotate(-1deg);
}

.card-hand .card:nth-child(even) {
    transform: rotate(1deg);
}

.card-hand .card:hover {
    transform: translateY(-20px) scale(1.08) rotate(0deg);
}

.card-mana {
    position: absolute;
    top: 6px;
    right: 6px;
    width: 30px;
    height: 30px;
    background: radial-gradient(circle at center, var(--secondary-color), #2a70df);
    color: white;
    border-radius: 50%;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: bold;
    font-size: 16px;
    border: 2px solid #fff;
    box-shadow: 0 0 8px rgba(74, 144, 255, 0.7);
    z-index: 1;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
}

.card-name {
    font-weight: bold;
    text-align: center;
    margin-top: 22px;
    margin-bottom: 8px;
    color: var(--primary-color);
    font-size: 15px;
    letter-spacing: 0.5px;
    text-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
}

.card-icon {
    font-size: 38px;
    text-align: center;
    margin: 10px 0;
    flex-shrink: 0;
    height: 45px;
}

.card-icon-image {
    width: 45px;
    height: 45px;
    image-rendering: pixelated;
    display: block;
    margin: 0 auto;
    filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.5));
    transition: transform var(--anim-fast) ease;
}

.card:hover .card-icon-image {
    transform: scale(1.1) rotate(5deg);
    filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.7));
}
        .card-description {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            /* Hintergrund: Leicht transparent + Backdrop Filter */
            background-color: rgba(44, 48, 58, 0.75); /* Angepasst an --card-bg, mit Transparenz */
            backdrop-filter: blur(5px);              /* Weichzeichner für den Hintergrund */
            -webkit-backdrop-filter: blur(5px);      /* Für Safari */
            color: var(--text-color);
            padding: 12px; /* Etwas mehr Padding */
            font-size: 0.8em; /* Etwas größer für Lesbarkeit */
            line-height: 1.4;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7); /* Textschatten für Kontrast */
            border-top: 1px solid rgba(255, 255, 255, 0.1); /* Sehr subtile obere Linie */
            border-radius: 0 0 10px 10px; /* Nur untere Ecken abrunden (passend zur Karte) */

            /* Standardmäßig ausblenden */
            opacity: 0;
            transform: translateY(20px); /* Startet etwas weiter unten und faded ein */
            visibility: hidden;
            pointer-events: none;

            /* Übergang */
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s linear 0.25s;
            z-index: 2;
        }

        .card-power {
           text-align: center;
           font-size: 1.4em; /* Größer */
           font-weight: bold;
           margin-top: auto; /* Schiebt es nach unten */
           margin-bottom: 10px;
           color: var(--text-color); /* Standardmäßig weiß */
           padding: 4px 6px;
           background-color: rgba(0,0,0,0.3);
           border-radius: 6px;
           visibility: visible;
           align-self: center; /* Zentriert horizontal */
           min-width: 30px; /* Damit es nicht zu schmal wird */
        }
         /* Farben für Power basierend auf Kartentyp (Beispiele) */
        .card[data-card-type="attack"] .card-power { color: var(--accent-color-lighter); }
        .card[data-card-type="block"] .card-power { color: #80deea; } /* Türkis */
        .card[data-card-type="heal"] .card-power { color: var(--player-color-lighter); }
    
        .card-power.hidden-power {
            visibility: hidden;
        }
        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #444;
            background: linear-gradient(145deg, #555, #3a3a3a);
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(0,0,0,0.4);
            filter: grayscale(80%);
            transform-style: flat; /* Kein 3D für disabled */
        }
        .card.disabled:hover {
            transform: none; /* Kein Hover-Effekt */
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(0,0,0,0.4);
            border-color: #444;
        }
        .card.disabled::before {
            opacity: 0; /* Kein Glanz */
        }
        .card:hover .card-description {
            opacity: 1;
            transform: translateY(0); /* auf Endposition fahren */
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s linear 0s;
        }

    
        /* --- Action Buttons --- */
         .action-buttons-vertical { /* Wrapper für Buttons neben der Hand */
            display: flex;
            flex-direction: column;
            gap: 12px;
            align-items: center; /* Zentriert Buttons horizontal */
            padding-top: 20px; /* Vertikaler Abstand von oben */
        }
    
        button {
            background: linear-gradient(to bottom, var(--primary-color), #d4a106); /* Gold-Gradient */
            color: #333; /* Dunkler Text für Kontrast */
            border: none;
            padding: 12px 25px; /* Größer */
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600; /* Semibold */
            font-size: 1em; /* Größer */
            font-family: 'Poppins', sans-serif; /* Sicherstellen */
            transition: all 0.2s ease-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 -2px 2px rgba(0,0,0,0.2);
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
        }
        button:hover:not(:disabled) {
            background: linear-gradient(to bottom, #ffce3a, var(--primary-color)); /* Heller */
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 -1px 1px rgba(0,0,0,0.1), 0 0 10px var(--glow-primary); /* Leichter Glow */
        }
        button:active:not(:disabled) {
            transform: translateY(1px); /* Nach unten drücken */
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.3); /* Innerer Schatten */
            filter: brightness(0.95);
        }
        button:disabled {
            background: linear-gradient(to bottom, #777, #555); /* Grau-Gradient */
            color: #aaa;
            cursor: not-allowed;
            transform: none;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.4); /* Deutlicher innerer Schatten */
            text-shadow: none;
            filter: grayscale(50%);
        }
    
        /* Spezielle Button-Farben */
        #manaBoostBtn {
            background: linear-gradient(to bottom, #90aaff, #6b8fff);
            color: #fff;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
        }
        #manaBoostBtn:hover:not(:disabled) {
            background: linear-gradient(to bottom, #4a79d9, #365fc4); /* kräftiges Dunkelblau */
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4),
                        inset 0 -1px 1px rgba(0, 0, 0, 0.1),
                        0 0 10px rgba(41, 121, 255, 0.5);
        }
         #manaBoostBtn:disabled {
            background: linear-gradient(to bottom, #6a7081, #454a59) !important;
            color: #999 !important;
            cursor: not-allowed;
            filter: grayscale(70%);
             box-shadow: inset 0 2px 5px rgba(0,0,0,0.4) !important;
        }
    
        /* --- Message Log --- */
        .message-log {
            height: 130px; /* Etwas höher */
            background-color: rgba(0,0,0,0.25);
            border-radius: 8px;
            padding: 12px 15px; /* Mehr Padding */
            overflow-y: auto;
            margin-top: 20px;
            font-size: 0.8em; /* Etwas kleiner für Log */
            line-height: 1.5; /* Mehr Zeilenabstand */
            border: 1px solid var(--border-color);
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.4);
            color: var(--text-color-secondary); /* Standardmäßig grau */
        }
        /* Scrollbar-Styling (Webkit-Browser) */
        .message-log::-webkit-scrollbar { width: 8px; }
        .message-log::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px; }
        .message-log::-webkit-scrollbar-thumb { background-color: var(--border-color-light); border-radius: 4px; border: 2px solid transparent; background-clip: content-box; }
        .message-log::-webkit-scrollbar-thumb:hover { background-color: var(--primary-color); }
    
        .message { margin-bottom: 5px; }
        /* Nachrichtentypen hervorheben */
        .message.player { color: var(--secondary-color-lighter); } /* Blau für Spieleraktionen */
        .message.enemy { color: var(--accent-color-lighter); } /* Rot für Gegneraktionen */
        .message.system { color: var(--primary-color); font-weight: 600; } /* Gold für Systemnachrichten */
        .message.xp { color: #a5d6a7; } /* Grünlich für XP */
        .message.mana { color: #b39ddb; } /* Lila für Mana */
        .message.lifesteal { color: #ffcc80; } /* Orange für Lebensraub */
        .message.discard { color: #9e9e9e; font-style: italic; } /* Grau für Abwurf */
        .message.block { color: #80deea; } /* Türkis für Block */
        .message.heal { color: #c5e1a5; } /* Hellgrün für Heilung */
        .message.poison { color: #ce93d8; } /* Violett für Gift */
    
    
        /* --- Overlays (Upgrade, Game Over) --- */
        .overlay-container {
            display: none;
        }
        .overlay-container.visible {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .overlay-box {
            background-color: var(--card-bg);
            padding: 30px 40px;
            border-radius: 15px;
            border: 1px solid var(--border-color-light);
            text-align: center;
            max-width: 700px; /* Beispielbreite */
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            position: relative; /* Für eventuelle Schließen-Buttons */

            /* Leichte Animation beim Erscheinen */
            transform: scale(0.95);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1); /* Etwas "federnder" */
        }
        .overlay-container.visible .overlay-box {
            transform: scale(1); /* Skaliert auf volle Größe */
        }
        /* Optional: Schließen-Button für Overlays */
        .close-overlay-btn {
            position: absolute;
            top: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-color-secondary);
            border-radius: 50%;
            width: 30px; height: 30px;
            font-size: 1.2em;
            line-height: 28px; /* Zentriert das X */
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 101;
        }
        .close-overlay-btn:hover {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            transform: rotate(90deg);
        }
    
        /* --- Upgrade Screen --- */
        .upgrade-container {
            display: flex;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .upgrade-box { /* Nutzt .overlay-box */
            border-color: var(--primary-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7), 0 0 20px var(--glow-primary);
            max-width: 700px; /* Breite für Upgrades */
        }
        .upgrade-title {
            margin-bottom: 25px;
            color: var(--primary-color);
            font-size: 1.8em;
        }
        .upgrade-options {
            display: flex;
            gap: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }
        .upgrade-option {
            background-color: #3a3f4c; /* Etwas heller als Karten */
            padding: 20px;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            width: 180px; /* Feste Breite */
            min-height: 120px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            text-align: left; /* Besser für Text */
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }
         .upgrade-option h3 {
            margin: 0 0 10px 0;
            font-size: 1.1em;
            color: var(--primary-color);
         }
         .upgrade-option p {
            margin: 0;
            font-size: 0.85em;
            color: var(--text-color-secondary);
            line-height: 1.4;
         }
         .upgrade-option:hover {
            transform: translateY(-5px) scale(1.03);
            background-color: #454a59;
            border-color: var(--primary-color);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 10px var(--glow-primary);
         }
        /* Upgrade Raritäten */
        .upgrade-option.rare {
            border-color: var(--rare-color);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3), 0 0 10px var(--glow-rare);
        }
        .upgrade-option.rare h3 { color: var(--rare-color); }
        .upgrade-option.rare:hover {
            border-color: var(--rare-color); /* Behält die Farbe bei */
            background-color: #503a5a; /* Lila-Ton */
            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 15px var(--glow-rare);
        }
    
        /* --- Game Over Screen --- */
        .game-over-container { /* Nutzt .overlay-container */
            background-color: rgba(50, 10, 10, 0.7); /* Rötlicherer Hintergrund */
        }
        .game-over-box { /* Nutzt .overlay-box */
            border-color: var(--accent-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7), 0 0 20px var(--glow-enemy);
        }
         .game-over-box h2 {
            color: var(--accent-color);
            font-size: 3em; /* Groß */
            margin-bottom: 25px;
            text-shadow: 0 0 8px var(--glow-enemy);
            border: none; /* Keine Unterlinie hier */
         }
        .highscore {
            font-size: 1.4em;
            margin-bottom: 15px;
            color: var(--text-color);
        }
         .highscore span { /* Highscore Zahl */
            color: var(--primary-color);
            font-weight: bold;
            font-size: 1.2em; /* Größer als der Text */
            display: inline-block;
            margin-left: 10px;
         }
         #restartBtn {
            margin-top: 35px;
            padding: 15px 35px; /* Größerer Button */
            font-size: 1.2em;
            background: linear-gradient(to bottom, var(--player-color-lighter), var(--player-color)); /* Grün für Neustart */
            color: white;
         }
         #restartBtn:hover:not(:disabled) {
            background: linear-gradient(to bottom, #90ee90, var(--player-color-lighter));
             box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 -1px 1px rgba(0,0,0,0.1), 0 0 10px var(--glow-player);
         }

        /* --- Shop Screen --- */
        #shopScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none; /* Wird durch JavaScript auf 'flex' gesetzt */
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5); /* Halbtransparenter Hintergrund */
            z-index: 9999; /* Sicherstellen, dass es über anderen Elementen liegt */
        }
        #shopScreen.visible {
            display: flex !important;
            opacity: 1;
            pointer-events: auto;
            visibility: visible;
        }

        .shop-box {
            border-color: gold;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7), 0 0 20px gold;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            padding: 25px;
        }

         /* Scrollbar für Shop (Webkit) */
        .shop-box::-webkit-scrollbar { width: 10px; }
        .shop-box::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 5px; }
        .shop-box::-webkit-scrollbar-thumb { background-color: var(--border-color-light); border-radius: 5px; border: 2px solid transparent; background-clip: content-box; }
        .shop-box::-webkit-scrollbar-thumb:hover { background-color: var(--primary-color); }
    
        #shopTitle {
            color: gold; /* Gold für den Shop-Titel */
            font-size: 2em;
            margin-bottom: 20px;
            text-shadow: 0 0 6px gold;
        }
        #shopItems {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 16px;
            }
        .shop-item {
            display: flex;
            flex-direction: column; /* Besser für Inhalt untereinander */
            align-items: center; /* Zentriert alles */
            background-color: #444;
            border-radius: 12px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid var(--border-color);
            gap: 10px; /* Abstand zwischen Elementen */
            position: relative; /* Für Tooltip */
            text-align: center; /* Text zentrieren */
            box-shadow: 0 3px 7px rgba(0,0,0,0.4);
        }
        .shop-item:hover {
            background-color: #555;
            border-color: gold;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5), 0 0 10px gold;
        }
         .shop-item.purchased { /* Stil für gekaufte/nicht verfügbare Items */
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
            filter: grayscale(80%);
         }
        .shop-item.purchased:hover {
            background-color: #444;
            transform: none;
            box-shadow: 0 3px 7px rgba(0,0,0,0.4);
        }
        .shop-image {
            width: 80px; /* Kleinere Bilder im Grid */
            height: 80px;
            image-rendering: pixelated;
            border: 2px solid #aaa;
            border-radius: 8px;
            margin-bottom: 10px; /* Abstand zum Text */
        }
        .shop-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
         .shop-item-name {
            font-weight: 600;
            font-size: 1.1em;
            color: var(--text-color);
         }
        .shop-item-desc {
            font-size: 0.8em;
            color: var(--text-color-secondary);
            min-height: 30px; /* Platz für kurze Beschreibung */
        }
        .shop-price {
            font-size: 1.2em;
            color: gold;
            margin-top: auto; /* Schiebt Preis nach unten */
            font-weight: bold;
        }
        /* Shop Tooltip (einfacher als Monster Trait) */
        .shop-item[data-tooltip]:hover::after {
           content: attr(data-tooltip);
           position: absolute;
           bottom: calc(100% + 5px); /* Über dem Item */
           left: 50%;
           transform: translateX(-50%);
           background: rgba(10, 10, 15, 0.95);
           color: white;
           font-size: 0.8em;
           padding: 6px 10px;
           border-radius: 6px;
           white-space: normal;
           text-align: center;
           z-index: 1001;
           pointer-events: none;
           width: max-content;
           max-width: 200px;
           opacity: 0;
           animation: tooltipFadeIn 0.3s ease forwards;
        }
        .shop-footer {
        margin-top: 20px;
        display: flex;
        justify-content: center;
        gap: 20px;
        }

        #skipShopBtn,
        #closeShopBtn {
        padding: 10px 20px;
        font-size: 1em;
        border-radius: 8px;
        border: none;
        background: linear-gradient(to bottom, #888, #666);
        color: white;
        cursor: pointer;
        transition: all 0.2s ease;
        }

        #skipShopBtn:hover,
        #closeShopBtn:hover {
        background: linear-gradient(to bottom, #999, #777);
        }

        #shopContainer {
            display: none;
        }
        #shopContainer.visible {
            display: flex !important;
        }

        .shop-icon-wrapper {
        display: inline-block;
        position: relative;
        }

        #shopIconBtn {
        width: 60px;
        height: 60px;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        border: 2px solid rgb(49, 97, 255);
        border-radius: 10px;
        padding: 4px;
        background-color: rgba(0, 0, 0, 0.3);
        box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        #shopIconBtn:hover {
        transform: scale(1.15);
        box-shadow: 0 0 15px gold;
        }

        .shop-icon-wrapper::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: 120%;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.85);
        color: white;
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        white-space: nowrap;
        opacity: 0;
        transition: opacity 0.2s ease;
        pointer-events: none;
        z-index: 100;
        }

        .shop-icon-wrapper:hover::after {
        opacity: 1;
        }


        /* --- Animationen & Effekte --- */
        .enemy-animation { /* Wird bereits vom enemy-container genutzt */ }
        .enemy-animation.hit {
            animation: strongShake 0.35s ease-out; /* Verwendet verbesserte Shake-Animation */
            filter: brightness(1.4) saturate(1.6);
        }
        .enemy-animation.defeat {
            opacity: 0;
            transform: translateY(-80px) scale(0.6) rotate(-20deg);
            transition: transform 0.6s cubic-bezier(0.68, -0.6, 0.27, 1.6), opacity 0.5s ease-out; /* Dynamischere Kurve */
            filter: grayscale(100%) brightness(0.5); /* Ausgrauen und abdunkeln */
        }
        .card-animation { /* Klasse für Karten, die animiert werden (z.B. ziehen) */ }
        .card-animation.played {
            transform: translateY(-200px) scale(0.2) rotate(35deg); /* Fliegt weiter weg */
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.4, 0.8, 0.7, 0.2), opacity 0.4s ease-out;
            /* Wichtig: Animation auf der Karte selbst oder einem Wrapper ausführen */
        }
        .player-status .status-effect, .item-icon { /* Animation für neu hinzugefügte Effekte/Items */
            animation: popIn 0.3s ease-out;
        }
    
        @keyframes strongShake { /* Verbesserter Shake */
          0% { transform: translate(0, 0) rotate(0); filter: brightness(1.4) saturate(1.6); }
          15% { transform: translate(-1px, 0) rotate(-0.2deg); }
          30% { transform: translate(1px, 0) rotate(0.2deg); }
          45% { transform: translate(-1px, 0) rotate(-0.2deg); }
          60% { transform: translate(1px, 0) rotate(0.2deg); }
          75% { transform: translate(-1px, 0) rotate(-0.2deg); }
          90% { transform: translate(1px, 0) rotate(0.2deg); }
          100% { transform: translate(0, 0) rotate(0); filter: brightness(1); } /* Filter zurücksetzen */
        }
    
        @keyframes gentleBob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); } /* Etwas mehr Bewegung */
        }
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }
    
        /* --- Spieler Status Effekte & Items --- */
        .player-status {
            display: flex;
            justify-content: center;
            align-items: center; /* Vertikal zentrieren */
            gap: 8px; /* Mehr Abstand */
            margin-top: 8px;
            margin-bottom: 10px; /* Abstand zur Stats-Leiste */
            flex-wrap: wrap;
            font-size: 0.8em; /* Kleinere Schrift */
            color: #fff;
            min-height: 30px; /* Mindesthöhe, damit es nicht springt */
        }
        .player-status .status-effect {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 4px 8px;
            border-radius: 10px; /* Runder */
            border: 1px solid var(--border-color);
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.4);
            display: inline-flex; /* Für align-items */
            align-items: center;
            gap: 4px;
        }
         /* Icons für Status-Effekte (Beispiel) */
        .status-effect .icon {
            font-style: normal; /* Damit Emojis nicht kursiv sind */
            font-size: 1.1em;
        }
        .status-effect.buff { color: var(--player-color-lighter); border-color: var(--player-color); }
        .status-effect.debuff { color: var(--accent-color-lighter); border-color: var(--accent-color); }

        .item-icon {
            width: 28px; /* Größer */
            height: 28px;
            image-rendering: pixelated;
            vertical-align: middle;
            border: 2px solid var(--player-color); /* Spielerfarbe als Standard */
            border-radius: 6px;
            box-shadow: 0 0 5px var(--glow-player); /* Leichter Glow */
            background-color: rgba(0,0,0,0.3); /* Hintergrund, falls Bild transparent */
            display: inline-block; /* Korrekte Darstellung */
        }
                    /* Tooltip-Box */
        .item-icon-wrapper {
            position: relative;
            display: inline-block;
            margin-right: 6px;
        }

        .item-icon-wrapper::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 5px;
            white-space: nowrap;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .item-icon-wrapper::before {
            content: '';
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .item-icon-wrapper:hover::after,
        .item-icon-wrapper:hover::before {
            opacity: 1;
        }

        .upgrade-option.superrare {
            position: relative;
            background: linear-gradient(
                270deg,
                #222,
                #332244,
                #098181,
                #442255,
                #223344,
                #222
            );
            background-size: 800% 800%;
            animation: darkRainbow 12s ease infinite;

            border: 2px solid #ffeb3b;
            box-shadow:
                0 0 10px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.4),
                inset 0 0 10px rgba(255, 235, 59, 0.2);
            
            color: #ffeb3b;
            font-weight: bold;
            text-shadow: 0 0 6px #ffeb3b;

            overflow: hidden;
        }

        /* Animation für den Regenbogen-Hintergrund */
        @keyframes darkRainbow {
            0%   { background-position: 0% 50%; }
            50%  { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .card.superrare {
            position: relative;
            background: linear-gradient(
                270deg,
                #222,
                #332244,
                #098181,
                #442255,
                #223344,
                #222
            );
            background-size: 800% 800%;
            animation: darkRainbow 12s ease infinite;

            border: 2px solid #ffeb3b;
            box-shadow:
                0 0 10px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.4),
                inset 0 0 10px rgba(255, 235, 59, 0.2);

            color: #ffeb3b;
            font-weight: bold;
            text-shadow: 0 0 6px #ffeb3b;
            overflow: hidden;
        }
        .upgrade-option {
            background-color: #333;
            color: white;
            border: 2px solid #666;
            border-radius: 10px;
            padding: 10px;
            margin: 10px;
            cursor: pointer;
            width: 200px;
            text-align: center;
            transition: transform 0.2s ease;
        }

        .upgrade-option:hover {
            transform: scale(1.05);
            border-color: #ccc;
            background-color: #444;
        }

        .upgrade-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 15px;
            flex-wrap: wrap;
        }

        .status-effect[data-tooltip] {
            position: relative;
            cursor: help;
            display: inline-block;
        }

        .status-effect[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;           /* ← Keine Umbrüche! */
            max-width: none;               /* ← Keine feste Breite */
            word-break: normal;
            overflow-wrap: normal;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }

        .status-effect[data-tooltip]:hover::after {
            opacity: 1;
        }
        .minion-box.hellhound {
            border: 2px solid crimson;
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.7);
        }

    
    </style>
</head>
<body>
    <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <h1>Sigma The Game</h1>

    <div id="gameContainer" class="game-container">
        <div class="stats-container">
            <div class="stats-column">
                <div>Runde: <span id="round">1</span></div>
                <div>Besiegt: <span id="defeatedEnemies">0</span></div>
            </div>
            <div class="stats-column">
                <div>Level: <span id="playerLevel">1</span></div>
                <div>XP: <span id="playerXP">0</span> / <span id="xpToNextLevel">100</span></div>
            </div>
            <div class="stats-column">
                 <div>Max Mana: <span id="playerMaxManaDisplay">3</span></div> <div>Handgröße: <span id="maxHandSizeDisplay">5</span></div>
            </div>
             <div class="stats-column">
                 <div>Update: <span id="playerLifestealDisplay">1.22</span>%</div>
                 <div>Highscore: <span id="highScoreDisplay">0</span></div>
            </div>
        </div>

        <div class="battle-area-wrapper">
            <div class="battle-area">
                <!-- Spieleranzeige -->
                
                <div id="playerDisplay" class="player-display">
                    <!-- Spielername und Goldanzeige -->
                    <div class="player-header">
                        <div class="player-name">Spieler</div>
                        <div class="player-gold">💰 Gold: <span id="playerGoldDisplay">0</span></div>
                    </div>
                
                    <!-- Spielerbild -->
                    <div class="player-image" id="playerImage"></div>
                    <div id="petContainer"></div>
                
                    <!-- Statusanzeige (Effekte & Items) -->
                    <div class="player-status-container">
                        <div class="player-status" id="playerStatusDisplay"></div>
                        <div class="player-items" id="playerItemIcons"></div>
                    </div>
                
                    <!-- Spielerstatistiken -->
                    <div class="player-stats">
                
                        <div class="stat-text">🛡 Block: <span id="playerBlock" class="block-value">0</span></div>
                
                        <div class="stat-text">Leben: <span id="playerHealth">50</span>/<span id="playerMaxHealth">50</span></div>
                        <div class="health-bar" id="playerHealthBar">
                            <div class="health-fill" style="width: 100%;"></div>
                        </div>
                
                        <div class="stat-text">Mana: <span id="playerMana">3</span>/<span id="playerMaxMana">3</span></div>
                        <div class="mana-bar">
                            <div class="mana-fill" id="playerManaBar" style="width: 100%;"></div>
                        </div>
                
                    </div>
                </div>
                
        
                <!-- Gegneranzeige -->
                <div id="enemyContainer" class="enemy-container enemy-animation">
                    <div class="enemy-name" id="enemyName">Gegner</div>
                    <div class="monster-image" id="monsterImage"></div>
                    <div id="enemyMinions" class="enemy-minions"></div>
                    <div class="monster-traits" id="monsterTraits"></div>
        
                    <div class="enemy-stats-display">
                        <div class="stat-text">Leben: <span id="enemyHealth">10</span>/<span id="enemyMaxHealth">10</span></div>
                        <div class="health-bar" id="enemyHealthBar">
                            <div class="health-fill" style="width: 100%;"></div>
                        </div>
        
                        <div class="stat-text">Angriff: <span id="enemyAttack">2</span></div>
                    </div>
        
                    <div class="enemy-info" id="enemyInfo">Infos zum Gegner...</div>
                </div>
            </div>
        </div>
        

        <div class="card-hand-container" style="position: relative;">
            
            <div class="card-hand-toolbar">
                <button id="manaBoostBtn">Mana Boost (Volles Mana, Runde zuende)</button>
                <button id="endTurnBtn">Zug beenden</button>
              </div>
        
            <h2>Deine Karten (<span id="currentHandSize">0</span>/<span id="maxHandSizeDisplay2">5</span>)</h2>         
        
            <div class="card-hand-action-wrapper">
                <div id="cardHand" class="card-hand"></div>
            </div>
        </div>            

        <div id="messageLog" class="message-log">
            </div>
    </div>

    <div id="upgradeContainer" class="overlay-container upgrade-container">
        <div class="overlay-box upgrade-box">
          <h2 class="upgrade-title">Wähle ein Upgrade!</h2>
          <div class="upgrade-options" id="upgradeOptions">
            <!-- Upgrades werden hier eingefügt -->
          </div>
      
          <!-- Shop-Icon unten zentriert mit Tooltip -->
          <div id="shopIconContainer" style="margin-top: 20px; text-align: center;">
            <div class="shop-icon-wrapper" data-tooltip="Shop öffnen. Falls du ein Item Kaufst schließen sich die Upgrades!">
              <img 
                src="images/shop-chest.png" 
                alt="Shop öffnen" 
                id="shopIconBtn"
              />
            </div>
          </div>
        </div>
      </div>
      
    
<!-- Ändere einfach die ID -->
<div id="shopScreen" style="display: none;">
    <div class="overlay-box shop-box">
      <h3 id="shopTitle">🛒 Shop: Du hast <span id="shopGoldAmount"></span></h3>
      <div id="shopItems" class="shop-items"></div>
      <div class="shop-footer">
        <button id="skipShopBtn">Shop schließen</button>
      </div>
    </div>
  </div>
     
      
        </div>
      </div>
      
    
    <div id="gameOverContainer" class="game-over-container" style="display: none;"> <h2>Game Over!</h2>
        <div class="highscore">Besiegte Gegner: <span id="finalScore">0</span></div>
        <div class="highscore">Höchste Runde: <span id="finalRound">0</span></div>
        <div class="highscore">Endlevel: <span id="finalLevel">0</span></div>
        <button id="restartBtn">Neues Spiel</button>
    </div>

    <script>
        // --- Firebase Initialisierung ---
        const firebaseConfig = {
            apiKey: "AIzaSyCSn9mCvNT6JZgXy5ZTIOeVhri4FQRvn9E",
            authDomain: "sigma-the-game.firebaseapp.com",
            databaseURL: "https://sigma-the-game-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "sigma-the-game",
            storageBucket: "sigma-the-game.appspot.com",
            messagingSenderId: "346310580482",
            appId: "1:346310580482:web:a7e6f835eb4dd541964a1b"
            };


            firebase.initializeApp(firebaseConfig);
            const db = firebase.firestore();

        // --- Spielkonstanten ---
        const CARD_TYPES = [
            // ... (deine Kartendefinitionen bleiben hier unverändert) ...
                 { id: 1, name: 'Schwert', icon: '⚔️', description: 'Ein einfaches Schwert.', power: 5, effect: 'damage', manaCost: 2, weight: 11, tags: ['sword'] },
                 { id: 2, name: 'Schild', icon: '🛡️', description: 'Erhalte 5 Block', power: 5, effect: 'block', manaCost: 2, weight: 1 },
                 { id: 3, name: 'Heilung', icon: '❤️', description: 'Heilt 8 Leben', power: 8, effect: 'heal', manaCost: 3, weight: 1 },
                 { id: 4, name: 'Gift', icon: '☠️', description: 'Vergiftet (2 Schaden, 3 Rd.) Falls bereit Vergiftet mache 3 Schaden', power: 2, duration: 3, effect: 'poison', manaCost: 1, weight: 1 },
                 { id: 5, name: 'Blitz', icon: '⚡', description: '12 Schaden, Paralysiert Gegner zu 45% (Halbiert den Angriff 2 Runden)', power: 12, effect: 'damage_paralyze', manaCost: 4, weight: 2 },
                 { id: 6, name: 'Großer Schlag', icon: '💥', description: 'Fügt 15 Schaden zu', power: 15, effect: 'damage', manaCost: 4, weight: 2 },
                 { id: 7, name: 'Meditieren', icon: '🧘', description: 'Ziehe 1 Karte', power: 1, effect: 'draw', manaCost: 0, weight: 1 },
                 { id: 8, name: 'Vampirbiss', icon: '🧛', description: '8 Schaden, heilt 8', power: 8, healAmount: 8, effect: 'lifesteal', manaCost: 4, weight: 2 }, // Direkte Heilung statt %
                 { id: 9, name: 'Manatrank', icon: '🧪', description: 'Erhalte 2 Mana', power: 2, effect: 'gain_mana', manaCost: 0, weight: 3 },
                 { id: 10, name: 'Fokus', icon: '🎯', description: 'Ziehe 2 Karten', power: 2, effect: 'draw', manaCost: 1, weight: 1 },
                 { id: 11, name: 'Heilige Macht', icon: '✨', description: 'Fügt 25 Schaden zu', power: 25, effect: 'damage', manaCost: 6, weight: 1 },
                 { id: 12, name: 'Genesung', icon: '💖', description: 'Heilt 15 Leben', power: 15, effect: 'heal', manaCost: 5, weight: 1 },
                 {id: 13, name: 'Feuerpfeil', icon: '🔥', description: 'Fügt 12 Schaden zu. 50% Chance auf Verbrennung (5 Schaden für 2 Runden).', power: 12, effect: 'firearrow', manaCost: 5, weight: 2},
                 {id: 14, name: 'Gambler’s Luck', icon: '🎲', description: 'Gegner nimmt 5 Schaden und du erhältst 100 Gold (Ignoriert Block) oder Du nimmst 5 Schaden.', power: 5, effect: 'gamble', manaCost: 0, weight: 1},
                 { id: 15, name: 'Kraft Sammeln', icon: '🔋', description: 'Heilt dich um dein gesamtes Mana.<br><br>Einmaliger Schadensboost i.H.v. Manakosten -1', power: 0, effect: 'power_surge', manaCost: 'X', weight: 1 },
                 {id: 16, name: 'Klingenwirbel', icon: '🌀', description: 'Greift mehrere Gegner gleichzeitig an. (Ignoriert Block.)', power: 8, effect: 'whirlwind', manaCost: 3, weight: 2},
                 {id: 17, name: 'Todesklinge', icon: '⚔️', description: 'Die stärkste aller Schwerter. 25 Schaden.', power: 25, effect: 'damage', manaCost: 4, weight: 1, tags: ['sword'], rarity: 'superrare'},
                 {id: 18, name: 'Mana Oase', icon: '🧪', description: 'Erhalte 5 Mana', power: 5, effect: 'gain_mana', manaCost: 0, weight: 1, rarity: 'superrare'},
                 {id: 19, name: 'Blutrausch', icon: '🧛', description: '20 Schaden, heilt 12', power: 20, healAmount: 12, effect: 'lifesteal', manaCost: 7, weight: 1, rarity: 'superrare'},
                 { id: 20, name: 'Unwetter', icon: '🌩️', description: 'Paralysiere den Gegner (Halbiert den Angriff 2 Runden)', power: 0, effect: 'paralyze', manaCost: 1, weight: 2 },

        ];
    
        // --- Bildpfade ---
        const IMAGE_FOLDER = 'images/';
        const ENEMY_PIXEL_PLACEHOLDERS = {
            // ... (deine Bildpfade bleiben hier unverändert) ...
                'Goblin': IMAGE_FOLDER + 'Goblin.png',
                'Ork': IMAGE_FOLDER + 'Ork.png',
                'Troll': IMAGE_FOLDER + 'Troll.png',
                'Dämon': IMAGE_FOLDER + 'Demon.png', // Umlaut vermieden
                'Baby Drache': IMAGE_FOLDER + 'BabyDrache.png', // Leerzeichen vermieden
                'Nekromant': IMAGE_FOLDER + 'Nekromant.png', // Umlaut vermieden
                'Riesen Spinne': IMAGE_FOLDER + 'Spinne.png', // Leerzeichen vermieden
                'Eiskönig': IMAGE_FOLDER + 'Eiskönig.png', // Umlaut vermieden
                'Erzengel': IMAGE_FOLDER + 'Erzengel.png',
                'Dracula': IMAGE_FOLDER + 'Drakula.png',
                'Drache': IMAGE_FOLDER + 'Drache.png',
                'Verfluchter Ritter': IMAGE_FOLDER + 'CursedKnight.png',
                'Gepanzertes Skelett': IMAGE_FOLDER + 'armorskelett.png',
                'Donnerschlange': IMAGE_FOLDER + 'snake.png',
                'Charged Golem': IMAGE_FOLDER + 'golem.png',
                'Gargoyle': IMAGE_FOLDER + 'gargoyle.png',
                'hund': IMAGE_FOLDER + 'hund.png',
                'Teufel': IMAGE_FOLDER + 'teufel.png',
                'Rainbow': IMAGE_FOLDER + 'rainbow.png',
                'Yagdril': IMAGE_FOLDER + 'yagdril.png'
        };
        const PLAYER_PIXEL_IMAGE = IMAGE_FOLDER + 'Spieler.png';
    
        // --- Gegnertypen ---
        const ENEMY_TYPES = [
            // ... (deine Gegnertypen bleiben hier unverändert) ...
                { name: 'Goblin', health: 20, attack: 5, levelMin: 1, levelMax: 5, xp: 35, gold: 70, pixelImageKey: 'Goblin', description: 'Ein kleiner, flinker Goblin.', traits: ['Keine Fähigkeit'] },
                { name: 'Gepanzertes Skelett', health: 25, attack: 4, levelMin: 2, levelMax: 6, xp: 55, gold: 85, pixelImageKey: 'Gepanzertes Skelett', description: 'Ein ehmaliger stolzer Krieger.', traits: ['Rüstung'] },
                { name: 'Ork', health: 35, attack: 5, levelMin: 3, levelMax: 7, xp: 60, gold: 65, pixelImageKey: 'Ork', description: 'Ein brutaler Ork-Krieger.', traits: ['Stark'] },
                { name: 'Riesen Spinne', health: 40, attack: 6, levelMin: 4, levelMax: 7, xp: 65, gold: 110, pixelImageKey: 'Riesen Spinne', description: 'Spuckt lähmendes Gift.', traits: ['Giftig'] }, // 'Netzwerfer' Effekt muss implementiert werden
                { name: 'Troll', health: 50, attack: 8, levelMin: 5, levelMax: 9, xp: 70, gold: 120, pixelImageKey: 'Troll', description: 'Regeneriert 3 Leben pro Runde.', traits: ['Regeneration', 'Massiv'], regen: 3 }, // Regeneration implementiert
                { name: 'Donnerschlange', health: 45, attack: 9, levelMin: 6, levelMax: 10, xp: 120, gold: 135, pixelImageKey: 'Donnerschlange', description: 'Eine lähmende Donnerschlange', traits: ['Statisch'] },
                { name: 'Nekromant', health: 50, attack: 7, levelMin: 8, levelMax: 12, xp: 80, gold: 160, pixelImageKey: 'Nekromant', description: 'Schwächt dich oder ruft Diener.', traits: ['Untotenbeschwörer'] }, // Effekte müssen implementiert werden
                { name: 'Eiskönig', health: 65, attack: 9, levelMin: 9, levelMax: 13, xp: 100, gold: 180, pixelImageKey: 'Eiskönig', description: 'Verlangsamt dich mit Kälte.', traits: ['Eis-Elementar', 'Frost-Aura'] }, // Effekte müssen implementiert werden
                { name: 'Baby Drache', health: 60, attack: 11, levelMin: 10, levelMax: 14, xp: 120, gold: 210, pixelImageKey: 'Baby Drache', description: 'Speit Feuerstöße.', traits: ['Verspielt', 'Feueratem'] }, // Effekte müssen implementiert werden
                { name: 'Charged Golem', health: 70, attack: 9, levelMin: 11, levelMax: 15, xp: 170, gold: 240, pixelImageKey: 'Charged Golem', description: 'Mächtiger Elementar Golem.', traits: ['Statisch', 'Regeneration'], regen: 3 }, // Effekte müssen implementiert werden
                { name: 'Dracula', health: 65, attack: 9, levelMin: 12, levelMax: 16, xp: 190, gold: 280, pixelImageKey: 'Dracula', description: 'Dein Blut macht ihn stärker.', traits: ['Vamp', 'Stark'] }, // Effekte müssen implementiert werden
                { name: 'Dämon', health: 75, attack: 12, levelMin: 13, levelMax: 18, xp: 280, gold: 330, pixelImageKey: 'Dämon', description: 'Feuer und Schatten. Resistent.', traits: ['Höllen Krallen'] }, // Effekte müssen implementiert werden
                { name: 'Verfluchter Ritter', health: 70, attack: 9, levelMin: 14, levelMax: 18, xp: 360, gold: 400, pixelImageKey: 'Verfluchter Ritter', description: 'Ein wandelnde Geisterrüstung', traits: ['Rüstung', 'Krieger']}, // Effekte müssen implementiert werden
                { name: 'Erzengel', health: 90, attack: 12, levelMin: 15, levelMax: 19, xp: 400, gold: 450, pixelImageKey: 'Erzengel', description: 'Ein mächtiger gefallener Engel.', traits: ['Segen', 'Fliegend'] }, // Effekte müssen implementiert werden
                { name: 'Gargoyle', health: 95, attack: 14, levelMin: 16, levelMax: 20, xp: 450, gold: 480, pixelImageKey: 'Gargoyle', description: 'Einst da um die Menschen zu beschützen. Jetzt ein unbändiges Monster', traits: ['Gepanzerte Schuppen'] }, 
                { name: 'Drache', health: 110, attack: 16, levelMin: 17, levelMax: 21, xp: 650, gold: 520, pixelImageKey: 'Drache', description: 'Ein mächtiger, alter Drache.', traits: ['Feueratem', 'Fliegend', 'Gepanzerte Schuppen'] }, 
                { name: 'Teufel', health: 70, attack: 5, levelMin: 18, levelMax: 23, xp: 750, gold: 600, pixelImageKey: 'Teufel', description: 'Der Herrscher der Unterwelt.', traits: ['Höllenwache'] },
                { name: 'Rainbow', health: 90, attack: 10, levelMin: 19, levelMax: 24, xp: 800, gold: 750, pixelImageKey: 'Rainbow', description: 'Meister über alle Elemente', traits: ['Frost-Aura', 'Giftig', 'Feueratem', 'Statisch'] },
                { name: 'Yagdril', health: 130, attack: 20, levelMin: 20, levelMax: 100, xp: 1000, gold: 1000, pixelImageKey: 'Yagdril', description: 'Ein Wesen dessen Macht unbeschreiblich ist', traits: ['Fliegend', 'Segen'] } 
        ];
    
        // --- Upgrade-Typen ---
        const UPGRADE_TYPES = [
            // ... (deine Upgrade-Typen bleiben hier unverändert) ...
                 { type: 'newCardSpecific', title: 'Neue Karte wählen', description: 'Wähle 1 von 3 neuen Karten.', rarity: 'common' }, // Komplexer zu implementieren
                 { type: 'upgradeSwordPower', title: 'Schwertstärke +1', description: 'Erhöhe die Stärke deiner Schwerter um +1.', rarity: 'common' },
                 { type: 'upgradeHealth', title: 'Max Leben +8', description: 'Erhöhe dein maximales Leben um 8.', rarity: 'common' },
                 { type: 'healPercent', title: 'Heilung 50%', description: 'Stelle 50% deines max. Lebens wieder her.', rarity: 'common' },
                 { type: 'blackMarketGold', title: 'Schwarzmarkt', description: 'Entferne 1 Karte nach Wahl dauerhaft und erhalte dafür ein Gold Angebot', rarity: 'common' },
                 { type: 'upgradeMana', title: 'Max Mana +1', description: 'Erhöhe dein maximales Mana um 1.', rarity: 'rare' }, // Seltener
                 { type: 'swapCard', title: 'Kartentausch', description: 'Lösche eine Karte aus deinem Deck und wähle eine neue.', rarity: 'rare' }, 
                 { type: 'increaseHandSize', title: 'Handgröße +1', description: 'Du kannst 1 Karte mehr halten.', rarity: 'rare' },
                 { type: 'addLifestealFlat', title: 'Lebensraub +1', description: 'Du bekommst 20% Lifesteal.', rarity: 'rare' }, // Geändert zu festem Wert pro Schadenspunkt
                 { type: 'regenManaPassive', title: 'Mana-Regen +1', description: 'Du erhältst pro Runde +1 zusätzliches Mana zurück.', rarity: 'rare' },
                 { type: 'regenManaPassive3', title: 'Mana-Regen +3', description: 'Du erhältst pro Runde +3 zusätzliches Mana zurück.', rarity: 'superrare' },
                 { type: 'newUltraCardSpecific', title: 'Eine Ultra Karte wählen', description: 'Wähle 1 von 3 Ultra Karten.', rarity: 'superrare' }, // Komplexer zu implementieren
                 { type: 'fuseCards', title: '🧬 Kartenfusion',  description: 'Fusioniere zwei Karten aus deinem Deck zu einer neuen.', rarity: 'common'},
        ];
    
        // --- XP & Level Konstanten ---
        const BASE_XP_TO_LEVEL_UP = 50;
        const LEVEL_UP_FACTOR = 1.25;
    
        // --- Spielzustand (state object) ---
        let state = {};
        let cardUniqueCounter = 0; // Für eindeutige Karten-IDs im Spielverlauf
        let cardsPlayedThisTurn = 0;
    
        // --- DOM-Elemente ---
        // (IDs wurden teilweise angepasst für Klarheit)
        const roundElem = document.getElementById('round');
        const defeatedEnemiesElem = document.getElementById('defeatedEnemies');
        const playerHealthElem = document.getElementById('playerHealth');
        const playerMaxHealthElem = document.getElementById('playerMaxHealth');
        const playerHealthBarElem = document.getElementById('playerHealthBar').querySelector('.health-fill');
        const playerManaElem = document.getElementById('playerMana');
        const playerMaxManaElem = document.getElementById('playerMaxMana');
        const playerMaxManaDisplayElem = document.getElementById('playerMaxManaDisplay');
        const playerManaBarElem = document.getElementById('playerManaBar'); // Korrigiert: Direkt das Mana-Fill Element holen
        const playerBlockElem = document.getElementById('playerBlock');
        const playerLevelElem = document.getElementById('playerLevel');
        const playerXPElem = document.getElementById('playerXP');
        const xpToNextLevelElem = document.getElementById('xpToNextLevel');
        const playerLifestealDisplayElem = document.getElementById('playerLifestealDisplay');
        const highScoreDisplayElem = document.getElementById('highScoreDisplay');
    
        const enemyNameElem = document.getElementById('enemyName');
        const enemyHealthElem = document.getElementById('enemyHealth');
        const enemyMaxHealthElem = document.getElementById('enemyMaxHealth');
        const enemyHealthBarElem = document.getElementById('enemyHealthBar').querySelector('.health-fill');
        const enemyAttackElem = document.getElementById('enemyAttack');
        const enemyContainerElem = document.getElementById('enemyContainer');
        const monsterImageElem = document.getElementById('monsterImage');
        const playerImageElem = document.getElementById('playerImage');
        const enemyInfoElem = document.getElementById('enemyInfo');
        const monsterTraitsElem = document.getElementById('monsterTraits');
    
        const cardHandElem = document.getElementById('cardHand');
        const currentHandSizeElem = document.getElementById('currentHandSize');
        const maxHandSizeDisplayElem = document.getElementById('maxHandSizeDisplay');
        const maxHandSizeDisplayElem2 = document.getElementById('maxHandSizeDisplay2');
    
        const endTurnBtn = document.getElementById('endTurnBtn');
        const manaBoostBtn = document.getElementById('manaBoostBtn');
        const messageLogElem = document.getElementById('messageLog');
    
        const upgradeContainerElem = document.getElementById('upgradeContainer');
        const upgradeOptionsElem = document.getElementById('upgradeOptions');
        const upgradeTitleElem = upgradeContainerElem.querySelector('.upgrade-title');
    
        const gameOverContainerElem = document.getElementById('gameOverContainer');
        const finalScoreElem = document.getElementById('finalScore');
        const finalRoundElem = document.getElementById('finalRound');
        const finalLevelElem = document.getElementById('finalLevel');
        const restartBtn = document.getElementById('restartBtn');
        const playerDisplay = document.getElementById('playerDisplay');

    
        // --- Event-Listener ---
        endTurnBtn.addEventListener('click', () => endTurn());
        manaBoostBtn.addEventListener('click', manaBoost);
        restartBtn.addEventListener('click', () => {
        window.location.href = 'index.html'; // Weiterleitung ins Hauptmenü
        });
        document.addEventListener('DOMContentLoaded', initGame); // Spiel beim Laden starten
    
        // --- Hilfsfunktionen ---
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
    
        // Fisher-Yates Shuffle Algorithmus zum Mischen von Arrays
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Tausche Elemente
            }
        }

        // Hilfsfunktion für gewichtete Upgrade-Auswahl
        function getWeightedUpgrades(pool, superRareWeight = 1, rareWeight = 10, commonWeight = 50) {
            const weighted = [];

            for (const upg of pool) {
                let weight;
                switch (upg.rarity) {
                    case 'superrare':
                        weight = superRareWeight;
                        break;
                    case 'rare':
                        weight = rareWeight;
                        break;
                    default: 
                        weight = commonWeight;
                }

                for (let i = 0; i < Math.round(weight); i++) {
                    weighted.push(upg);
                }
            }

            shuffleArray(weighted);
            return weighted;
        }


        function getThreeUniqueNewCards() {
            const forbiddenCardIds = [17, 18, 19];
            const ownedCardIds = new Set(state.player.deck.map(card => card.id));
            const unlockedIds = state.unlockedCardIds;

            const availableCards = CARD_TYPES.filter(card =>
                !ownedCardIds.has(card.id) &&
                !forbiddenCardIds.includes(card.id) &&
                !unlockedIds.has(card.id) // <- NEU: noch nicht freigeschaltet
            );

            shuffleArray(availableCards);
            return availableCards.slice(0, Math.min(3, availableCards.length));
        }
   
        // Funktion zum Erstellen einer eindeutigen Karteninstanz
    function createCardInstance(cardType) {
            cardUniqueCounter++;

            let newCard = {
                ...cardType,
                uniqueId: cardUniqueCounter,
                basePower: cardType.power, // merken, falls Schwertbonus dazukommt
                tags: cardType.tags || []
            };

            const isSword = (cardType.name === 'Schwert' || (cardType.tags && cardType.tags.includes('sword')));
            if (isSword && state.player.swordPenalty) {
                newCard.basePower = (cardType.power || 0) - state.player.swordPenalty;
            }

            // Bonus anwenden, falls es ein Schwert ist
            if ((newCard.name === 'Schwert' || newCard.tags.includes('sword')) && typeof newCard.power === 'number') {
                // Nur Basiswert setzen, KEIN zusätzlicher Bonus!
                newCard.basePower = newCard.power; // neuer Standardwert
            }


            return newCard;
        }

        function getThreeUniqueUltraCards() {
                const ultraCardIds = [17, 18, 19];
                const ownedCardIds = new Set(state.player.deck.map(card => card.id));
                const ultraCards = CARD_TYPES.filter(card =>
                    ultraCardIds.includes(card.id) && !ownedCardIds.has(card.id)
                );
                console.log("Ultra-Karten zur Auswahl:", ultraCards);
                shuffleArray(ultraCards);
                return ultraCards.slice(0, 3);
            }


         // Funktion zum Loggen von Nachrichten im Spiel
        function logMessage(message, type = 'system') {
            const messageDiv = document.createElement('div');
            messageDiv.classList.add('message', type);
            // Sicherstellen, dass nur Text eingefügt wird (Sicherheit)
            messageDiv.textContent = message;
            messageLogElem.appendChild(messageDiv);
            // Automatisch nach unten scrollen
            messageLogElem.scrollTop = messageLogElem.scrollHeight;
        }
    
    
        // --- Kern Initialisierungsfunktion ---
        function initGame() {

            console.log('Gibt es shopContainerElem?', document.getElementById('shopContainer'));
            // 🛠️ Fix: Alle Overlays verstecken, falls sie versehentlich offen geblieben sind
            if (typeof upgradeContainerElem !== 'undefined') upgradeContainerElem.style.display = 'none';
            if (typeof shopContainerElem !== 'undefined') shopContainerElem.style.display = 'none';
            if (typeof gameOverContainerElem !== 'undefined') gameOverContainerElem.style.display = 'none';

            const playerName = localStorage.getItem('playerName') || 'Spieler';
            const selectedPassive = localStorage.getItem('selectedPassive') || 'swordfighter';

            console.log("🧠 Geladene Passive:", selectedPassive);

            console.log("Initialisiere Spiel...");
            cardUniqueCounter = 0; // Eindeutige ID zurücksetzen
    
            // 1. Spielzustand zurücksetzen
            state = {
                round: 1,
                defeatedEnemies: 0,
                player: {
                    level: 1,
                    xp: 0,
                    xpToNextLevel: BASE_XP_TO_LEVEL_UP,
                    maxHealth: 50,
                    health: 50,
                    maxMana: 10,
                    mana: 10,
                    block: 0,
                    deck: [],
                    hand: [],
                    discardPile: [],
                    maxHandSize: 5,
                    lifestealFlat: 0,
                    gold: 0, // 💰 Start-Gold
                    statusEffects: [], // Für zukünftige Effekte
                    swordBonus: 0
                },
                currentEnemy: null,
                gameOver: false,
                turnInProgress: false, // Verhindert Aktionen während Animationen/Gegnerzug
                highScore: parseInt(localStorage.getItem('pixelKartenspielHighScore') || '0') // Highscore laden
            };
    
            if (selectedPassive === 'shieldmaster') {
                state.player.isShieldmaster = true;
                state.player.block = 5; // Direkt zu Beginn 5 Block
                logMessage('🛡️ Schildmeister: Du startest mit 5 Block.', 'block');
                }

            // Pasiven
            const savedCardIds = localStorage.getItem('unlockedCardIds');
            if (savedCardIds) {
                state.unlockedCardIds = new Set(JSON.parse(savedCardIds));
            } else {
                state.unlockedCardIds = new Set([1, 2, 3, 7, 15, 16]);
            }

            state.player.name = localStorage.getItem('playerName') || 'Spieler';

            switch (selectedPassive) {
            case 'swordfighter':
                state.player.swordBonus = 2;
                break;

            case 'goldboy':
                state.player.gold = 1500;
                break;

            case 'dragonscale':
                state.player.immuneToStatus = true;
                state.player.hasDragonscale = true;
                break;

            case 'shieldmaster':
                state.player.isShieldmaster = true;
                state.player.swordPenalty = 1;
                break;

            case 'martyr':
                state.player.isMartyr = true;
                break;
            case 'undead':
                state.player.passive = 'undead';
                state.player.hellhound = {
                    damage: 2,
                    icon: 'images/hellhound.png'
                };
                break;
            }

            state.unlockedCardIds.add(1); // Schwert hat id 1

            // Spielerbild setzen
            playerImageElem.style.backgroundImage = `url(${PLAYER_PIXEL_IMAGE})`;
            playerImageElem.style.backgroundColor = '#444'; // Fallback-Farbe

            // Freigeschaltete Karten definieren, Start karten
            const unlockedCards = CARD_TYPES.filter(card => state.unlockedCardIds.has(card.id));


            // Gewichteten Pool erstellen
            let weightedPool = [];

            unlockedCards.forEach(card => {
                const count = card.weight || 1; // falls kein weight vorhanden, 1 als Standard
                for (let i = 0; i < count; i++) {
                    weightedPool.push(card);
                }
            });

            // 10 Karten ziehen – gewichtet
            for (let i = 0; i < 10; i++) {
                const randomCardType = weightedPool[getRandomInt(0, weightedPool.length - 1)];
                state.player.deck.push(createCardInstance(randomCardType));
            }

            shuffleArray(state.player.deck); // Deck mischen


    
            // 3. Ersten Gegner laden
            loadEnemy(); // Lädt einen passenden Gegner für Level 1
    
            // 4. Starthand ziehen
            drawCards(3); // Nur 3 Karten zum Start
    
            // 5. UI Aktualisieren
            messageLogElem.innerHTML = ''; // Log leeren
            logMessage("Neues Spiel gestartet. Viel Glück!", "system");
            updateUIDisplay(); // Zeigt alle Startwerte an
            updatePetDisplay();
            updateHandUI(); // Zeigt die Handkarten an
            updateEnemyUI(); // Zeigt den Gegner an
    
            // 6. Overlays & Buttons zurücksetzen
            gameOverContainerElem.style.display = 'none';
            upgradeContainerElem.style.display = 'none';
            endTurnBtn.disabled = false;
            manaBoostBtn.disabled = false;
            state.turnInProgress = false; // Sicherstellen, dass der Spieler agieren kann
    
            console.log("Spiel initialisiert. Aktueller Status:", state);
            logMessage(`🧠 Aktive Passive: ${selectedPassive}`, 'system');

            // Globale Highscore-Liste laden
            db.collection("highscores")
            .orderBy("score", "desc")
            .limit(10)
            .get()
            .then(snapshot => {
                const list = document.getElementById('leaderboardList');
                if (!list) return;

                list.innerHTML = '';
                snapshot.forEach(doc => {
                const entry = doc.data();
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score} besiegte Gegner (Lvl ${entry.level})`;
                list.appendChild(li);
                });
            })
            .catch(err => {
                console.warn("⚠️ Highscore-Liste konnte nicht geladen werden:", err);
            });


        }
    
        // --- UI Update Funktionen ---


        // Aktualisiert alle allgemeinen UI-Anzeigen (Stats, Runde etc.)
        function updateUIDisplay() {
            // Spieler Stats
            playerHealthElem.textContent = state.player.health;
            playerMaxHealthElem.textContent = state.player.maxHealth;
            playerHealthBarElem.style.width = `${Math.max(0, (state.player.health / state.player.maxHealth)) * 100}%`; // Verhindert negative Breite
    
            playerManaElem.textContent = state.player.mana;
            playerMaxManaElem.textContent = state.player.maxMana;
            playerMaxManaDisplayElem.textContent = state.player.maxMana;
            // Korrektur: .mana-fill Element direkt ansprechen
            const manaFill = playerManaBarElem;
             if (manaFill) { // Sicherstellen, dass das Element gefunden wurde
                manaFill.style.width = `${state.player.maxMana > 0 ? (state.player.mana / state.player.maxMana) * 100 : 0}%`;
             } else {
                 console.error("Mana-Fill Element nicht gefunden in #playerManaBar!");
             }
    
    
            playerBlockElem.textContent = state.player.block;
            playerLevelElem.textContent = state.player.level;
            playerXPElem.textContent = state.player.xp;
            xpToNextLevelElem.textContent = state.player.xpToNextLevel;
            playerLifestealDisplayElem.textContent = state.player.lifestealFlat;
            document.getElementById('playerGoldDisplay').textContent = state.player.gold;
    
            // Handgrößenanzeige
            currentHandSizeElem.textContent = state.player.hand.length;
            maxHandSizeDisplayElem.textContent = state.player.maxHandSize;
            maxHandSizeDisplayElem2.textContent = state.player.maxHandSize;
    
            // Allgemeine Spielinfo
            roundElem.textContent = state.round;
            defeatedEnemiesElem.textContent = state.defeatedEnemies;
            highScoreDisplayElem.textContent = state.highScore;
    
            // Kartenverfügbarkeit prüfen (wegen Mana)
            updateCardAvailability();

            updatePlayerStatusDisplay();

        }

        function updatePlayerStatusDisplay() {
                const container = document.getElementById('playerStatusDisplay');
                container.innerHTML = ''; // alten Inhalt löschen

                    // Entferne Frost-Aura-Effekt (blauer Hintergrund) wenn er nicht mehr aktiv ist
                if (!state.player.frozen) {
                    document.getElementById('playerDisplay').style.backgroundColor = '';  // Normaler Zustand
                }

                if (state.player.statusEffects?.length > 0) {
                    state.player.statusEffects.forEach(effect => {
                        const span = document.createElement('span');
                        span.classList.add('status-effect', effect.type);

                        // Symbol und Text
                        let icon = '';
                        switch (effect.type) {
                            case 'poison':
                                icon = '☠️';
                                span.style.color = '#ce93d8'; // lila
                                span.textContent = `${icon} ${effect.power} (${effect.duration})`;
                                break;

                            case 'burn':
                                icon = '🔥';
                                span.style.color = '#ff7043'; // orange/rot
                                span.textContent = `${icon} ${effect.power} (${effect.duration})`;
                                break;

                            case 'paralyze':
                                icon = '⚡';
                                span.style.color = '#ffeb3b'; // Gelb
                                span.textContent = `${icon} (${effect.duration})`;
                                break;

                            default:
                                icon = '❓';
                                span.textContent = `${icon} (${effect.duration})`;
                        }

                        // Tooltip hinzufügen
                        span.setAttribute('data-tooltip', getEffectDescription(effect.type, effect.duration, effect.power));
                        
                        container.appendChild(span);
                    });
                }

                //Kurze damage buffs (Kraft sammeln)
                if (state.player.tempAttackBonus) {
                    const span = document.createElement('span');
                    span.classList.add('status-effect', 'buff');
                    span.textContent = `+${state.player.tempAttackBonus} Angriff`;
                    container.appendChild(span);
                }

                // 🔥 Märtyrer-Bonus anzeigen (außerhalb der Schleife!)
                if (state.player.isMartyr) {
                    const lostPercent = 1 - (state.player.health / state.player.maxHealth);
                    const martyrBonus = Math.floor(10 * lostPercent); // Repräsentativer Basiswert, z. B. für 5 Schaden
                    const span = document.createElement('span');
                    span.classList.add('status-effect');
                    span.textContent = `⚔ Märtyrer +${martyrBonus}`;
                    span.title = `Bonus-Schaden durch fehlendes Leben (${Math.floor(lostPercent * 100)} % verloren)`;
                    container.appendChild(span);
                }
                updateEnemyUI();
            }

        function getEffectDescription(type, duration, power = 0) {
                switch (type) {
                    case 'poison':
                        return `Vergiftung: Verliert ${power} Leben pro Runde. (${duration} Runden)`;
                    case 'burn':
                        return `Verbrennung: Verliert ${power} Leben pro Runde. (${duration} Runden)`;
                    case 'paralyze':
                        return `Paralyse: Du kannst nur 2 Karten pro Runde spielen. (${duration} Runden)`;
                    default:
                        return `${type} (${duration} Runden)`;
                }
            }
 
        function updateEnemyUI() {
            if (!state.currentEnemy) {
                enemyNameElem.textContent = 'Kein Gegner';
                enemyHealthElem.textContent = '0';
                enemyMaxHealthElem.textContent = '0';
                enemyHealthBarElem.style.width = '0%';
                enemyAttackElem.textContent = '0';
                monsterImageElem.style.backgroundImage = 'none';
                monsterImageElem.style.backgroundColor = '#555';
                enemyInfoElem.textContent = '';
                monsterTraitsElem.innerHTML = '';
                document.getElementById('enemyMinions').innerHTML = '';
                return;
            }

            const enemy = state.currentEnemy;

            // Gegner-Grunddaten
            enemyNameElem.textContent = enemy.name;
            enemyHealthElem.textContent = enemy.health;
            enemyMaxHealthElem.textContent = enemy.maxHealth;
            enemyHealthBarElem.style.width = `${Math.max(0, (enemy.health / enemy.maxHealth)) * 100}%`;
            let displayedAttack = enemy.attack || 0;
            if (enemy.statusEffects?.some(e => e.type === 'paralyze')) {
                displayedAttack = Math.floor(displayedAttack / 2);
            }
            enemyAttackElem.textContent = displayedAttack;
            enemyAttackElem.style.color = enemy.statusEffects?.some(e => e.type === 'paralyze') ? '#ffeb3b' : '#fff';
            enemyInfoElem.textContent = enemy.description || '';

            // Bild
            const imagePath = ENEMY_PIXEL_PLACEHOLDERS[enemy.pixelImageKey];
            monsterImageElem.style.backgroundImage = imagePath ? `url(${imagePath})` : 'none';
            monsterImageElem.style.backgroundColor = imagePath ? 'transparent' : '#555';

            // Traits mit Tooltip
            const traitDescriptions = {
                'Keine Fähigkeit': 'Keine speziellen Effekte.',
                'Stark': 'Verdoppelt Angriff nach 3 Runden.',
                'Giftig': '30% Chance, den Spieler zu vergiften (2 Schaden für 3 Runden).',
                'Regeneration': 'Regeneriert jede Runde Leben.',
                'Massiv': 'Immun gegen Gift.',
                'Untotenbeschwörer': 'Beschwört einmalig zwei Skelette. Diese werden von direktem Damage zuerst angegriffen',
                'Eis-Elementar': 'Bekommt doppelten schaden durch Feuerattacken.',
                'Frost-Aura': '20% Chance, den Spieler einzufrieren.',
                'Höllen Krallen': '45% Chance auf kritischen Treffer. (Kritischer Treffer = 1,5x Schaden)',
                'Verspielt': '20% Chance, den Angriff zu verpassen.',
                'Feueratem': '30% Chance auf Brennen (5 Schaden für 2 Runden).',
                'Fliegend': 'Ignoriert Block zu 75%.',
                'Gepanzerte Schuppen': 'Immun gegen alle Statuseffekte.',
                'Lebensraub': 'Heilt sich um 50% seine schadens.',
                'Segen': 'Heilt sich einmal um 50% seiner Leben.',
                'Rüstung': 'Stellt jede Runde 5 Block her',
                'Vamp': 'Heilt sich um 50% des verursachten Schadens',
                'Krieger': 'Ein erfahrener Krieger trifft auch manchmal doppelt',
                'Statisch': 'Angriffe Paralysieren dich zu 45% (Paraylse = 2 Karte nur Spielbar)',
                'Höllenwache': 'Beschwört einen sehr starken Höllenhund'
            };

            monsterTraitsElem.innerHTML = '';
            if (enemy.traits?.length) {
                enemy.traits.forEach(trait => {
                    const span = document.createElement('span');
                    span.classList.add('monster-trait');
                    span.textContent = trait;
                    span.setAttribute('data-tooltip', traitDescriptions[trait] || 'Keine Beschreibung verfügbar.');
                    monsterTraitsElem.appendChild(span);
                });
                }

                //Block enemy
            const enemyBlockElem = document.getElementById('enemyBlock');
                if (!enemyBlockElem) {
                    const blockDiv = document.createElement('div');
                    blockDiv.id = 'enemyBlock';
                    blockDiv.style.color = '#00bcd4';
                    blockDiv.style.fontWeight = 'bold';
                    blockDiv.style.marginTop = '4px';
                    enemyHealthElem.parentElement.appendChild(blockDiv);
                }
                document.getElementById('enemyBlock').textContent = `🛡 ${state.currentEnemy.block || 0}`;

            // Status-Effekte
            if (enemy.statusEffects?.length) {
            enemy.statusEffects.forEach(effect => {
                const span = document.createElement('span');
                span.classList.add('monster-trait', 'status-effect');

                let icon = '❓';
                let bgColor = '#777';
                let textColor = '#fff';
                let tooltip = `${effect.type} (${effect.duration})`;
                let text = `${icon} (${effect.duration})`;

                switch (effect.type) {
                    case 'poison':
                        icon = '☠️';
                        bgColor = '#6a1b9a';
                        tooltip = `Vergiftung – erleidet ${effect.power} Schaden pro Runde`;
                        text = `${icon} ${effect.power} (${effect.duration})`;
                        break;

                    case 'burn':
                        icon = '🔥';
                        bgColor = '#ff7043';
                        tooltip = `Verbrennung – erleidet ${effect.power} Schaden pro Runde`;
                        text = `${icon} ${effect.power} (${effect.duration})`;
                        break;

                    case 'paralyze':
                        icon = '⚡';
                        bgColor = '#ffeb3b';
                        textColor = '#000';
                        tooltip = `Paralyse – halbiert den Angriff (${effect.duration} Runden)`;
                        text = `${icon} (${effect.duration})`;
                        break;
                }

                span.style.backgroundColor = bgColor;
                span.style.color = textColor;
                span.setAttribute('data-tooltip', tooltip);
                span.textContent = text;
                monsterTraitsElem.appendChild(span);
            });
        }

            // Minions anzeigen
            const minionContainer = document.getElementById('enemyMinions');
            minionContainer.innerHTML = '';

            if (enemy.minions?.length) {
                enemy.minions.forEach(minion => {
                    const minionDiv = document.createElement('div');
                    minionDiv.classList.add('minion-box');

                    // Bildpfad korrekt abrufen
                    const imgPath = ENEMY_PIXEL_PLACEHOLDERS[minion.pixelImageKey] || 'images/Skelett.png';

                    // Besondere Klasse für Höllenhund
                    if (minion.pixelImageKey === 'hund' || minion.pixelImageKey === 'hund') {
                        minionDiv.classList.add('hund');
                    }

                    minionDiv.innerHTML = `
                        <div class="minion-image" style="background-image: url(${imgPath});"></div>
                        <div>${minion.health} / ${minion.maxHealth}</div>
                        <div>⚔ ${minion.attack}</div>
                    `;

                    minionContainer.appendChild(minionDiv);
                });
            }
        }
    
        // Aktualisiert die Anzeige der Handkarten
        function updateHandUI() {
            cardHandElem.innerHTML = ''; // Alte Karten entfernen
            state.player.hand.forEach(card => {
                const cardDiv = createCardElement(card); // Eigene Funktion für Kartenerstellung
                cardHandElem.appendChild(cardDiv);
            });
            updateCardAvailability(); // Verfügbarkeit nach dem Neuzeichnen prüfen
            // Handgrößenanzeige auch hier aktualisieren
             currentHandSizeElem.textContent = state.player.hand.length;
             updatePlayerStatusDisplay();
        }

    
function createCardElement(card) {
    const cardDiv = document.createElement('div');
    cardDiv.classList.add('card', 'card-animation');
    cardDiv.dataset.uniqueId = card.uniqueId;

    if (card.rarity === 'rare') cardDiv.classList.add('rare');
    if (card.rarity === 'superrare') cardDiv.classList.add('superrare');

    const EFFECT_ICONS = {
        damage: '💥',
        block: '🛡️',
        heal: '❤️',
        lifesteal: '💥',
        poison: '☠️',
        damage_paralyze: '💥',
        whirlwind: '💥',
        firearrow: '💥',
        gamble: '💥'
    };

    let powerHint = '';
    let formattedPower = '';

    if (typeof card.power === 'object' && card.power !== null) {
        const enhanced = {};

        for (const [eff, val] of Object.entries(card.power)) {
            let result = val || 0;

            if (eff === 'damage') {
                if (card.name.includes('Schwert') || card.name === 'Schwert') {
                    if (state.player?.swordBonus) {
                        result += state.player.swordBonus;
                        powerHint += `+${state.player.swordBonus} durch Schwertkämpfer `;
                    }
                    if (state.player?.isShieldmaster) {
                        result -= 1;
                        powerHint += `-1 durch Schildmeister `;
                    }
                }
            }

            if (result > 0) {
                enhanced[eff] = result;
            }
        }

        formattedPower = Object.entries(enhanced)
            .map(([eff, val]) => `<span style="font-size: 16px;">${EFFECT_ICONS[eff] || eff}</span> ${val}`)
            .join(' / ');
    } else {
        let base = card.basePower ?? card.power ?? 0;

        if (card.effect === 'damage' && (card.name.includes('Schwert') || card.name === 'Schwert')) {
            if (state.player?.swordBonus) {
                base += state.player.swordBonus;
                powerHint += `+${state.player.swordBonus} durch Schwertkämpfer `;
            }
            if (state.player?.isShieldmaster) {
                base -= 1;
                powerHint += `-1 durch Schildmeister `;
            }
        }

        if (base > 0) {
            formattedPower = `<span style="font-size: 20px;">${EFFECT_ICONS[card.effect] || ''}</span> ${base}`;
        }
    }

    cardDiv.innerHTML = `
        <div class="card-mana">${card.manaCost === 'X' ? 'X' : card.manaCost}</div>
        <div class="card-name">${card.name}</div>
        <div class="card-icon">
        ${card.icon.endsWith('.png') 
            ? `<img src="${card.icon}" style="width: 42px; height: 42px;" alt="${card.name}">` 
            : card.icon}
        </div>
        <div class="card-description">
            ${card.description}
            ${card.name === 'Schwert' && state.player?.isShieldmaster 
                ? `<br><span style="color:orange;">-1 wegen Schildmeister</span>` 
                : ''}
        </div>
        <div class="card-power" title="${powerHint.trim()}">${formattedPower}</div>
    `;

    if (!state.player.frozen) {
        cardDiv.addEventListener('click', () => playCard(card.uniqueId));
    }

    return cardDiv;
}



    
        // Aktualisiert den 'disabled'-Status der Karten basierend auf Manakosten
        function updateCardAvailability() {
            const cards = document.querySelectorAll('.card');

            cards.forEach(cardElem => {
                const card = state.player.hand.find(c => c.uniqueId == cardElem.dataset.uniqueId);
                if (!card) return;

                // "Kraft Sammeln" = Spezialfall mit X -> zählt als 1 Mana
                let manaCost = 0;
                if (card.manaCost === 'X') {
                    manaCost = 1;
                } else if (typeof card.manaCost === 'number') {
                    manaCost = card.manaCost;
                } else if (!isNaN(parseInt(card.manaCost))) {
                    manaCost = parseInt(card.manaCost);
                } else {
                    manaCost = 0; // Fallback falls gar nichts angegeben ist
                }

                const hasEnoughMana = state.player.mana >= manaCost;
                const shouldDisable = (manaCost > 0 && !hasEnoughMana) || state.player.frozen;

                if (shouldDisable) {
                    cardElem.classList.add('disabled');
                } else {
                    cardElem.classList.remove('disabled');
                }
            });

            endTurnBtn.disabled = state.turnInProgress;
            manaBoostBtn.disabled = state.turnInProgress || cardsPlayedThisTurn > 0 || state.player.frozen;
        }

        
        //Pet
        function updatePetDisplay() {
            const container = document.getElementById('petContainer');
            container.innerHTML = '';

            // Normales Pet anzeigen
            if (state.player.activePet) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('pet-tooltip-wrapper');

                const img = document.createElement('img');
                img.src = state.player.activePet.icon;
                img.alt = state.player.activePet.name;
                img.classList.add('pet-image');

                const tooltip = document.createElement('div');
                tooltip.classList.add('pet-tooltip');
                tooltip.textContent = getPetDescription(state.player.activePet.effect);

                wrapper.appendChild(img);
                wrapper.appendChild(tooltip);
                container.appendChild(wrapper);
            }

            // Teufelshund anzeigen (falls vorhanden)
            if (state.player.hellhound) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('pet-tooltip-wrapper');

                const img = document.createElement('img');
                img.src = state.player.hellhound.icon;
                img.alt = 'Teufelshund';
                img.classList.add('pet-image');

                const tooltip = document.createElement('div');
                tooltip.classList.add('pet-tooltip');
                tooltip.textContent = `Teufelshund: ${state.player.hellhound.damage} Damage.`;

                wrapper.appendChild(img);
                wrapper.appendChild(tooltip);
                container.appendChild(wrapper);
            }
        }


        function getPetDescription(effect) {
                switch (effect) {
                    case 'gawa':
                        return 'Macht 4 extra Schaden.';
                    case 'lulu':
                        return '2 Schaden, +1 Mana Regeneration';
                    case 'cassa':
                        return '1 Schaden, +3 Block pro Runde.';
                    default:
                        return 'Ein treuer Begleiter.';
                }
            }

        // Lädt einen neuen Gegner basierend auf dem Spielerlevel
        function loadEnemy() {
            const possibleEnemies = ENEMY_TYPES.filter(enemy =>
                state.player.level >= enemy.levelMin && state.player.level <= enemy.levelMax
            );
    
            let enemyTemplate;
            if (possibleEnemies.length > 0) {
                const randomIndex = getRandomInt(0, possibleEnemies.length - 1);
                enemyTemplate = possibleEnemies[randomIndex];
            } else {
                // Fallback: Wenn kein passender Gegner gefunden wird (z.B. am Ende der definierten Gegner)
                console.warn("Kein passender Gegner für Level", state.player.level, "gefunden. Lade letzten Gegner.");
                enemyTemplate = ENEMY_TYPES[ENEMY_TYPES.length - 1];
            }
    
            // WICHTIG: Eine *Kopie* des Gegners erstellen, um das Original nicht zu ändern!
            state.currentEnemy = {
                 ...enemyTemplate,
                 health: enemyTemplate.health, // Startleben setzen
                 maxHealth: enemyTemplate.health, // MaxLeben speichern
                 poisonTurns: 0,
                 statusEffects: [], // Initial leere Status-Effekte
                 minions: [],
                 block: 0 
             };
             
    
            console.log("Gegner geladen:", state.currentEnemy.name);
            enemyContainerElem.classList.remove('defeat', 'hit'); // Animation-Klassen zurücksetzen
            enemyContainerElem.style.opacity = 1;
            enemyContainerElem.style.transform = 'none';
            updateEnemyUI(); // Anzeige aktualisieren
        }
    
        function drawCards(numCards) {
            let drawnCount = 0;

            while (drawnCount < numCards) {
                const handCount = state.player.hand.filter(c => c.name !== 'Donner-Zauber').length;
                if (handCount >= state.player.maxHandSize) {
                    logMessage(`Hand ist voll. Ziehen gestoppt.`, 'discard');
                    break;
                }

                while (drawnCount < numCards) {
                const handCount = state.player.hand.filter(c => c.name !== 'Lotus Trank').length;
                if (handCount >= state.player.maxHandSize) {
                    logMessage(`Hand ist voll. Ziehen gestoppt.`, 'discard');
                    break;
                }

                // Deck leer → Mische Ablagestapel
                if (state.player.deck.length === 0) {
                    if (state.player.discardPile.length === 0) {
                        logMessage("Deck und Ablagestapel sind leer. Keine Karte gezogen.", 'system');
                        break;
                    }
                    logMessage("Deck leer. Mische Ablagestapel...", 'system');
                    state.player.deck = [...state.player.discardPile];
                    state.player.discardPile = [];
                    shuffleArray(state.player.deck);
                }

                const card = state.player.deck.pop();
                state.player.hand.push(card);
                drawnCount++;
            }

            if (drawnCount > 0) {
                updateHandUI();
                updateUIDisplay();
            }

            return drawnCount;
        }}

    
        // --- Platzhalter für weitere Spiellogik (wird später benötigt) ---
    
        function playCard(uniqueCardId) {
    if (state.gameOver || state.turnInProgress) return;

    const paralyzeEffect = state.player.statusEffects?.find(e => e.type === 'paralyze');
    if (paralyzeEffect && cardsPlayedThisTurn >= 2) {
        logMessage("⚡ Du bist paralysiert und kannst diese Runde nur 2 Karten spielen!", 'system');
        return;
    }

    const cardIndex = state.player.hand.findIndex(c => c.uniqueId === uniqueCardId);
    if (cardIndex === -1) {
        console.error("Karte zum Spielen nicht in der Hand gefunden:", uniqueCardId);
        return;
    }
    const card = state.player.hand[cardIndex];

    const isPowerSurge = card.name === 'Kraft Sammeln';
    const requiredMana = card.manaCost === 'X' ? 1 : card.manaCost;

    if (requiredMana > 0 && state.player.mana < requiredMana) {
        logMessage(`Nicht genug Mana für ${card.name}! (${requiredMana} benötigt)`, 'player');
        const cardElement = cardHandElem.querySelector(`.card[data-unique-id="${uniqueCardId}"]`);
        if (cardElement) {
            cardElement.classList.add('shake');
            setTimeout(() => cardElement.classList.remove('shake'), 250);
        }
        return;
    }

    if (isPowerSurge && state.usedPowerSurgeThisTurn) {
        logMessage(`🔋 Kraft Sammeln kann nur einmal pro Runde genutzt werden.`, 'system');
        return;
    }

    state.turnInProgress = true;
    updateCardAvailability();
    cardsPlayedThisTurn++;

    // Mana abziehen (außer für oneShot)
    if (!card.oneShot) {
        state.player.mana -= requiredMana;
    }

    const cardElement = cardHandElem.querySelector(`.card[data-unique-id="${uniqueCardId}"]`);
    if (cardElement) {
        cardElement.classList.add('played');
        setTimeout(() => {
            updateHandUI();
            updateUIDisplay();
        }, 300);
    } else {
        updateHandUI();
        updateUIDisplay();
    }

    logMessage(`Spieler spielt ${card.name}.`, 'player');

    // ➕ Fusionierte Karten mit mehreren Effekten
    if (card.effect.includes('_') && typeof card.power === 'object') {
        for (const [effect, value] of Object.entries(card.power)) {
            playSingleEffect(effect, value, card);
        }
    } else {
        executeCardEffect(card); // normale Karte
    }

    // Spezialfall: Kraft Sammeln
    if (isPowerSurge) {
        state.usedPowerSurgeThisTurn = true;
    }

    // Ablage oder Entfernen bei oneShot
    state.player.hand.splice(cardIndex, 1);
    if (card.oneShot) {
        logMessage(`${card.name} verschwindet nach der Benutzung.`, 'system');
        playerInventory.delete('donner');
        playerInventory.delete('lotus');
        updatePlayerItemIcons();
    } else {
        state.player.discardPile.push(card);
    }

    updateUIDisplay();
    updateEnemyUI();

    setTimeout(() => {
        checkEnemyDefeat();
    }, 400);
}


function playSingleEffect(effect, power, card) {
    const enemy = state.currentEnemy;

    // Kombinierte Effekte aufteilen und rekursiv verarbeiten
    if (effect.includes('_') && typeof power === 'object') {
        const effects = effect.split('_');
        for (const e of effects) {
            playSingleEffect(e, power[e] || 0, card);
        }
        return;
    }

    let remaining = power;

    const hitAnimation = () => {
        enemyContainerElem.classList.add('hit');
        setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
    };

    switch (effect) {
        case 'draw':
            drawCards(remaining);
            logMessage(`📜 Du ziehst ${remaining} Karte(n).`, 'system');
            break;

        case 'damage': {
            const blockUsed = Math.min(enemy.block || 0, remaining);
            if (blockUsed > 0) {
                enemy.block -= blockUsed;
                logMessage(`${enemy.name} blockt ${blockUsed} Schaden.`, 'block');
            }

            const finalDamage = remaining - blockUsed;
            if (finalDamage > 0) {
                enemy.health -= finalDamage;
                logMessage(`${enemy.name} erleidet ${finalDamage} Schaden.`, 'enemy');
            }
            hitAnimation();
            break;
        }

        case 'block':
            state.player.block = (state.player.block || 0) + remaining;
            logMessage(`🛡️ Du erhältst ${remaining} Block.`, 'block');
            break;

        case 'heal': {
            const healAmount = Math.min(remaining, state.player.maxHealth - state.player.health);
            if (healAmount > 0) {
                state.player.health += healAmount;
                logMessage(`❤️ Du heilst ${healAmount} Leben.`, 'heal');
            }
            break;
        }

        case 'lifesteal': {
            const blockUsed = Math.min(enemy.block || 0, remaining);
            if (blockUsed > 0) {
                enemy.block -= blockUsed;
                logMessage(`${enemy.name} blockt ${blockUsed} Schaden.`, 'block');
            }

            const finalDamage = remaining - blockUsed;
            if (finalDamage > 0) {
                enemy.health -= finalDamage;
                const heal = Math.min(finalDamage, state.player.maxHealth - state.player.health);
                state.player.health += heal;
                logMessage(`🧛 Du stiehlst ${heal} Leben.`, 'lifesteal');
            }
            hitAnimation();
            break;
        }

        case 'poison': {
            const existing = enemy.statusEffects?.find(e => e.type === 'poison');
            if (existing) {
                enemy.health -= 3;
                logMessage(`☠️ Vergiftet – ${enemy.name} nimmt 3 extra Schaden.`, 'enemy');
            } else {
                addStatusEffect(enemy, { type: 'poison', damagePerTurn: remaining, duration: 3 });
                logMessage(`☠️ ${enemy.name} ist nun vergiftet (${remaining} für 3 Runden).`, 'effect');
            }
            break;
        }

        case 'damage_paralyze': {
            enemy.health -= remaining;
            logMessage(`⚡ ${enemy.name} erleidet ${remaining} Schaden.`, 'enemy');

            if (Math.random() < 0.45) {
                addStatusEffect(enemy, { type: 'paralyze', duration: 2 });
                logMessage(`⚡ ${enemy.name} ist paralysiert (Angriff halbiert).`, 'effect');
            }
            hitAnimation();
            break;
        }

        case 'firearrow': {
            enemy.health -= remaining;
            logMessage(`🔥 ${enemy.name} erleidet ${remaining} Schaden durch Feuerpfeil.`, 'enemy');

            if (Math.random() < 0.5) {
                addStatusEffect(enemy, { type: 'burn', damagePerTurn: 5, duration: 2 });
                logMessage(`🔥 ${enemy.name} brennt! (5 Schaden für 2 Runden)`, 'effect');
            }
            hitAnimation();
            break;
        }

        case 'gamble': {
            const roll = Math.random();
            if (roll < 0.5) {
                enemy.health -= remaining;
                state.player.gold += 100;
                logMessage(`🎲 Glück gehabt! ${enemy.name} verliert ${remaining} Leben. Du erhältst 100 Gold.`, 'gold');
            } else {
                state.player.health -= remaining;
                logMessage(`🎲 Verloren! Du verlierst ${remaining} Leben.`, 'enemy');
            }
            break;
        }

        case 'whirlwind':
            enemy.health -= remaining;
            logMessage(`🌀 Klingenwirbel trifft ${enemy.name} für ${remaining} Schaden.`, 'enemy');
            break;

        default:
            console.warn("Unbekannter Effekt:", effect);
            logMessage(`⚠️ Effekt ${effect} konnte nicht ausgeführt werden.`, 'system');
    }
}


    
function executeCardEffect(card) {
    switch (card.effect) {
        case 'paralyze':
                tryApplyParalyze(state.currentEnemy); // 100 % Chance
                break;
        case 'damage_paralyze':
                dealDamage(state.currentEnemy, card.power);
                tryApplyParalyze(state.currentEnemy, 0.45); // 45 % Chance
                break;
        case 'whirlwind': {
                let rawDamage = card.power;
                let totalDamage = applyDamageBonuses(rawDamage); // ✅ alle Boni berücksichtigen

                // Minions zuerst treffen
                if (state.currentEnemy.minions?.length > 0) {
                    state.currentEnemy.minions.forEach((minion, index) => {
                        minion.health -= totalDamage;
                        logMessage(`🌀 ${minion.name} erleidet ${totalDamage} Schaden (ignoriert Block).`, 'enemy');
                    });

                    // Entferne besiegte Minions
                    state.currentEnemy.minions = state.currentEnemy.minions.filter(m => m.health > 0);
                }

                // Hauptgegner angreifen (Block ignorieren)
                state.currentEnemy.health -= totalDamage;
                logMessage(`🌀 ${state.currentEnemy.name} erleidet ${totalDamage} Schaden durch Klingenwirbel (ignoriert Block).`, 'enemy');

                enemyContainerElem.classList.add('hit');
                setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
                break;
            }
        case 'power_surge': {
            const spentMana = state.player.mana;

            if (spentMana > 0) {
                // Mana ausgeben
                state.player.mana = 0;

                // Heilen
                const healAmount = Math.min(spentMana, state.player.maxHealth - state.player.health);
                state.player.health += healAmount;

                logMessage(`💚 Kraft Sammeln heilt dich um ${healAmount} Leben.`, 'heal');

                // Temporärer Schadensbonus für nächste Runde
                state.player.tempAttackBonus = (state.player.tempAttackBonus || 0) + spentMana;
                logMessage(`⚔️ Du bekommst +${spentMana} Angriff für deine nächste Runde.`, 'buff');
            } else {
                logMessage(`🌀 Kein Mana verfügbar – Effekt von Kraft Sammeln entfällt.`, 'system');
            }
            break;
        }
        case 'damage':
            let rawDamage = (typeof card.basePower === 'number' ? card.basePower : card.power);

            if (card.name === 'Schwert') {
                if (state.player.swordBonus) {
                    rawDamage += state.player.swordBonus;
                }
                if (state.player.isShieldmaster) {
                    rawDamage -= 1;
                    logMessage('⚠️ Schildmeister: Schwert macht 1 weniger Schaden.', 'system');
                }
            }

            let damageDealt = applyDamageBonuses(rawDamage);

            if (state.currentEnemy.minions?.length > 0) {
                const target = state.currentEnemy.minions[0];
                target.health -= damageDealt;
                logMessage(`💀 ${target.name} erleidet ${damageDealt} Schaden.`, 'enemy');
                if (target.health <= 0) {
                    logMessage(`${target.name} wurde zerstört!`, 'enemy');
                    state.currentEnemy.minions.shift();
                }
            } else {
                let blockUsed = Math.min(state.currentEnemy.block || 0, damageDealt);
                if (blockUsed > 0) {
                    state.currentEnemy.block -= blockUsed;
                    logMessage(`${state.currentEnemy.name} blockt ${blockUsed} Schaden.`, 'block');
                }

                const remainingDamage = damageDealt - blockUsed;
                if (remainingDamage > 0) {
                    state.currentEnemy.health -= remainingDamage;
                    logMessage(`${state.currentEnemy.name} erleidet ${remainingDamage} Schaden.`, 'enemy');
                } else {
                    logMessage(`${state.currentEnemy.name} blockt den gesamten Schaden!`, 'block');
                }
            }

            // 🪓 Kritischer Treffer durch Katryns Axt
                if (state.player.critChance && Math.random() < state.player.critChance) {
                    const critBonus = Math.floor(damageDealt * 0.5);
                    damageDealt += critBonus;
                    logMessage(`💥 Kritischer Treffer! Schaden um +${critBonus} erhöht!`, 'player');
                }


            // 🔥 Drachenschuppen-Effekt: 20% Chance auf Verbrennung
                if (state.player.hasDragonscale) {
                    const burnChance = Math.random();
                    if (burnChance <= 0.20) {
                        const burnPower = 5;
                        const burnDuration = 2;

                        const target = state.currentEnemy.minions?.[0] || state.currentEnemy;

                        if (!target.statusEffects) target.statusEffects = [];

                        const alreadyBurning = target.statusEffects.some(e => e.type === 'burn');
                        if (!alreadyBurning) {
                            target.statusEffects.push({
                                type: 'burn',
                                power: burnPower,
                                duration: burnDuration
                            });
                            console.log("🔥 Burn-Effekt hinzugefügt:", target.statusEffects);
                            logMessage(`🔥 Drachenschuppen: ${target.name} wurde verbrannt! (${burnPower} Schaden für ${burnDuration} Runden)`, 'burn');
                        } else {
                            console.log("🔥 Gegner brennt bereits. Kein zusätzlicher Burn angewendet.");
                        }
                    }
                }

            // Prozentualer Lifesteal (aus Upgrade)
            const lifestealPercent = state.player.lifestealPercent || 0;

                if (lifestealPercent > 0 && damageDealt > 0) {
                    const rawHeal = Math.floor(damageDealt * lifestealPercent);
                    const effectiveHeal = Math.min(rawHeal, state.player.maxHealth - state.player.health);

                    if (effectiveHeal > 0) {
                        state.player.health += effectiveHeal;
                        logMessage(`🧛 Du absorbierst ${effectiveHeal} Leben durch ${Math.round(lifestealPercent * 100)} % Lebensraub.`, 'lifesteal');
                    }
                }

                enemyContainerElem.classList.add('hit');
                setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
                break;


        case 'block':
            state.player.block += card.power;
            logMessage(`Spieler erhält ${card.power} Block.`, 'block');
            break;

        case 'heal':
            const healFromCard = Math.min(card.power, state.player.maxHealth - state.player.health);
            if (healFromCard > 0) {
                state.player.health += healFromCard;
                logMessage(`Spieler heilt ${healFromCard} Leben.`, 'heal');
            } else {
                logMessage(`Spieler ist bereits bei vollem Leben.`, 'heal');
            }
            break;
        case 'full_heal': {
            const amount = state.player.maxHealth - state.player.health;
            if (amount > 0) {
                state.player.health = state.player.maxHealth;
                logMessage(`🌸 Lotus Trank heilt dich vollständig (${amount} Leben).`, 'heal');
            } else {
                logMessage(`🌸 Lotus Trank: Du bist bereits voll geheilt.`, 'system');
            }
            break;
        }

        if (!state.currentEnemy.statusEffects) {
            state.currentEnemy.statusEffects = [];
                    }

            switch (effectType) {
                case 'poison':
                    if (
                        state.currentEnemy.traits?.includes('Gepanzerte Schuppen') ||
                        state.currentEnemy.traits?.includes('Massiv')
                    ) {
                        logMessage(`${state.currentEnemy.name} ist immun gegen Vergiftung!`, 'enemy');
                        return; // bricht die ganze Funktion ab
                    }
                    applyEnemyStatusEffect('poison');
                    break;

                case 'paralyze':
                    if (state.currentEnemy.traits?.includes('Gepanzerte Schuppen')) {
                        logMessage(`${state.currentEnemy.name} ist immun gegen Paralyse!`, 'enemy');
                        return;
                    }
                    applyEnemyStatusEffect('paralyze');
                    break;

                case 'burn':
                    if (state.currentEnemy.traits?.includes('Gepanzerte Schuppen')) {
                        logMessage(`${state.currentEnemy.name} ist immun gegen Verbrennung!`, 'enemy');
                        return;
                    }
                    applyEnemyStatusEffect('burn');
                    break;
            }


            const existingPoison = state.currentEnemy.statusEffects.find(e => e.type === 'poison');
            if (existingPoison) {
                const bonusPoisonDamage = 3;
                state.currentEnemy.health -= bonusPoisonDamage;
                logMessage(`${state.currentEnemy.name} ist bereits vergiftet – erleidet ${bonusPoisonDamage} zusätzlichen Giftschaden!`, 'poison');
                enemyContainerElem.classList.add('hit');
                setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
            } else {
                state.currentEnemy.statusEffects.push({
                    type: 'poison',
                    power: card.power,
                    duration: card.duration
                });
                logMessage(`${state.currentEnemy.name} wird vergiftet (${card.power} Schaden für ${card.duration} Runden).`, 'poison');
                updateEnemyUI();
            }
            break;

            case 'lifesteal':
                let rawLifestealDamage = card.power;

                // Anwenden aller temporären Schadenboni (Kraft sammeln, Märtyrer, etc.)
                let lsDamage = applyDamageBonuses(rawLifestealDamage);

                logMessage(`${state.currentEnemy.name} erleidet ${lsDamage} Schaden.`, 'enemy');

                let enemyBlockUsed = Math.min(state.currentEnemy.block || 0, lsDamage);
                if (enemyBlockUsed > 0) {
                    state.currentEnemy.block -= enemyBlockUsed;
                    logMessage(`${state.currentEnemy.name} blockt ${enemyBlockUsed} Schaden.`, 'block');
                }

                const remainingDamage = lsDamage - enemyBlockUsed;
                if (remainingDamage > 0) {
                    state.currentEnemy.health -= remainingDamage;
                }

                // Lifesteal der Karte (direkt, unabhängig von Upgrade)
                const healFromCardLifesteal = Math.min(card.healAmount || 0, state.player.maxHealth - state.player.health);
                if (healFromCardLifesteal > 0) {
                    state.player.health += healFromCardLifesteal;
                    logMessage(`🧛 Vampirbiss heilt ${healFromCardLifesteal} Leben.`, 'lifesteal');
                }

                enemyContainerElem.classList.add('hit');
                setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
                break;


            case 'firearrow':
                    let baseFireDamage = card.power;

                    // Doppelter Schaden bei Eis-Gegner
                    if (state.currentEnemy.traits?.includes('Eis-Elementar')) {
                        baseFireDamage *= 2;
                        logMessage(`🔥 Effektiv! ${state.currentEnemy.name} erhält doppelten Schaden durch Feuer.`, 'system');
                    }

                    // Bonus-Effekte anwenden
                    let fireDamage = applyDamageBonuses(baseFireDamage);

                    // Block berücksichtigen
                    const enemyBlock = state.currentEnemy.block || 0;
                    const blockUsed = Math.min(enemyBlock, fireDamage);
                    const damageAfterBlock = Math.max(0, fireDamage - blockUsed);

                    if (blockUsed > 0) {
                        state.currentEnemy.block -= blockUsed;
                        logMessage(`🛡️ ${state.currentEnemy.name} blockt ${blockUsed} Schaden.`, 'block');
                    }

                    state.currentEnemy.health -= damageAfterBlock;
                    logMessage(`${state.currentEnemy.name} erleidet ${damageAfterBlock} Schaden durch Feuerpfeil.`, 'enemy');

                    enemyContainerElem.classList.add('hit');
                    setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);

                    // 50% Verbrennungs-Chance
                    if (Math.random() < 0.5) {
                        const alreadyBurning = state.currentEnemy.statusEffects?.some(e => e.type === 'burn');
                        if (!alreadyBurning) {
                            state.currentEnemy.statusEffects.push({
                                type: 'burn',
                                power: 5,
                                duration: 2
                            });
                            logMessage(`${state.currentEnemy.name} wird verbrannt! (5 Schaden für 2 Runden)`, 'burn');
                        } else {
                            logMessage(`${state.currentEnemy.name} ist bereits verbrannt.`, 'system');
                        }
                        updateEnemyUI();
                    }
                    break;


         case 'gamble':
                if (Math.random() < 0.5) {
                    // Negativer Effekt
                    state.player.health -= card.power;
                    logMessage(`💥 Pech gehabt! Du verlierst ${card.power} Leben.`, 'player');
                } else {
                    // Positiver Effekt → Schaden am Gegner mit Boni
                    let gambleDamage = applyDamageBonuses(card.power);

                    state.currentEnemy.health -= gambleDamage;
                    state.player.gold += 100;
                    logMessage(`🍀 Glück gehabt! Gegner erleidet ${gambleDamage} Schaden und du erhältst 100 Gold.`, 'system');

                    enemyContainerElem.classList.add('hit');
                    setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
                }
                break;


        case 'draw':
            const drawn = drawCards(card.power);
            if (drawn > 0) {
                logMessage(`Ziehe ${drawn} Karte(n).`, 'system');
            } else {
                logMessage(`Keine Karten gezogen – Hand ist voll oder Deck leer.`, 'discard');
            }
            updateHandUI();
            break;

        case 'gain_mana':
            const manaGained = Math.min(card.power, state.player.maxMana - state.player.mana);
            if (manaGained > 0) {
                state.player.mana += manaGained;
                logMessage(`Erhalte ${manaGained} Mana.`, 'mana');
            } else {
                logMessage(`Mana ist bereits voll.`, 'mana');
            }
            break;

        default:
            logMessage(`Unbekannter Effekt: ${card.effect}`, 'system');
        }
    }


        function dealDamage(target, amount) {
            const blockUsed = Math.min(target.block || 0, amount);
            const remaining = Math.max(0, amount - blockUsed);

            if (blockUsed > 0) {
                target.block -= blockUsed;
                logMessage(`${target.name} blockt ${blockUsed} Schaden.`, 'block');
            }

            if (remaining > 0) {
                target.health -= remaining;
                logMessage(`${target.name} erleidet ${remaining} Schaden.`, 'enemy');
            } else {
                logMessage(`${target.name} blockt den gesamten Schaden!`, 'block');
            }

            enemyContainerElem.classList.add('hit');
            setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
        }


        function tryApplyParalyze(target, chance = 1.0) {
                // Immun gegen Paralyse durch "Gepanzerte Schuppen"
                if (target.traits?.includes('Gepanzerte Schuppen')) {
                    logMessage(`🛡️ ${target.name} ist immun gegen Paralyse!`, 'enemy');
                    return;
                }

                // Bereits paralysiert?
                if (target.statusEffects?.some(e => e.type === 'paralyze')) {
                    logMessage(`⚡ ${target.name} ist bereits paralysiert.`, 'system');
                    return;
                }

                // Paralyse mit Chance anwenden
                if (Math.random() < chance) {
                    if (!target.statusEffects) target.statusEffects = [];
                    target.statusEffects.push({ type: 'paralyze', duration: 2 });
                    logMessage(`⚡ ${target.name} wird paralysiert!`, 'enemy');
                    updateEnemyUI();
                } else {
                    logMessage(`⚡ Der Paralyseversuch bei ${target.name} ist fehlgeschlagen.`, 'system');
                }
            }



        function applyDamageBonuses(baseDamage) {
            let damage = baseDamage;

            if (state.player.tempAttackBonus) {
                damage += state.player.tempAttackBonus;
                logMessage(`💥 Kraftbonus: +${state.player.tempAttackBonus} Schaden!`, 'buff');
                state.player.tempAttackBonus = 0;
            }

            if (state.player.isMartyr) {
                const lostPercent = 1 - (state.player.health / state.player.maxHealth);
                const martyrBonus = Math.floor(damage * lostPercent);
                damage += martyrBonus;
                logMessage(`⚔️ Märtyrer: +${martyrBonus} Bonus-Schaden durch erlittenen Schmerz.`, 'system');
            }

            return damage;
}


    
        function endTurn() {
             if (state.gameOver || state.turnInProgress) return;
             state.turnInProgress = true; // Verhindert Aktionen während des Zugendes/Gegnerzugs
             updateCardAvailability(); // Deaktiviert Karten/Buttons
    
             logMessage("Spieler beendet den Zug.", 'system');
    
             // 3. UI aktualisieren (leere Hand, kein Block)
             updateHandUI();
             updateUIDisplay();
    
             // 4. Gegnerzug starten (mit Verzögerung)
             setTimeout(enemyTurn, 600); // Kurze Pause
        }
    
        function manaBoost() {
            if (state.gameOver || state.turnInProgress || cardsPlayedThisTurn > 0) return;

            logMessage("Spieler nutzt Mana Boost. Mana wird vollständig aufgefüllt. Zug wird beendet.", 'mana');

            // Fülle Mana komplett auf
            state.player.mana = state.player.maxMana;


            updateUIDisplay(); // UI sofort aktualisieren
            

            // Jetzt Zug beenden – turnInProgress wird dort korrekt gesetzt
            setTimeout(() => {
                endTurn(); // wichtig: verzögert aufrufen
            }, 100); // kleine Pause für bessere UX
        }

    

// --- Gegnerzug-Logik ---
        function applyEnemyTraitEffectsBeforeAttack() {
                const enemy = state.currentEnemy;

                if (!enemy.traitRounds) enemy.traitRounds = 0;
                enemy.traitRounds++;

                // STARK – Verdoppelt nach 3 Runden
                if (enemy.traits?.includes('Stark') && enemy.traitRounds === 3) {
                    enemy.attack *= 2;
                    logMessage(`${enemy.name} wird wütend! Angriff verdoppelt auf ${enemy.attack}!`, 'enemy');
                }

                // UNTOTENBESCHWÖRER – nur beim ersten Mal
                if (enemy.traits?.includes('Untotenbeschwörer') && !enemy.summoned) {
                    logMessage(`${enemy.name} beschwört zwei Skelette zur Unterstützung!`, 'enemy');

                    // Skelette definieren und zur Minion-Liste hinzufügen
                    enemy.minions.push(
                        {
                            name: 'Skelett',
                            health: 5,
                            maxHealth: 5,
                            attack: 3,
                            pixelImageKey: 'Skelett' // Bildname, z. B. 'Skelett.png'
                        },
                        {
                            name: 'Skelett',
                            health: 5,
                            maxHealth: 5,
                            attack: 3,
                            pixelImageKey: 'Skelett'
                        }
                    );

                    enemy.summoned = true;
                    updateEnemyUI(); // Anzeige sofort aktualisieren
                }


                if (enemy.traits?.includes('Höllenwache') && !enemy.summonedHellhound) {
                    logMessage(`${enemy.name} ruft einen höllischen Wachhund zur Hilfe!`, 'enemy');

                    enemy.minions.push({
                        name: 'Höllenhund',
                        health: 50,
                        maxHealth: 50,
                        attack: 15,
                        pixelImageKey: 'hund'
                    });

                    enemy.summonedHellhound = true;
                    updateEnemyUI();
                }

                // VERSPIELT – 20% verfehlt
                if (enemy.traits?.includes('Verspielt') && Math.random() < 0.2) {
                    logMessage(`${enemy.name} spielt herum und verfehlt seinen Angriff.`, 'enemy');
                    enemy.skipAttack = true;
                }

                // FLIEGEND – ignoriert Block (25%)
                if (enemy.traits?.includes('Fliegend') && Math.random() < 0.75) {
                    logMessage(`${enemy.name} greift aus der Luft an – dein Block wird ignoriert!`, 'enemy');
                    state.player.block = 0;
                }
            }

            function applyEnemyTraitEffectsAfterAttack(damage) {
                const enemy = state.currentEnemy;

                // GIFTIG
                if (
                    enemy.traits?.includes('Giftig') &&
                    Math.random() < 0.3 &&
                    !state.player.statusEffects?.some(e => e.type === 'poison')
                ) {
                    if (state.player.immuneToStatus) {
                        logMessage(`🛡️ Drachenschuppen schützt dich vor Vergiftung.`, 'system');
                    } else {
                        if (!state.player.statusEffects) state.player.statusEffects = [];
                        state.player.statusEffects.push({ type: 'poison', power: 2, duration: 3 });
                        logMessage(`☠️ Du wurdest vergiftet (2 Schaden für 3 Runden)!`, 'poison');
                    }
            }

                // FROST-AURA
                if (enemy.traits?.includes('Frost-Aura') && Math.random() < 0.20) {
                if (state.player.immuneToStatus) {
                    logMessage(`🛡️ Drachenschuppen schützt dich vor Vereisung durch Frost-Aura.`, 'system');
                } else {
                    state.player.frozen = true;
                    logMessage(`❄️ Du bist vereist und setzt nächste Runde aus!`, 'enemy');

                    // Visual Effect: Spielerfeld wird blau (vereist)
                    document.getElementById('playerDisplay').style.backgroundColor = 'rgba(0, 247, 255, 0.8)';
                }
            }


                // FEUERATEM
                if (enemy.traits?.includes('Feueratem') && Math.random() < 0.3) {
                const alreadyBurning = state.player.statusEffects?.some(e => e.type === 'burn');
                if (!alreadyBurning) {
                    if (state.player.immuneToStatus) {
                        logMessage(`🛡️ Drachenschuppen schützt dich vor Feuer.`, 'system');
                    } else {
                        if (!state.player.statusEffects) state.player.statusEffects = [];
                        state.player.statusEffects.push({ type: 'burn', power: 5, duration: 2 });
                        logMessage(`🔥 Du brennst – 5 Schaden für 2 Runden!`, 'enemy');
                    }
                }
            }

            // ⚔️ NEU: KRIEGER-Trait – Chance auf Extra-Angriff mit Verzögerung
            if (enemy.traits?.includes('Krieger') && Math.random() < 0.3) {
                logMessage(`⚔️ ${enemy.name} holt zu einem weiteren Schlag aus...`, 'enemy');

                setTimeout(() => {
                    const bonusDamage = enemy.attack || 0;
                    const blockUsed = Math.min(state.player.block, bonusDamage);
                    const damageTaken = Math.max(0, bonusDamage - blockUsed);

                    if (blockUsed > 0) {
                        state.player.block -= blockUsed;
                        logMessage(`🛡️ Spieler blockt ${blockUsed} Schaden vom Zusatzschlag.`, 'block');
                    }

                    if (damageTaken > 0) {
                        state.player.health -= damageTaken;
                        logMessage(`💥 ${enemy.name} trifft erneut und verursacht ${damageTaken} Extraschaden!`, 'enemy');
                    } else {
                        logMessage(`${enemy.name}'s Zusatzschlag wird komplett geblockt.`, 'block');
                    }

                    updateUIDisplay();

                    if (state.player.health <= 0) {
                        gameOver();
                    }
                }, 600); // ≈ 0.6 Sekunden Verzögerung – angenehm sichtbar
            }
        }


            function enemyTurn() {

                state.turnInProgress = true;
                state.player.frozen = false;

                logMessage("🔁 Gegner ist am Zug...", 'enemy');

                applyEnemyTraitEffectsBeforeAttack();

                // Wenn Minions vorhanden sind, greifen sie zuerst an
                if (state.currentEnemy.minions?.length) {
                    state.currentEnemy.minions.forEach(minion => {
                        let damage = minion.attack || 0;
                        const blockUsed = Math.min(state.player.block, damage);
                        const damageTaken = Math.max(0, damage - blockUsed);

                        if (blockUsed > 0) {
                            state.player.block -= blockUsed;
                            logMessage(`🛡️ Spieler blockt ${blockUsed} Schaden von ${minion.name}.`, 'block');
                        }

                        if (damageTaken > 0) {
                            state.player.health -= damageTaken;
                            logMessage(`💀 ${minion.name} fügt dir ${damageTaken} Schaden zu!`, 'enemy');
                        } else {
                            logMessage(`${minion.name} wird komplett geblockt.`, 'block');
                        }
                    });
                }


                if (state.currentEnemy.skipAttack) {
                    state.currentEnemy.skipAttack = false;
                    applyEnemyStatusEffectsAfterTurn();
                    updateUIDisplay();
                    setTimeout(startNewTurn, 800);
                    return;
                }

                let damage = state.currentEnemy.attack || 0;

                const paralyzeEffect = state.currentEnemy.statusEffects?.find(e => e.type === 'paralyze');
                if (paralyzeEffect) {
                    damage = Math.floor(damage / 2);
                    logMessage(`⚡ Paralyse reduziert den Angriff des Gegners auf ${damage}.`, 'enemy');
                }

                if (state.currentEnemy.traits?.includes('Höllen Krallen') && Math.random() < 0.45) {
                    damage = Math.floor(damage * 1.5);
                    logMessage(`💥 Kritischer Treffer! Schaden erhöht auf ${damage}.`, 'enemy');
                }

                const blockUsed = Math.min(state.player.block, damage);
                const damageTaken = Math.max(0, damage - state.player.block);

                if (blockUsed > 0) {
                    state.player.block -= blockUsed;
                    logMessage(`🛡️ Spieler blockt ${blockUsed} Schaden.`, 'block');
                }
                if (damageTaken > 0) {
                    state.player.health -= damageTaken;
                    logMessage(`💥 Spieler erleidet ${damageTaken} Schaden.`, 'player');


                    // ⚡ Paralyse durch "Statisch"-Trait
                    const hasStaticTrait = state.currentEnemy.traits?.includes('Statisch');
                    const alreadyParalyzed = state.player.statusEffects?.some(e => e.type === 'paralyze');

                    if (hasStaticTrait && !alreadyParalyzed && Math.random() < 0.45) {
                        if (state.player.immuneToStatus) {
                            logMessage(`🛡️ Drachenschuppen schützt dich vor Paralyse durch Statisch.`, 'system');
                        } else {
                            if (!state.player.statusEffects) state.player.statusEffects = [];
                            state.player.statusEffects.push({ type: 'paralyze', duration: 3 });
                            logMessage(`⚡ Du wurdest durch den statischen Angriff paralysiert!`, 'enemy');
                            updatePlayerStatusDisplay();
                        }
                    }


                    // 🪓 Dornen-Helm: Gegner erleidet Rückstoß
                if (state.player.hasThorns) {
                    const thornDamage = Math.floor(damageTaken * 0.3);
                    if (thornDamage > 0) {
                        state.currentEnemy.health -= thornDamage;
                        logMessage(`🪓 Dornen-Helm: ${state.currentEnemy.name} erleidet ${thornDamage} Rückstoß-Schaden!`, 'enemy');
                        updateEnemyUI();
                    }
                }

                    playerDisplay.classList.add('shake');
                    updatePlayerStatusDisplay();

                    // Nach Shake-Effekt Statusanzeige aktualisieren
                    setTimeout(() => {
                        playerDisplay.classList.remove('shake');
                    }, 250);
                } else {
                    logMessage("🧱 Angriff komplett geblockt!", 'block');
                }

                applyEnemyTraitEffectsAfterAttack(damage);

                if (
                    damageTaken > 0 &&
                    state.currentEnemy.traits?.includes('Vamp')
                ) {
                    const heal = Math.floor(damageTaken * 0.5);
                    const maxHealable = state.currentEnemy.maxHealth - state.currentEnemy.health;
                    const actualHeal = Math.min(heal, maxHealable);

                    if (actualHeal > 0) {
                        state.currentEnemy.health += actualHeal;
                        logMessage(`🩸 ${state.currentEnemy.name} saugt ${actualHeal} Leben durch Vamp!`, 'lifesteal');
                        updateEnemyUI();
                    }
                }

                
              // 🕊 Göttlicher Segen – Erzengel heilt sich einmalig bei unter 50 % Leben
                if (
                    (state.currentEnemy.name === 'Erzengel' || state.currentEnemy.name === 'Yagdril') &&
                    state.currentEnemy.traits.includes('Segen') &&
                    !state.currentEnemy.hasUsedBlessing &&
                    state.currentEnemy.health < state.currentEnemy.maxHealth / 2
                ) {
                    const missingHealth = state.currentEnemy.maxHealth - state.currentEnemy.health;
                    const healAmount = Math.floor(missingHealth / 2);
                    state.currentEnemy.health += healAmount;
                    state.currentEnemy.hasUsedBlessing = true;

                    logMessage(`🕊 ${state.currentEnemy.name} erhält einen göttlichen Segen!`, 'system');
                    logMessage(`✨ Heilt ${healAmount} Leben.`, 'heal');
                    updateEnemyUI();
                }

                applyEnemyStatusEffectsAfterTurn();

                updateUIDisplay();

                if (state.player.health <= 0) {
                    gameOver();
                } else {
                    setTimeout(startNewTurn, 800); // Immer neue Runde einleiten, wenn nicht tot
                }
            }


            // --- Status-Effekte beim Gegner auswerten ---
            function applyEnemyStatusEffectsAfterTurn() {
                if (!state.currentEnemy || !state.currentEnemy.statusEffects) return;

                let totalPoisonDamage = 0;
                let totalBurnDamage = 0;

                for (let effect of state.currentEnemy.statusEffects) {
                    switch (effect.type) {
                        case 'poison':
                            logMessage(`${state.currentEnemy.name} erleidet ${effect.power} Giftschaden.`, 'poison');
                            totalPoisonDamage += effect.power;
                            effect.duration -= 1;
                            break;

                        case 'burn':
                            logMessage(`${state.currentEnemy.name} erleidet ${effect.power} Feuerschaden.`, 'burn');
                            totalBurnDamage += effect.power;
                            effect.duration -= 1;
                            break;

                        case 'paralyze':
                            logMessage(`${state.currentEnemy.name} ist gelähmt – Angriff halbiert. (${effect.duration} Runden übrig)`, 'paralyze');
                            effect.duration -= 1;
                            break;
                    }
                }


                // Gesamtschaden anwenden
                if (totalPoisonDamage > 0) {
                    state.currentEnemy.health -= totalPoisonDamage;
                }
                if (totalBurnDamage > 0) {
                    state.currentEnemy.health -= totalBurnDamage;
                }

                // Abgelaufene Effekte entfernen
                state.currentEnemy.statusEffects = state.currentEnemy.statusEffects.filter(e => e.duration > 0);

                // Regeneration
                if (state.currentEnemy.regen && state.currentEnemy.health < state.currentEnemy.maxHealth) {
                    const heal = Math.min(state.currentEnemy.regen, state.currentEnemy.maxHealth - state.currentEnemy.health);
                    if (heal > 0) {
                        state.currentEnemy.health += heal;
                        logMessage(`${state.currentEnemy.name} regeneriert ${heal} Leben.`, 'heal');
                    }
                }

                updateEnemyUI();

                if (state.currentEnemy.health <= 0) {
                    logMessage(`${state.currentEnemy.name} stirbt an Statuseffekten!`, 'system');
                    checkEnemyDefeat();
                }
            }

    
        // Beginnt eine neue Runde für den Spieler
        function startNewTurn() {
            if (state.gameOver) return; // Kein neuer Zug, wenn Spiel vorbei ist
            state.turnInProgress = false;

            //Block erst jetzt zurücksetzen
            if (state.player.block > 0) {
                    logMessage(`Block (${state.player.block}) verschwindet.`, 'block');
                    state.player.block = 0;
                }

            if (state.player.isShieldmaster) {
                state.player.block += 5;
                logMessage('🛡️ Schildmeister: Du erhältst 5 Block.', 'block');
                }


  
            state.currentEnemy.block = 0;

                 // RÜSTUNG: 5 Block pro Runde
            if (state.currentEnemy.traits?.includes('Rüstung')) {
                 state.currentEnemy.block = (state.currentEnemy.block || 0) + 5;
                logMessage(`${state.currentEnemy.name} erhält 5 Block durch Rüstung.`, 'block');
             }

             // ✅ Blutrüstung heilt 2 Leben
             if (state.player.hasBloodArmor && state.player.health < state.player.maxHealth) {
                const heal = Math.min(3, state.player.maxHealth - state.player.health);
                if (heal > 0) {
                    state.player.health += heal;
                    logMessage(`🩸 Blutrüstung heilt ${heal} Leben.`, 'heal');
                }
            }
    
             // 1. Mana auffüllen
             const baseRegen = 1;
                const bonusRegen = state.player.passiveManaRegen || 0;
                state.player.mana = Math.min(
                state.player.mana + baseRegen + bonusRegen,
                state.player.maxMana
                );

                state.usedPowerSurgeThisTurn = false;

        // Zieht so viele Karten, bis die Hand (ohne Sonderkarten) voll ist
            const handCount = state.player.hand.filter(c => c.name !== 'Donner-Zauber').length;
            const missingCards = state.player.maxHandSize - handCount;
            if (missingCards > 0) {
                drawCards(missingCards);
            }

             // PET-AKTION MIT ANIMATION
             if (state.player.activePet) {
    const pet = state.player.activePet;
    let damage = 0;
    let blockGain = 0;
    let manaGain = 0;
    let logText = '';

    switch (pet.effect) {
        case 'gawa':
            damage = 4;
            logText = `🐾 ${pet.name} greift an – ${damage} Schaden.`;
            break;
        case 'lulu':
            damage = 2;
            manaGain = 1;
            logText = `🦊 ${pet.name} wirkt Magie – ${damage} Schaden + ${manaGain} Mana.`;
            break;
        case 'cassa':
            damage = 1;
            blockGain = 3;
            logText = `🐍 ${pet.name} verteidigt dich – ${damage} Schaden + ${blockGain} Block.`;
            break;
    }

    const petImage = document.querySelector('#petContainer img:not([src*="hellhound"])');
    if (petImage) {
        petImage.classList.add('wobble');
        setTimeout(() => petImage.classList.remove('wobble'), 300);
    }

    setTimeout(() => {
        state.currentEnemy.health -= damage;
        state.player.block += blockGain;
        state.player.mana = Math.min(state.player.maxMana, state.player.mana + manaGain);
        logMessage(logText, blockGain ? 'block' : damage ? 'enemy' : 'system');
        updateEnemyUI();
        updateUIDisplay();
        updatePetDisplay();
        //FALLS KAPUTT
    if (state.currentEnemy.health <= 0) {
            checkEnemyDefeat();
        }
    }, 600);
}

// 🔥 HÖLLENHUND → jetzt immer separat prüfen!
if (state.player.hellhound) {
    setTimeout(() => {
        const hellhoundDamage = state.player.hellhound.damage || 2;
        state.currentEnemy.health -= hellhoundDamage;
        logMessage(`🔥 Dein Teufelshund greift an und verursacht ${hellhoundDamage} Schaden!`, 'enemy');

        const hellhoundImage = document.querySelector('#petContainer img[src*="hellhound"]');
        if (hellhoundImage) {
            hellhoundImage.classList.add('wobble');
            setTimeout(() => hellhoundImage.classList.remove('wobble'), 300);
        }

        updateEnemyUI();
        if (state.currentEnemy.health <= 0) {
            checkEnemyDefeat();
        }
    }, 300); // etwas nach dem Pet
}


            // Zähler zurücksetzen
            cardsPlayedThisTurn = 0;

            // Status-Effekte anwenden
            if (state.player.statusEffects?.length > 0) {
                for (let effect of state.player.statusEffects) {
                    if (effect.type === 'poison' || effect.type === 'burn') {
                        logMessage(`☠️ ${effect.type === 'burn' ? 'Verbrennung' : 'Vergiftung'} fügt dir ${effect.power} Schaden zu.`, 'player');
                        state.player.health -= effect.power;
                        effect.duration -= 1;
                    } else if (effect.type === 'paralyze') {
                        logMessage(`⚡ Du bist paralysiert und kannst nur 3 Karten spielen. (${effect.duration} Runden)`, 'system');
                        effect.duration -= 1;
                    }
                }

                // Entferne abgelaufene Effekte
                state.player.statusEffects = state.player.statusEffects.filter(e => e.duration > 0);
            }
            updatePlayerStatusDisplay();
    
              // TODO: Spieler-Statuseffekte anwenden (z.B. Gift erleidet Schaden)
    
             // 4. UI aktualisieren
             updateUIDisplay();
             updateHandUI(); // Gezogene Karten anzeigen
             updatePlayerItemIcons();
    
             // 5. Spieleraktionen wieder erlauben
             state.turnInProgress = false;
             updateCardAvailability(); // Aktiviert spielbare Karten/Buttons
             updateEnemyUI();
             updatePlayerItemIcons();
             updatePlayerStatusDisplay();
    
        }

    
        // Prüft, ob der aktuelle Gegner besiegt ist
        function checkEnemyDefeat() {
            if (state.currentEnemy && state.currentEnemy.health <= 0) {
            const defeatedName = state.currentEnemy.name;
            logMessage(`${defeatedName} besiegt!`, 'system');
            state.defeatedEnemies++;

            // 🔓 Direkt beim Besiegen speichern!
            if (defeatedName === 'Nekromant') {
                localStorage.setItem('unlockedGoldboy', 'true');
                logMessage('🗝️ Passive "Goldjunge" freigeschaltet!', 'system');
            }
            if (defeatedName === 'Drache') {
                localStorage.setItem('unlockedDragonscale', 'true');
                logMessage('🗝️ Passive "Drachenschuppen" freigeschaltet!', 'system');
            }
            if (defeatedName === 'Teufel') {
                localStorage.setItem('unlockedUndead', 'true');
                logMessage('🗝️ Passive "Totenbeschwörer" freigeschaltet!', 'system');
            }

            const xpGained = state.currentEnemy.xp || 50;
            gainXP(xpGained);

            const goldEarned = state.currentEnemy.gold || 0;
            state.player.gold += goldEarned;
            logMessage(`💰 Du erhältst ${goldEarned} Gold.`, 'system');
            updateUIDisplay();

            // NEU: Volles Mana wiederherstellen
            state.player.mana = state.player.maxMana;
            logMessage(`🔋 Dein Mana wurde vollständig aufgefüllt.`, 'mana');

            enemyContainerElem.classList.add('defeat');

                setTimeout(() => {
                    // UI zurücksetzen + Suche anzeigen
                    state.currentEnemy = null;
                    enemyNameElem.textContent = '🔍 Suche nach neuem Gegner...';
                    enemyHealthElem.textContent = '-';
                    enemyMaxHealthElem.textContent = '-';
                    enemyHealthBarElem.style.width = '0%';
                    enemyAttackElem.textContent = '-';
                    monsterImageElem.style.backgroundImage = 'none';
                    monsterImageElem.style.backgroundColor = '#333';
                    enemyInfoElem.textContent = '';
                    monsterTraitsElem.innerHTML = '';
                    document.getElementById('enemyMinions').innerHTML = '';
                }, 400);

                // Nach 3 Sekunden neuen Gegner laden + neue Runde starten
                setTimeout(() => {
                    loadEnemy(); 
                    state.turnInProgress = false;
                    updateUIDisplay();
                    updateEnemyUI();
                    startNewTurn();
                }, 2000);

                return true;
            } else {
                state.turnInProgress = false;
                updateCardAvailability();
                return false;
            }
        }

    
            // Verarbeitet erhaltene XP und prüft auf Level Up
            function gainXP(amount) {
                if (state.gameOver) return;
                state.player.xp += amount;
                logMessage(`+${amount} XP erhalten!`, 'xp');

                // Level Up prüfen (kann mehrmals passieren bei viel XP)
                while (state.player.xp >= state.player.xpToNextLevel && !state.gameOver) {
                    levelUp();
                }
                updateUIDisplay(); // XP-Balken aktualisieren
            }

            // Führt einen Level Up durch
            function levelUp() {
                state.player.level++;
                state.player.xp -= state.player.xpToNextLevel;
                state.player.xpToNextLevel = Math.floor(BASE_XP_TO_LEVEL_UP * Math.pow(LEVEL_UP_FACTOR, state.player.level - 1));
                logMessage(`*** Level Up! Spieler erreicht Level ${state.player.level}! ***`, 'system');

                setTimeout(() => {
                    showUpgradeScreen();
                }, 500); // kurze Verzögerung für saubere UX
            }

    
            function showUpgradeScreen() {
                state.turnInProgress = true;
                updateCardAvailability();

                // UI vorbereiten
                upgradeOptionsElem.innerHTML = '';
                upgradeTitleElem.textContent = `Level ${state.player.level}! Wähle ein Upgrade`;

                // Shop-Icon sicher wieder einblenden
                const shopIcon = document.getElementById('shopIconContainer');
                if (shopIcon) {
                    shopIcon.style.display = 'block';
                }

                // Immer dabei: feste Gold-Option
                const goldOption = {
                    type: 'gainGoldFixed',
                    title: 'Goldbeutel +350',
                    description: 'Erhalte 350 Gold.',
                    rarity: 'common'
                };
                
                // Upgrade-Pool filtern und gewichten
                const availableUpgrades = UPGRADE_TYPES.filter(upg => upg.type !== 'gain_gold');
                const weightedPool = getWeightedUpgrades(availableUpgrades, 1, 15, 50);
                const chosenUpgrades = [goldOption, ...weightedPool.slice(0, 2)];

                // Spezialoption für bestimmte Klassen
                if (state.player.passive === 'undead') {
                    chosenUpgrades.push({
                        type: 'hellhoundBoost',
                        title: '🍗 Totenkeule 🍗',
                        description: 'Dein Höllenhund verursacht +1 Schaden.',
                        rarity: 'rare'
                    });
                }


                // Upgrade-Optionen erzeugen
                chosenUpgrades.forEach(upgrade => {
                    const optionDiv = document.createElement('div');
                    optionDiv.classList.add('upgrade-option');

                    if (upgrade.rarity === 'rare') optionDiv.classList.add('rare');
                    if (upgrade.rarity === 'superrare') optionDiv.classList.add('superrare');

                    // Dynamischer Titel für Lifesteal
                    if (upgrade.type === 'lifesteal') {
                        const currentStacks = state.player.lifestealStacks || 0;
                        upgrade.title = `Lebensraub ${currentStacks + 1}`;
                    }

                    optionDiv.innerHTML = `
                        <h3>${upgrade.title}</h3>
                        <p>${upgrade.description}</p>
                    `;

                    optionDiv.addEventListener('click', () => {
                        applyUpgrade(upgrade);

                        // Shop-Icon nach Upgrade-Wahl ausblenden
                        if (shopIcon) {
                            shopIcon.style.display = 'none';
                        }
                    });

                    upgradeOptionsElem.appendChild(optionDiv);
                });

                // Upgrade-Screen anzeigen
                upgradeContainerElem.style.display = 'flex';
            }



    
          // Wendet das gewählte Upgrade an (PLATZHALTER - HIER MUSS DIE LOGIK REIN!)
         function applyUpgrade(upgrade) {
             logMessage(`Upgrade gewählt: ${upgrade.title}`, 'system');
         switch(upgrade.type) {  

        case 'blackMarketGold': {
                    logMessage(`🖤 Willkommen beim Schwarzmarkt! Verkaufe eine Karte *für dieses Spiel* gegen Gold.`, 'system');

                    upgradeOptionsElem.innerHTML = '';
                    upgradeTitleElem.textContent = 'Schwarzmarkt – Das heutige Angebot:';

                    const forbiddenCardIds = [1]; // Schwert darf niemals verkauft werden

                    // Karten im Deck, die NICHT das Schwert sind
                    const unlockedNonSwordCards = CARD_TYPES.filter(card =>
                        state.unlockedCardIds.has(card.id) &&
                        !forbiddenCardIds.includes(card.id)
                    );

                    if (unlockedNonSwordCards.length === 0) {
                        logMessage(`⚠️ Keine verkaufbaren Karten verfügbar.`, 'system');
                        return;
                    }

                    shuffleArray(unlockedNonSwordCards);
                    const offeredCards = unlockedNonSwordCards.slice(0, 3);

                    offeredCards.forEach(card => {
                        const sellPrice = getRandomInt(100, 600);

                        const cardDiv = document.createElement('div');
                        cardDiv.classList.add('card', 'card-choice');
                        if (card.rarity === 'rare') cardDiv.classList.add('rare');
                        if (card.rarity === 'superrare') cardDiv.classList.add('superrare');

                        cardDiv.innerHTML = `
                            <div class="card-mana">${card.manaCost}</div>
                            <div class="card-name">${card.name}</div>
                            <div class="card-icon">${card.icon}</div>
                            <div class="card-description">${card.description}</div>
                            <div class="card-power">${card.power ?? ''}</div>
                            <div class="sell-price">💰 ${sellPrice} Gold</div>
                        `;

                        cardDiv.querySelector('.sell-price').style.marginTop = '8px';
                        cardDiv.querySelector('.sell-price').style.fontWeight = 'bold';
                        cardDiv.querySelector('.sell-price').style.color = '#ffd700';

                        cardDiv.addEventListener('click', () => {
                            // Entferne nur aus Deck/Hand/Discard – unlocked bleibt!
                            ['deck', 'hand', 'discardPile'].forEach(pile => {
                                state.player[pile] = state.player[pile].filter(c => c.id !== card.id);
                            });

                            state.player.gold += sellPrice;
                            logMessage(`💸 ${card.name} wurde für ${sellPrice} Gold verkauft.`, 'gold');

                            upgradeContainerElem.style.display = 'none';
                            updateUIDisplay();
                            updateHandUI();
                            state.turnInProgress = false;
                        });

                        upgradeOptionsElem.appendChild(cardDiv);
                    });

                    // Ablehnen-Button
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = '❌ Angebote ablehnen';
                    cancelBtn.style.marginTop = '20px';
                    cancelBtn.style.padding = '6px 12px';
                    cancelBtn.style.fontSize = '14px';
                    cancelBtn.style.backgroundColor = '#444';
                    cancelBtn.style.color = '#fff';
                    cancelBtn.style.border = '1px solid #888';
                    cancelBtn.style.borderRadius = '6px';
                    cancelBtn.style.cursor = 'pointer';

                    cancelBtn.addEventListener('click', () => {
                        logMessage(`🚫 Du hast die Schwarzmarkt-Angebote abgelehnt.`, 'system');
                        upgradeContainerElem.style.display = 'none';
                        state.turnInProgress = false;
                    });

                    upgradeOptionsElem.appendChild(cancelBtn);
                    upgradeContainerElem.style.display = 'flex';
                    return;
                }


            case 'swapCard': {
                logMessage(`🔁 Wähle eine freigeschaltete Karte, die du dauerhaft entfernen möchtest.`, 'system');

                upgradeOptionsElem.innerHTML = '';
                upgradeTitleElem.textContent = 'Karte zum Entfernen wählen';

                const forbiddenCardIds = [1]; // Schwert darf nicht gelöscht werden

                const ownedCardIds = new Set(state.player.deck.map(c => c.id));
                const removableCards = CARD_TYPES.filter(card =>
                    state.unlockedCardIds.has(card.id) &&
                    !forbiddenCardIds.includes(card.id)
                );

                if (removableCards.length === 0) {
                    logMessage('⚠️ Keine entfernbare Karte verfügbar.', 'system');
                    return;
                }

                shuffleArray(removableCards);
                const choicesToRemove = removableCards.slice(0, 6);

                // Zeige Karten zur Auswahl
                choicesToRemove.forEach(card => {
                    const cardDiv = createCardElement(card);
                    cardDiv.addEventListener('click', () => {
                        // Entferne die Karte aus Deck, Hand, Ablage
                        ['deck', 'hand', 'discardPile'].forEach(pile => {
                            state.player[pile] = state.player[pile].filter(c => c.id !== card.id);
                        });

                        // Entferne aus freigeschaltetem Pool nur für diese Session
                        state.unlockedCardIds.delete(card.id);
                        logMessage(`❌ ${card.name} wurde dauerhaft aus deinem Deck entfernt.`, 'discard');

                        // Jetzt neue Karten anbieten (nicht besessen + nicht verboten)
                        const forbiddenCardIdsAdd = [17, 18, 19]; // keine Ultra-Karten
                        const addableCards = CARD_TYPES.filter(c =>
                            !forbiddenCardIdsAdd.includes(c.id) &&
                            !state.unlockedCardIds.has(c.id)
                        );

                        if (addableCards.length === 0) {
                            logMessage(`⚠️ Keine neuen Karten mehr verfügbar zum Hinzufügen.`, 'system');
                            upgradeContainerElem.style.display = 'none';
                            return;
                        }

                        shuffleArray(addableCards);
                        const choicesToAdd = addableCards.slice(0, 6);

                        upgradeOptionsElem.innerHTML = '';
                        upgradeTitleElem.textContent = 'Neue Karte wählen';

                        choicesToAdd.forEach(newCard => {
                            const newCardDiv = createCardElement(newCard);
                            newCardDiv.addEventListener('click', () => {
                                const instance = createCardInstance(newCard);
                                state.player.deck.push(instance);
                                state.unlockedCardIds.add(newCard.id);

                                logMessage(`✨ ${newCard.name} wurde deinem Deck hinzugefügt und freigeschaltet.`, 'system');

                                upgradeContainerElem.style.display = 'none';
                                updateUIDisplay();
                                updateHandUI();
                                state.turnInProgress = false;
                            });
                            upgradeOptionsElem.appendChild(newCardDiv);
                        });
                    });

                    upgradeOptionsElem.appendChild(cardDiv);
                });

                upgradeContainerElem.style.display = 'flex';
                return;
            }

            case 'hellhoundBoost':
                if (state.player.hellhound) {
                    state.player.hellhound.damage += 1;
                    logMessage('🔥 Dein Teufelshund wird stärker – +1 Schaden!', 'system');
                    updatePetDisplay(); // 🧩 HIER HINZUFÜGEN
                }
                break;

              case 'upgradeSwordPower':
                    state.player.swordBonus = (state.player.swordBonus || 0) + 1;
                    logMessage(`Schwertbonus dauerhaft auf +${state.player.swordBonus} erhöht.`, 'system');
                    
                    // 👇 Optional: Nur zur Klarheit, keine Power-Dopplung
                    logMessage(`Vorhandene Schwerter behalten ihre Basisstärke. Bonus wird im Kampf berechnet.`, 'system');
                    
                    // Hand neu ziehen
                    state.player.discardPile.push(...state.player.hand);
                    state.player.hand = [];
                    drawCards(state.player.maxHandSize);
                    updateUIDisplay();
                    updateHandUI();
                    break;

              case 'newCardSpecific':
                    showCardChoice(getThreeUniqueNewCards()); // ✅ Lösung
                    return; // ganz wichtig, damit der Bildschirm nicht sofort verschwindet
                    case 'newUltraCardSpecific': {
                        const ultraChoices = getThreeUniqueUltraCards();

                        if (!ultraChoices || ultraChoices.length === 0) {
                            logMessage("❌ Keine Ultra-Karten verfügbar!", 'system');
                            break;
                        }

                        logMessage("🔮 Wähle eine ULTRA Karte!", 'system');
                        showCardChoice(ultraChoices, true);
                        return; // ganz wichtig
                    }
                case 'newCard':
                    const ownedCardIds = new Set(state.player.deck.map(card => card.id));
                    const possibleNewCards = CARD_TYPES.filter(card => !ownedCardIds.has(card.id));
                    if (possibleNewCards.length > 0) {
                        const randomCardType = possibleNewCards[getRandomInt(0, possibleNewCards.length - 1)];
                        const newCardInstance = createCardInstance(randomCardType);
                        state.player.deck.push(newCardInstance);
                        logMessage(`Neue Karte hinzugefügt: ${newCardInstance.name}`, 'system');
                        shuffleArray(state.player.deck);
                    } else {
                        logMessage(`Alle Karten bereits im Deck. Kein neues Upgrade möglich.`, 'system');
                    }
                    break;
                case 'regenManaPassive':
                        state.player.passiveManaRegen = (state.player.passiveManaRegen || 0) + 1;
                        logMessage(`Du regenerierst jetzt ${state.player.passiveManaRegen} zusätzliches Mana pro Runde.`, 'mana');
                        break;
                case 'regenManaPassive3':
                        state.player.passiveManaRegen = (state.player.passiveManaRegen || 0) + 3;
                        logMessage(`Du regenerierst jetzt ${state.player.passiveManaRegen} zusätzliches Mana pro Runde.`, 'mana');
                        break;                        
                 case 'upgradeHealth':
                     state.player.maxHealth += 8;
                     state.player.health += 8; // Auch heilen
                     logMessage(`Max Leben auf ${state.player.maxHealth} erhöht.`, 'system');
                     break;
                  case 'healPercent':
                      const healAmount = Math.floor(state.player.maxHealth * 0.5);
                       const actualHeal = Math.min(healAmount, state.player.maxHealth - state.player.health);
                      if(actualHeal > 0) {
                        state.player.health += actualHeal;
                        logMessage(`${actualHeal} Leben wiederhergestellt.`, 'heal');
                      } else {
                         logMessage(`Keine Heilung nötig (volles Leben).`, 'heal');
                      }
                      break;
                  case 'upgradeMana':
                      state.player.maxMana += 1;
                      state.player.mana += 1; // Optional: Auch aktuelles Mana erhöhen
                      logMessage(`Max Mana auf ${state.player.maxMana} erhöht.`, 'system');
                      break;
                  case 'increaseHandSize':
                      state.player.maxHandSize += 1;
                      logMessage(`Maximale Handgröße auf ${state.player.maxHandSize} erhöht.`, 'system');
                      break;
                case 'addLifestealFlat':
                        if (!state.player.lifestealPercent) {
                            state.player.lifestealPercent = 0;
                        }
                        state.player.lifestealPercent += 0.20;
                        logMessage(`Lebensraub um 20 % erhöht. Aktuell: ${(state.player.lifestealPercent * 100).toFixed(0)} %`, 'lifesteal');
                        break;
                  case 'gainGoldFixed':
                    state.player.gold += 350;
                    logMessage(`Du erhältst 350 Gold. Aktuell: ${state.player.gold} Gold.`, 'system');
                    break;
                case 'fuseCards':
                        showFusionModal();
                    return;
                 // --- Implementiere andere Upgrades ---
                 default:
                     logMessage(`Upgrade-Typ '${upgrade.type}' noch nicht implementiert.`, 'system');
             }
    
    
             // Upgrade-Bildschirm ausblenden und Spiel fortsetzen
             upgradeContainerElem.style.display = 'none';
             state.turnInProgress = false; // Aktionen wieder erlauben
             updateUIDisplay(); // Stats aktualisieren
             updateCardAvailability();
         }

         function showCardChoice(cards, isSuperrare = false) {
            upgradeOptionsElem.innerHTML = '';
            upgradeTitleElem.textContent = isSuperrare ? 'Wähle eine ULTRA Karte' : 'Wähle eine neue Karte';

            if (!cards || cards.length === 0) {
                logMessage("❌ Es wurden keine Karten übergeben!", 'system');
                return;
            }

            cards.forEach(card => {
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('upgrade-option');

                if (card.rarity === 'rare') {
                    optionDiv.classList.add('rare');
                }

                // 👉 WICHTIG: entweder ist die Karte superrare, oder wir erzwingen es per Flag
                if (card.rarity === 'superrare' || isSuperrare) {
                    optionDiv.classList.add('superrare');
                }

                optionDiv.innerHTML = `
                <h3>${card.name}</h3>
                <p>${card.description}</p>
                <div style="font-size: 24px; margin-top: 5px;">${card.icon}</div>
                <p style="margin-top: 4px; font-size: 12px; color: #ccc;"> Manakosten: ${card.manaCost}</p>
            `;

                optionDiv.addEventListener('click', () => {
                    const newCard = createCardInstance(card);
                    state.player.deck.push(newCard);
                    state.unlockedCardIds.add(card.id); 
                    shuffleArray(state.player.deck);
                    upgradeContainerElem.style.display = 'none';
                    state.turnInProgress = false;
                    updateUIDisplay();
                    updateCardAvailability();
                });

                upgradeOptionsElem.appendChild(optionDiv);
            });

            upgradeContainerElem.style.display = 'flex';
        }


    
        function gameOver() {
            logMessage("💀 GAME OVER!", 'enemy');
            console.log("💀 gameOver() wurde aufgerufen.");

            state.gameOver = true;
            state.turnInProgress = true;

            playerInventory.clear();

            finalScoreElem.textContent = state.defeatedEnemies;
            finalRoundElem.textContent = state.round;
            finalLevelElem.textContent = state.player.level;

            const isNewLocalRecord = state.defeatedEnemies > state.highScore;
            const playerName = (localStorage.getItem('playerName') || 'Unbekannt').substring(0, 15);

            // 🏆 Lokalen Highscore nur überschreiben, wenn besser
            if (isNewLocalRecord) {
                state.highScore = state.defeatedEnemies;
                localStorage.setItem('pixelKartenspielHighScore', state.highScore.toString());
                logMessage(`🌟 Neuer Highscore: ${state.highScore}!`, 'system');
            }

            // 💾 Immer bei Firebase speichern
            if (typeof db !== 'undefined') {
                db.collection("highscores").add({
                    name: playerName,
                    score: state.defeatedEnemies,
                    round: state.round,
                    level: state.player.level,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                }).then(() => {
                    console.log("✅ Highscore online gespeichert!");
                }).catch(err => {
                    console.warn("⚠️ Fehler beim Speichern im Highscore:", err);
                });
            } else {
                console.warn("❌ Firestore-DB nicht verfügbar.");
            }

            // Zeige Game Over Screen
            gameOverContainerElem.style.display = 'flex';

            // Verzögere Weiterleitung
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 500); // Erhöht für Debug-Zwecke
        }



    </script>
    <script src="shop.js"></script>
    <script src="fusion.js"></script>

</body>
</html>