<!DOCTYPE html>
<html lang="de">
<head>
    <link rel="icon" href="data:;base64,iVBORw0KGgo=">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sigma The Game</title>
    <style>
        /* --- Google Font Import --- */
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;700&display=swap');
    
        /* --- Global Styles --- */
        :root {
            /* Core Colors */
            --bg-color: #1a1a24;
            --text-color: #f0f0f5;
            --primary-color: #ffcc00; /* Gold */
            --secondary-color: #4a90ff; /* Mana Blue - slightly more vibrant */
            --accent-color: #ff5252; /* Enemy Red - more saturated */
            --player-color: #50e050; /* Player Green - more natural */
            --card-bg: #2d2d3d; /* Darker card background with a hint of blue */
            --rare-color: #d966ff; /* Purple for rare upgrades - more vivid */
            
            /* UI Element Colors */
            --ui-dark: #252532;
            --ui-medium: #35354a;
            --ui-light: #45455a;
            --ui-highlight: rgba(255, 255, 255, 0.1);
            
            /* Status Effect Colors */
            --poison-color: #9c27b0;
            --heal-color: #66bb6a;
            --block-color: #29b6f6;
            
            /* Card Rarities */
            --common-glow: rgba(255, 255, 255, 0.4);
            --uncommon-glow: rgba(30, 255, 0, 0.5);
            --rare-glow: rgba(0, 112, 221, 0.5);
            --epic-glow: rgba(163, 53, 238, 0.6);
            --legendary-glow: rgba(255, 128, 0, 0.6);
            
            /* Animation Speeds */
            --anim-fast: 0.2s;
            --anim-medium: 0.5s;
            --anim-slow: 1s;
            
            /* Dimensions - Responsive für mobile */
            --card-width: min(140px, 28vw);
            --card-height: min(210px, 42vw);
            --border-radius: 12px;
            
            /* Glows */
            --glow-primary: rgba(255, 204, 0, 0.5);
            --glow-player: rgba(80, 224, 80, 0.5);
            --glow-enemy: rgba(255, 82, 82, 0.5);
            --glow-rare: rgba(217, 102, 255, 0.5);
            
            /* Color variants */
            --player-color-lighter: #80e880;
            --accent-color-lighter: #ff8080;
            --secondary-color-lighter: #80b0ff;
            --text-color-secondary: #bbb;
            --border-color: rgba(255, 255, 255, 0.2);
            --border-color-light: rgba(255, 255, 255, 0.3);
        }

        /* Base Elements */
        html, body {
            -webkit-tap-highlight-color: transparent; /* Entfernt den blauen Tap-Highlight auf mobilen Geräten */
            touch-action: manipulation; /* Verhindert Zoom-Gesten auf bestimmten Elementen */
            overscroll-behavior: contain; /* Verhindert Pull-to-Refresh auf mobilen Geräten */
        }
        
        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            color: var(--text-color);
            margin: 0;
            padding: 10px;
            overflow-x: hidden;
            background-color: var(--bg-color);
            position: relative;
            
            /* Animated Background */
            background: 
                radial-gradient(circle at 20% 30%, rgba(60, 60, 120, 0.15) 0%, transparent 60%),
                radial-gradient(circle at 80% 70%, rgba(100, 25, 80, 0.1) 0%, transparent 60%),
                linear-gradient(135deg, #151520, #1d1d2b, #151520, #252535);
            background-size: 400% 400%;
            animation: gradientShift 35s ease infinite;
        }

        /* Star particles in background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                radial-gradient(1px 1px at 50px 100px, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0)),
                radial-gradient(1px 1px at 150px 300px, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0)),
                radial-gradient(1px 1px at 300px 50px, rgba(255, 255, 255, 0.5), rgba(255, 255, 255, 0)),
                radial-gradient(1px 1px at 400px 250px, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0)),
                radial-gradient(1px 1px at 500px 100px, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0)),
                radial-gradient(1px 1px at 50% 80%, rgba(255, 255, 255, 0.7), rgba(255, 255, 255, 0)),
                radial-gradient(2px 2px at 70% 90%, rgba(255, 204, 0, 0.5), rgba(255, 204, 0, 0)),
                radial-gradient(2px 2px at 30% 20%, rgba(255, 204, 0, 0.5), rgba(255, 204, 0, 0));
            pointer-events: none;
            z-index: -1;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* Typography */
        h1, h2 {
            text-align: center;
            color: var(--primary-color);
            text-shadow: 0 0 10px rgba(255, 204, 0, 0.5);
            letter-spacing: 1px;
            margin-bottom: 15px;
        }

        h1 {
            font-size: clamp(1.5rem, 5vw, 2.2rem); /* Responsive Fontgröße */
            margin-top: 10px;
        }

        h2 {
            margin-top: 15px;
            font-size: clamp(1.2rem, 4vw, 1.5rem);
        }

        /* Main Container */
        .game-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
            background-color: rgba(29, 29, 40, 0.75);
            padding: 15px;
            border-radius: var(--border-radius);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            max-width: 100%;
            margin: 0 auto;
        }

        @media (min-width: 768px) {
            .game-container {
                max-width: 900px;
                padding: 20px;
                gap: 15px;
            }
        }

        .game-container::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 1px;
            background: linear-gradient(to right, 
                                transparent, 
                                rgba(255, 204, 0, 0.5), 
                                transparent);
            opacity: 0.7;
        }

        /* Stats Container */
        .stats-container {
            display: flex;
            justify-content: space-around;
            background-color: var(--ui-dark);
            padding: 8px 10px;
            border-radius: 10px;
            font-size: 12px;
            border: 1px solid var(--ui-light);
            flex-wrap: wrap;
            gap: 8px;
            box-shadow: inset 0 0 15px rgba(0, 0, 0, 0.2);
        }

        @media (min-width: 768px) {
            .stats-container {
                padding: 10px 15px;
                font-size: 13px;
                gap: 12px;
            }
        }

        .stats-column {
            display: flex;
            flex-direction: column;
            gap: 4px;
            align-items: center;
            position: relative;
            flex: 1;
            min-width: 45%;
        }

        @media (min-width: 768px) {
            .stats-column {
                min-width: auto;
            }
        }

        .stats-column::after {
            content: '';
            position: absolute;
            bottom: -8px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 2px;
            background: var(--primary-color);
            transition: width var(--anim-medium) ease;
        }

        .stats-column:hover::after {
            width: 100%;
        }

        /* Battle Area */
        .battle-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            position: relative;
        }

        @media (min-width: 768px) {
            .battle-area {
                flex-direction: row;
                justify-content: space-between;
                align-items: flex-start;
                gap: 25px;
                margin: 20px 0;
            }
        }

        /* Add a decorative line between player and enemy */
        .battle-area::before {
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background: linear-gradient(to right, 
                                    transparent, 
                                    rgba(255, 255, 255, 0.3), 
                                    transparent);
            opacity: 0.5;
        }

        @media (max-width: 767px) {
            .battle-area::before {
                top: 50%;
                transform: translateY(-50%);
            }
        }

        @media (min-width: 768px) {
            .battle-area::before {
                top: 50%;
                transform: translateY(-50%);
            }
        }

        /* Player Display */
        .player-display {
            flex: 1;
            background: linear-gradient(to bottom, 
                                    rgba(37, 58, 41, 0.9), 
                                    rgba(37, 58, 41, 0.7));
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid var(--player-color);
            box-shadow: 0 0 15px rgba(80, 224, 80, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            transition: all var(--anim-medium) ease;
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .player-display {
                padding: 18px;
                min-width: 220px;
                width: auto;
            }
        }

        .player-display::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                                    rgba(80, 224, 80, 0.1), 
                                    transparent 70%);
            opacity: 0.7;
            pointer-events: none;
        }

        .player-display:hover {
            box-shadow: 0 0 20px rgba(80, 224, 80, 0.5);
            transform: translateY(-3px);
        }

        .player-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--player-color);
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(80, 224, 80, 0.5);
        }

        @media (min-width: 768px) {
            .player-name {
                font-size: 22px;
                margin-bottom: 10px;
            }
        }

        .player-gold {
            font-size: 14px;
            margin-bottom: 8px;
            color: gold;
            font-weight: bold;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
            display: flex;
            align-items: center;
            gap: 5px;
        }

        @media (min-width: 768px) {
            .player-gold {
                font-size: 15px;
                margin-bottom: 10px;
            }
        }

        #petContainer {
            position: absolute;
            left: 60px;
            top: 90px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            z-index: 20;
        }

        @media (max-width: 767px) {
            #petContainer {
                left: 10px;
                top: 70px;
            }
        }

        .pet-tooltip-wrapper {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .pet-image {
            width: 60px;
            height: 60px;
            background-color: rgba(0, 0, 0, 0.2);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border: 3px solid var(--player-color);
            border-radius: var(--border-radius);
            image-rendering: pixelated;
            transition: all var(--anim-medium) ease;
            box-shadow: 0 0 15px rgba(80, 224, 80, 0.2);
            position: relative;
            pointer-events: auto;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .pet-image {
                width: 70px;
                height: 70px;
            }
        }

        .pet-image.wobble {
            animation: petWobble 0.4s ease-in-out;
        }

        .pet-tooltip {
            display: none;
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
        }

        .pet-tooltip-wrapper:hover .pet-tooltip {
            display: block;
        }

        @keyframes petWobble {
          0%   { transform: translateY(0px); }
          25%  { transform: translateY(-4px); }
          50%  { transform: translateY(4px); }
          75%  { transform: translateY(-4px); }
          100% { transform: translateY(0px); }
        }

        .player-image {
            width: 90px;
            height: 90px;
            background-color: rgba(0, 0, 0, 0.2);
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            border: 3px solid var(--player-color);
            border-radius: var(--border-radius);
            image-rendering: pixelated;
            margin-bottom: 10px;
            transition: all var(--anim-medium) ease;
            box-shadow: 0 0 15px rgba(80, 224, 80, 0.2);
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .player-image {
                width: 110px;
                height: 110px;
                margin-bottom: 12px;
            }
        }

        .player-image::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(
                to right,
                transparent,
                rgba(255, 255, 255, 0.2),
                transparent
            );
            transform: skewX(-25deg);
            animation: shimmer 5s infinite;
        }

        @keyframes shimmer {
            0% { left: -100%; }
            50% { left: 150%; }
            100% { left: 150%; }
        }

        .player-image.is-active {
            animation: playerPulse 3s ease-in-out infinite, gentleBob 4s ease-in-out infinite;
        }

        @keyframes playerPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(80, 224, 80, 0.2); }
            50% { box-shadow: 0 0 25px rgba(80, 224, 80, 0.6); }
        }

        .player-stats {
            width: 100%;
            text-align: left;
            padding: 0 5px;
        }

        @media (min-width: 768px) {
            .player-stats {
                width: 92%;
                padding: 0;
            }
        }

        /* Enemy Container */
        .enemy-container {
            flex: 1;
            background: linear-gradient(to bottom, 
                                    rgba(58, 37, 37, 0.9), 
                                    rgba(58, 37, 37, 0.7));
            padding: 15px;
            border-radius: var(--border-radius);
            border: 1px solid var(--accent-color);
            box-shadow: 0 0 15px rgba(255, 82, 82, 0.3);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 100%;
            position: relative;
            transition: all var(--anim-medium) ease;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .enemy-container {
                padding: 18px;
                min-width: 220px;
                width: auto;
            }
        }

        .enemy-container::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                                    rgba(255, 82, 82, 0.1), 
                                    transparent 70%);
            opacity: 0.7;
            pointer-events: none;
        }

        .enemy-container:hover {
            box-shadow: 0 0 20px rgba(255, 82, 82, 0.5);
            transform: translateY(-3px);
        }

        .enemy-name {
            font-size: 20px;
            font-weight: bold;
            margin-bottom: 8px;
            color: var(--accent-color);
            letter-spacing: 1px;
            text-shadow: 0 0 5px rgba(255, 82, 82, 0.5);
        }

        @media (min-width: 768px) {
            .enemy-name {
                font-size: 22px;
                margin-bottom: 10px;
            }
        }

        .monster-image {
            width: 90px;
            height: 90px;
            margin-bottom: 10px;
            background-size: contain;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: var(--border-radius);
            border: 3px solid var(--accent-color);
            box-shadow: 0 0 15px rgba(255, 82, 82, 0.2);
            transition: transform var(--anim-medium);
            image-rendering: pixelated;
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .monster-image {
                width: 110px;
                height: 110px;
                margin-bottom: 12px;
            }
        }

        .monster-image::after {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 50%;
            height: 100%;
            background: linear-gradient(
                to right,
                transparent,
                rgba(255, 255, 255, 0.15),
                transparent
            );
            transform: skewX(-25deg);
            animation: shimmer 6s infinite;
        }

        .monster-image:hover {
            transform: scale(1.05) rotate(2deg);
        }

        .monster-image.is-active {
            animation: enemyPulse 3s ease-in-out infinite, gentleEnemyBob 4s ease-in-out infinite;
        }

        @keyframes enemyPulse {
            0%, 100% { box-shadow: 0 0 15px rgba(255, 82, 82, 0.2); }
            50% { box-shadow: 0 0 25px rgba(255, 82, 82, 0.6); }
        }

        @keyframes gentleEnemyBob {
            0%, 100% { transform: translateY(0) rotate(0deg); }
            50% { transform: translateY(-5px) rotate(2deg); }
        }

        .enemy-stats-display {
            width: 100%;
            text-align: left;
            padding: 0 5px;
        }

        @media (min-width: 768px) {
            .enemy-stats-display {
                width: 92%;
                padding: 0;
            }
        }

        .enemy-info {
            margin-top: 10px;
            font-size: 12px;
            color: #eee;
            text-align: center;
            padding: 8px;
            background-color: rgba(0, 0, 0, 0.25);
            border-radius: 8px;
            width: 100%;
            min-height: 30px;
            border: 1px solid rgba(255, 82, 82, 0.2);
        }

        @media (min-width: 768px) {
            .enemy-info {
                margin-top: 12px;
                padding: 10px;
                width: 92%;
            }
        }

        /* Monster Traits */
        .monster-traits {
            display: flex;
            gap: 5px;
            justify-content: center;
            margin-top: 8px;
            flex-wrap: wrap;
            width: 100%;
        }

        @media (min-width: 768px) {
            .monster-traits {
                gap: 6px;
                margin-top: 10px;
            }
        }

        .monster-trait {
            background-color: rgba(60, 60, 60, 0.6);
            border-radius: 10px;
            padding: 3px 6px;
            font-size: 10px;
            color: var(--primary-color);
            border: 1px solid rgba(255, 204, 0, 0.3);
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
            position: relative;
            cursor: help;
            transition: all var(--anim-fast) ease;
        }

        @media (min-width: 768px) {
            .monster-trait {
                padding: 4px 9px;
                font-size: 11px;
            }
        }

        .monster-trait:hover, 
        .monster-trait:active,
        .monster-trait:focus,
        .monster-trait.trait-tooltip-visible {
            background-color: rgba(80, 80, 80, 0.7);
            border-color: var(--primary-color);
            transform: translateY(-2px);
        }

        .monster-trait[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 130%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 8px 10px;
            border-radius: 6px;
            white-space: normal;
            text-align: center;
            font-size: 11px;
            width: max-content;
            max-width: 200px;
            z-index: 1000;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.1);
            animation: tooltipFadeIn var(--anim-fast) ease-out;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            visibility: hidden; /* Standardmäßig ausblenden */
        }

        .monster-trait:hover::after,
        .monster-trait.trait-tooltip-visible::after {
            opacity: 1;
            visibility: visible;
        }

        .monster-trait:hover::before,
        .monster-trait.trait-tooltip-visible::before {
            content: "";
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 6px;
            border-style: solid;
            border-color: rgba(0, 0, 0, 0.9) transparent transparent transparent;
            z-index: 1001;
            animation: tooltipFadeIn var(--anim-fast) ease-out;
            visibility: visible;
        }

        @keyframes tooltipFadeIn {
            from { opacity: 0; transform: translateX(-50%) translateY(10px); }
            to { opacity: 1; transform: translateX(-50%) translateY(0); }
        }

        /* Health & Mana Bars */
        .health-bar, .mana-bar {
            height: 18px;
            background-color: rgba(50, 50, 60, 0.8);
            border-radius: 10px;
            margin: 6px 0;
            overflow: hidden;
            width: 100%;
            border: 1px solid rgba(0, 0, 0, 0.3);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
            position: relative;
        }

        @media (min-width: 768px) {
            .health-bar, .mana-bar {
                height: 20px;
            }
        }

        .health-fill, .mana-fill {
            height: 100%;
            transition: width 0.6s cubic-bezier(0.22, 1, 0.36, 1);
            position: relative;
            overflow: hidden;
        }

        .health-fill::before, .mana-fill::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 50%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0));
            border-radius: 10px 10px 0 0;
        }

        /* Dynamic glow effect on health change */
        @keyframes healthChange {
            0% { box-shadow: 0 0 12px rgba(255, 200, 0, 0.7); }
            100% { box-shadow: 0 0 0 rgba(255, 200, 0, 0); }
        }

        .health-bar.changed {
            animation: healthChange 1s ease-out;
        }

        #playerHealthBar .health-fill {
            background: linear-gradient(to right, #3e9c35, var(--player-color));
            box-shadow: 0 0 8px rgba(80, 224, 80, 0.5);
        }

        #enemyHealthBar .health-fill {
            background: linear-gradient(to right, #c92a2a, var(--accent-color));
            box-shadow: 0 0 8px rgba(255, 82, 82, 0.5);
        }

        .mana-fill {
            background: linear-gradient(to right, #1a73e8, var(--secondary-color));
            box-shadow: 0 0 8px rgba(74, 144, 255, 0.5);
        }

        /* Animate bar text */
        @keyframes valueChangeUp {
            0% { transform: translateY(0); opacity: 1; }
            50% { transform: translateY(-20px); opacity: 0; }
            51% { transform: translateY(20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        @keyframes valueChangeDown {
            0% { transform: translateY(0); opacity: 1; }
            50% { transform: translateY(20px); opacity: 0; }
            51% { transform: translateY(-20px); opacity: 0; }
            100% { transform: translateY(0); opacity: 1; }
        }

        .stat-text {
            font-size: 12px;
            margin-top: 5px;
            transition: all var(--anim-medium) ease;
        }

        @media (min-width: 768px) {
            .stat-text {
                font-size: 13px;
                margin-top: 6px;
            }
        }

        .stat-text.changed-up {
            animation: valueChangeUp 0.6s ease-out;
        }

        .stat-text.changed-down {
            animation: valueChangeDown 0.6s ease-out;
        }

        /* Enemy Minions */
        .enemy-minions {
            display: flex;
            gap: 6px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 10px;
            width: 100%;
        }

        @media (min-width: 768px) {
            .enemy-minions {
                gap: 10px;
                margin-bottom: 12px;
            }
        }

        .minion-box {
            background: linear-gradient(to bottom, #3d3d3d, #2d2d2d);
            border: 1px solid #666;
            border-radius: 8px;
            padding: 6px;
            text-align: center;
            width: 55px;
            font-size: 10px;
            color: white;
            transition: all var(--anim-fast) ease;
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.2);
            position: relative;
            overflow: hidden;
        }

        @media (min-width: 768px) {
            .minion-box {
                padding: 8px;
                width: 65px;
                font-size: 11px;
            }
        }

        .minion-box:hover,
        .minion-box:active {
            transform: translateY(-3px) scale(1.05);
            border-color: var(--accent-color);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.3);
        }

        .minion-box::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: radial-gradient(ellipse at center, rgba(255, 255, 255, 0.2), transparent 70%);
            opacity: 0;
            transition: opacity var(--anim-fast) ease;
            pointer-events: none;
        }

        .minion-box:hover::after,
        .minion-box:active::after {
            opacity: 1;
        }

        .minion-image {
            width: 35px;
            height: 35px;
            margin: 0 auto 3px;
            background-size: contain;
            background-repeat: no-repeat;
            background-position: center;
            image-rendering: pixelated;
            transition: transform var(--anim-fast) ease;
        }

        @media (min-width: 768px) {
            .minion-image {
                width: 40px;
                height: 40px;
                margin: 0 auto 5px;
            }
        }

        .minion-box:hover .minion-image,
        .minion-box:active .minion-image {
            transform: scale(1.1) rotate(5deg);
        }
            
        /* Hand Cards Area */
        .card-hand-container {
            margin-bottom: 15px;
            position: relative;
        }

        @media (min-width: 768px) {
            .card-hand-container {
                margin-bottom: 20px;
            }
        }

        .card-hand {
            display: flex;
            justify-content: center;
            gap: 8px;
            flex-wrap: wrap;
            min-height: 180px;
            padding: 10px 0;
            background-color: rgba(0, 0, 0, 0.15);
            border-radius: var(--border-radius);
            border: 1px dashed rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: visible;
            perspective: 1000px;
        }

        @media (min-width: 768px) {
            .card-hand {
                gap: 12px;
                min-height: 250px;
                padding: 15px 0;
            }
        }

        .card-hand::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, 
                                       rgba(255, 204, 0, 0.05), 
                                       transparent 70%);
            pointer-events: none;
        }

        /* Card Hand Toolbar */
        .card-hand-toolbar {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: -6px;
            position: relative;
            z-index: 2;
            flex-wrap: wrap;
        }

        @media (min-width: 768px) {
            .card-hand-toolbar {
                gap: 12px;
                margin-bottom: -8px;
                flex-wrap: nowrap;
            }
        }

        .card-hand-action-wrapper {
            display: flex;
            justify-content: center;
            gap: 15px;
            align-items: flex-start;
            margin-top: 10px;
        }

        @media (min-width: 768px) {
            .card-hand-action-wrapper {
                gap: 25px;
                margin-top: 15px;
            }
        }

        /* Card Styling */
        .card {
            width: var(--card-width);
            height: var(--card-height);
            background: linear-gradient(135deg, #383850, var(--card-bg));
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            padding: 10px;
            cursor: pointer;
            position: relative;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 3px 6px 12px rgba(0, 0, 0, 0.4), inset 0 0 8px rgba(255, 255, 255, 0.05);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), 
                        box-shadow 0.3s ease, 
                        border-color 0.3s ease,
                        opacity 0.3s ease;
            transform-origin: center bottom;
            overflow: hidden;
            z-index: 1;
        }

        @media (min-width: 768px) {
            .card {
                border-radius: 15px;
                padding: 12px;
            }
        }

        /* Card inner glow effect */
        .card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, 
                                      rgba(255, 255, 255, 0.1) 0%, 
                                      rgba(255, 255, 255, 0) 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Card hover highlight effect */
        .card::after {
            content: '';
            position: absolute;
            top: -150%;
            left: -150%;
            width: 400%;
            height: 400%;
            background: radial-gradient(ellipse at center, 
                                      rgba(255, 204, 0, 0.4), transparent 70%);
            opacity: 0;
            transition: opacity var(--anim-medium) ease;
            pointer-events: none;
            z-index: -1;
        }

        /* Mobile-Touch optimierter Hover-Effekt */
        @media (hover: hover) {
            /* Nur auf Geräten mit echter Hover-Unterstützung */
            .card:hover {
                transform: translateY(-20px) scale(1.08);
                box-shadow: 0 15px 25px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.15);
                border-color: var(--primary-color);
                z-index: 10;
            }

            .card:hover::after {
                opacity: 0.2;
            }
            
            /* Card position adjustment for fan effect (nur Desktop) */
            .card-hand .card:nth-child(odd) {
                transform: rotate(-1deg);
            }

            .card-hand .card:nth-child(even) {
                transform: rotate(1deg);
            }

            .card-hand .card:hover {
                transform: translateY(-20px) scale(1.08) rotate(0deg);
            }
        }

        /* Touch-Geräte-Version für die Karten */
        @media (hover: none) {
            .card-hand .card {
                transform: none; /* Keine Rotation auf Touch-Geräten */
            }
            
            .card:active {
                transform: translateY(-10px) scale(1.05);
                border-color: var(--primary-color);
                z-index: 10;
            }
            
            .card.selected {
                transform: translateY(-15px) scale(1.08);
                box-shadow: 0 15px 25px rgba(0, 0, 0, 0.5), inset 0 0 10px rgba(255, 255, 255, 0.15);
                border-color: var(--primary-color);
                z-index: 10;
            }
            
            .card.selected::after {
                opacity: 0.2;
            }
        }

        .card-mana {
            position: absolute;
            top: 4px;
            right: 4px;
            width: 24px;
            height: 24px;
            background: radial-gradient(circle at center, var(--secondary-color), #2a70df);
            color: white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            border: 2px solid #fff;
            box-shadow: 0 0 8px rgba(74, 144, 255, 0.7);
            z-index: 1;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }

        @media (min-width: 768px) {
            .card-mana {
                top: 6px;
                right: 6px;
                width: 30px;
                height: 30px;
                font-size: 16px;
            }
        }

        .card-name {
            font-weight: bold;
            text-align: center;
            margin-top: 18px;
            margin-bottom: 6px;
            color: var(--primary-color);
            font-size: 13px;
            letter-spacing: 0.5px;
            text-shadow: 0 0 5px rgba(255, 204, 0, 0.5);
        }

        @media (min-width: 768px) {
            .card-name {
                margin-top: 22px;
                margin-bottom: 8px;
                font-size: 15px;
            }
        }

        .card-icon {
            font-size: 30px;
            text-align: center;
            margin: 8px 0;
            flex-shrink: 0;
            height: 35px;
        }

        @media (min-width: 768px) {
            .card-icon {
                font-size: 38px;
                margin: 10px 0;
                height: 45px;
            }
        }

        .card-icon-image {
            width: 35px;
            height: 35px;
            image-rendering: pixelated;
            display: block;
            margin: 0 auto;
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.5));
            transition: transform var(--anim-fast) ease;
        }

        @media (min-width: 768px) {
            .card-icon-image {
                width: 45px;
                height: 45px;
            }
        }

        @media (hover: hover) {
            .card:hover .card-icon-image {
                transform: scale(1.1) rotate(5deg);
                filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.7));
            }
        }

        @media (hover: none) {
            .card:active .card-icon-image, 
            .card.selected .card-icon-image {
                transform: scale(1.1) rotate(5deg);
                filter: drop-shadow(0 3px 5px rgba(0, 0, 0, 0.7));
            }
        }

        .card-description {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(44, 48, 58, 0.75);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            color: var(--text-color);
            padding: 10px;
            font-size: 0.7em;
            line-height: 1.4;
            text-align: center;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.7);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 0 0 10px 10px;
            opacity: 0;
            transform: translateY(20px);
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s linear 0.25s;
            z-index: 2;
        }

        @media (min-width: 768px) {
            .card-description {
                padding: 12px;
                font-size: 0.8em;
            }
        }

        @media (hover: hover) {
            .card:hover .card-description {
                opacity: 1;
                transform: translateY(0);
                visibility: visible;
                pointer-events: auto;
                transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s linear 0s;
            }
        }

        @media (hover: none) {
            .card.selected .card-description {
                opacity: 1;
                transform: translateY(0);
                visibility: visible;
                pointer-events: auto;
                transition: opacity 0.25s ease-out, transform 0.25s ease-out, visibility 0s linear 0s;
            }
        }

        .card-power {
           text-align: center;
           font-size: 1.2em;
           font-weight: bold;
           margin-top: auto;
           margin-bottom: 8px;
           color: var(--text-color);
           padding: 3px 5px;
           background-color: rgba(0,0,0,0.3);
           border-radius: 6px;
           visibility: visible;
           align-self: center;
           min-width: 25px;
        }

        @media (min-width: 768px) {
            .card-power {
                font-size: 1.4em;
                margin-bottom: 10px;
                padding: 4px 6px;
                min-width: 30px;
            }
        }

         /* Farben für Power basierend auf Kartentyp */
        .card[data-card-type="attack"] .card-power { color: var(--accent-color-lighter); }
        .card[data-card-type="block"] .card-power { color: #80deea; }
        .card[data-card-type="heal"] .card-power { color: var(--player-color-lighter); }
    
        .card-power.hidden-power {
            visibility: hidden;
        }
        .card.disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #444;
            background: linear-gradient(145deg, #555, #3a3a3a);
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(0,0,0,0.4);
            filter: grayscale(80%);
            transform-style: flat;
        }

        .card.disabled:hover, 
        .card.disabled:active {
            transform: none;
            box-shadow: 1px 1px 3px rgba(0, 0, 0, 0.3), inset 0 0 10px rgba(0,0,0,0.4);
            border-color: #444;
        }

        .card.disabled::before {
            opacity: 0;
        }

        /* --- Action Buttons --- */
        .action-buttons-vertical {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            padding-top: 15px;
        }

        @media (min-width: 768px) {
            .action-buttons-vertical {
                gap: 12px;
                padding-top: 20px;
            }
        }
    
        button {
            background: linear-gradient(to bottom, var(--primary-color), #d4a106);
            color: #333;
            border: none;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 0.9em;
            font-family: 'Poppins', sans-serif;
            transition: all 0.2s ease-out;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), inset 0 -2px 2px rgba(0,0,0,0.2);
            text-shadow: 0 1px 1px rgba(255, 255, 255, 0.2);
            min-height: 44px; /* Mindesthöhe für mobile Geräte */
            min-width: 44px; /* Mindestbreite für mobile Geräte */
        }

        @media (min-width: 768px) {
            button {
                padding: 12px 25px;
                font-size: 1em;
            }
        }

        @media (hover: hover) {
            button:hover:not(:disabled) {
                background: linear-gradient(to bottom, #ffce3a, var(--primary-color));
                transform: translateY(-2px);
                box-shadow: 0 6px 12px rgba(0,0,0,0.4), inset 0 -1px 1px rgba(0,0,0,0.1), 0 0 10px var(--glow-primary);
            }
        }
        
        button:active:not(:disabled) {
            transform: translateY(1px);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), 0 1px 2px rgba(0,0,0,0.3);
            filter: brightness(0.95);
        }
        
        button:disabled {
            background: linear-gradient(to bottom, #777, #555);
            color: #aaa;
            cursor: not-allowed;
            transform: none;
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.4);
            text-shadow: none;
            filter: grayscale(50%);
        }
    
        /* Spezielle Button-Farben */
        #manaBoostBtn {
            background: linear-gradient(to bottom, #90aaff, #6b8fff);
            color: #fff;
            text-shadow: 0 1px 1px rgba(0, 0, 0, 0.3);
            width: 100%;
            margin: 0 auto;
            max-width: 280px;
        }

        @media (min-width: 768px) {
            #manaBoostBtn {
                width: auto;
                max-width: none;
            }
        }

        @media (hover: hover) {
            #manaBoostBtn:hover:not(:disabled) {
                background: linear-gradient(to bottom, #4a79d9, #365fc4);
                box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4),
                            inset 0 -1px 1px rgba(0, 0, 0, 0.1),
                            0 0 10px rgba(41, 121, 255, 0.5);
            }
        }
        
        #manaBoostBtn:disabled {
            background: linear-gradient(to bottom, #6a7081, #454a59) !important;
            color: #999 !important;
            cursor: not-allowed;
            filter: grayscale(70%);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.4) !important;
        }

        #endTurnBtn {
            width: 100%;
            margin: 0 auto;
            max-width: 280px;
        }

        @media (min-width: 768px) {
            #endTurnBtn {
                width: auto;
                max-width: none;
            }
        }
    
        /* --- Message Log --- */
        .message-log {
            height: 110px;
            background-color: rgba(0,0,0,0.25);
            border-radius: 8px;
            padding: 10px 12px;
            overflow-y: auto;
            margin-top: 15px;
            font-size: 0.75em;
            line-height: 1.5;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 1px 4px rgba(0,0,0,0.4);
            color: var(--text-color-secondary);
        }

        @media (min-width: 768px) {
            .message-log {
                height: 130px;
                padding: 12px 15px;
                margin-top: 20px;
                font-size: 0.8em;
            }
        }

        /* Scrollbar-Styling (Webkit-Browser) */
        .message-log::-webkit-scrollbar { width: 6px; }
        .message-log::-webkit-scrollbar-track { background: rgba(0,0,0,0.1); border-radius: 4px; }
        .message-log::-webkit-scrollbar-thumb { background-color: var(--border-color-light); border-radius: 4px; border: 2px solid transparent; background-clip: content-box; }
        .message-log::-webkit-scrollbar-thumb:hover { background-color: var(--primary-color); }

        @media (min-width: 768px) {
            .message-log::-webkit-scrollbar { width: 8px; }
        }
    
        .message { margin-bottom: 5px; }
        /* Nachrichtentypen hervorheben */
        .message.player { color: var(--secondary-color-lighter); }
        .message.enemy { color: var(--accent-color-lighter); }
        .message.system { color: var(--primary-color); font-weight: 600; }
        .message.xp { color: #a5d6a7; }
        .message.mana { color: #b39ddb; }
        .message.lifesteal { color: #ffcc80; }
        .message.discard { color: #9e9e9e; font-style: italic; }
        .message.block { color: #80deea; }
        .message.heal { color: #c5e1a5; }
        .message.poison { color: #ce93d8; }
    
        /* --- Overlays (Upgrade, Game Over) --- */
        .overlay-container {
            display: none;
        }
        
        .overlay-container.visible {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .overlay-box {
            background-color: var(--card-bg);
            padding: 20px 25px;
            border-radius: 15px;
            border: 1px solid var(--border-color-light);
            text-align: center;
            max-width: 90%;
            width: 90%;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7);
            position: relative;
            transform: scale(0.95);
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
        }

        @media (min-width: 768px) {
            .overlay-box {
                padding: 30px 40px;
                max-width: 700px;
            }
        }
        
        .overlay-container.visible .overlay-box {
            transform: scale(1);
        }
        
        /* Schließen-Button für Overlays */
        .close-overlay-btn {
            position: absolute;
            top: 10px; right: 10px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid var(--border-color);
            color: var(--text-color-secondary);
            border-radius: 50%;
            width: 30px; height: 30px;
            font-size: 1.2em;
            line-height: 28px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s ease;
            z-index: 101;
        }
        
        .close-overlay-btn:hover,
        .close-overlay-btn:active {
            background: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
            transform: rotate(90deg);
        }
    
        /* --- Upgrade Screen --- */
        .upgrade-container {
            display: flex;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            z-index: 100;
            justify-content: center;
            align-items: center;
            padding: 15px;
        }
        
        .upgrade-box {
            border-color: var(--primary-color);
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7), 0 0 20px var(--glow-primary);
            max-width: 90%;
            overflow-y: auto;
            max-height: 90vh;
        }

        @media (min-width: 768px) {
            .upgrade-box {
                max-width: 700px;
            }
        }
        
        .upgrade-title {
            margin-bottom: 20px;
            color: var(--primary-color);
            font-size: 1.5em;
        }

        @media (min-width: 768px) {
            .upgrade-title {
                margin-bottom: 25px;
                font-size: 1.8em;
            }
        }
        
        .upgrade-options {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }

        @media (min-width: 768px) {
            .upgrade-options {
                gap: 20px;
            }
        }
        
        .upgrade-option {
            background-color: #3a3f4c;
            padding: 15px;
            border-radius: 10px;
            border: 2px solid var(--border-color);
            cursor: pointer;
            transition: transform 0.2s ease, background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            width: 140px;
            min-height: 100px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            text-align: left;
            box-shadow: 0 3px 6px rgba(0,0,0,0.3);
        }

        @media (min-width: 768px) {
            .upgrade-option {
                padding: 20px;
                width: 180px;
                min-height: 120px;
            }
        }
        
        .upgrade-option h3 {
            margin: 0 0 8px 0;
            font-size: 1em;
            color: var(--primary-color);
        }

        @media (min-width: 768px) {
            .upgrade-option h3 {
                margin: 0 0 10px 0;
                font-size: 1.1em;
            }
        }
        
        .upgrade-option p {
            margin: 0;
            font-size: 0.8em;
            color: var(--text-color-secondary);
            line-height: 1.4;
        }

        @media (min-width: 768px) {
            .upgrade-option p {
                font-size: 0.85em;
            }
        }
        
        .upgrade-option:hover,
        .upgrade-option:active {
            transform: translateY(-5px) scale(1.03);
            background-color: #454a59;
            border-color: var(--primary-color);
            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 10px var(--glow-primary);
        }
        
        /* Upgrade Raritäten */
        .upgrade-option.rare {
            border-color: var(--rare-color);
            box-shadow: 0 3px 6px rgba(0,0,0,0.3), 0 0 10px var(--glow-rare);
        }
        
        .upgrade-option.rare h3 { color: var(--rare-color); }
        
        .upgrade-option.rare:hover,
        .upgrade-option.rare:active {
            border-color: var(--rare-color);
            background-color: #503a5a;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4), 0 0 15px var(--glow-rare);
        }

        /* --- Shop Screen --- */
        #shopScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 9999;
        }
        
        #shopScreen.visible {
            display: flex !important;
            opacity: 1;
            pointer-events: auto;
            visibility: visible;
        }

        .shop-box {
            border-color: gold;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.7), 0 0 20px gold;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            padding: 20px;
            width: 90%;
        }

        @media (min-width: 768px) {
            .shop-box {
                max-width: 500px;
                padding: 25px;
            }
        }
        
        /* Scrollbar für Shop (Webkit) */
        .shop-box::-webkit-scrollbar { width: 6px; }
        .shop-box::-webkit-scrollbar-track { background: rgba(0,0,0,0.2); border-radius: 5px; }
        .shop-box::-webkit-scrollbar-thumb { background-color: var(--border-color-light); border-radius: 5px; border: 2px solid transparent; background-clip: content-box; }
        .shop-box::-webkit-scrollbar-thumb:hover { background-color: var(--primary-color); }

        @media (min-width: 768px) {
            .shop-box::-webkit-scrollbar { width: 10px; }
        }
    
        #shopTitle {
            color: gold;
            font-size: 1.8em;
            margin-bottom: 15px;
            text-shadow: 0 0 6px gold;
        }

        @media (min-width: 768px) {
            #shopTitle {
                font-size: 2em;
                margin-bottom: 20px;
            }
        }
        
        #shopItems {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 12px;
        }

        @media (min-width: 768px) {
            #shopItems {
                grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
                gap: 16px;
            }
        }
        
        .shop-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #444;
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 2px solid var(--border-color);
            gap: 8px;
            position: relative;
            text-align: center;
            box-shadow: 0 3px 7px rgba(0,0,0,0.4);
        }

        @media (min-width: 768px) {
            .shop-item {
                padding: 15px;
                gap: 10px;
            }
        }
        
        .shop-item:hover,
        .shop-item:active {
            background-color: #555;
            border-color: gold;
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0,0,0,0.5), 0 0 10px gold;
        }
        
        .shop-item.purchased {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #666;
            filter: grayscale(80%);
        }
        
        .shop-item.purchased:hover,
        .shop-item.purchased:active {
            background-color: #444;
            transform: none;
            box-shadow: 0 3px 7px rgba(0,0,0,0.4);
        }
        
        .shop-image {
            width: 70px;
            height: 70px;
            image-rendering: pixelated;
            border: 2px solid #aaa;
            border-radius: 8px;
            margin-bottom: 8px;
        }

        @media (min-width: 768px) {
            .shop-image {
                width: 80px;
                height: 80px;
                margin-bottom: 10px;
            }
        }
        
        .shop-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
        }

        @media (min-width: 768px) {
            .shop-info {
                gap: 5px;
            }
        }
        
        .shop-item-name {
            font-weight: 600;
            font-size: 1em;
            color: var(--text-color);
        }

        @media (min-width: 768px) {
            .shop-item-name {
                font-size: 1.1em;
            }
        }
        
        .shop-item-desc {
            font-size: 0.75em;
            color: var(--text-color-secondary);
            min-height: 25px;
        }

        @media (min-width: 768px) {
            .shop-item-desc {
                font-size: 0.8em;
                min-height: 30px;
            }
        }
        
        .shop-price {
            font-size: 1.1em;
            color: gold;
            margin-top: auto;
            font-weight: bold;
        }

        @media (min-width: 768px) {
            .shop-price {
                font-size: 1.2em;
            }
        }
        
        /* Shop Tooltip */
        .shop-item[data-tooltip]:hover::after,
        .shop-item[data-tooltip]:active::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: calc(100% + 5px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(10, 10, 15, 0.95);
            color: white;
            font-size: 0.8em;
            padding: 6px 10px;
            border-radius: 6px;
            white-space: normal;
            text-align: center;
            z-index: 1001;
            pointer-events: none;
            width: max-content;
            max-width: 200px;
            opacity: 0;
            animation: tooltipFadeIn 0.3s ease forwards;
        }
        
        .shop-footer {
            margin-top: 15px;
            display: flex;
            justify-content: center;
            gap: 15px;
        }

        @media (min-width: 768px) {
            .shop-footer {
                margin-top: 20px;
                gap: 20px;
            }
        }

        #skipShopBtn,
        #closeShopBtn {
            padding: 8px 15px;
            font-size: 0.9em;
            border-radius: 8px;
            border: none;
            background: linear-gradient(to bottom, #888, #666);
            color: white;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        @media (min-width: 768px) {
            #skipShopBtn,
            #closeShopBtn {
                padding: 10px 20px;
                font-size: 1em;
            }
        }

        #skipShopBtn:hover,
        #closeShopBtn:hover,
        #skipShopBtn:active,
        #closeShopBtn:active {
            background: linear-gradient(to bottom, #999, #777);
        }

        #shopContainer {
            display: none;
        }
        
        #shopContainer.visible {
            display: flex !important;
        }

        .shop-icon-wrapper {
            display: inline-block;
            position: relative;
        }

        #shopIconBtn {
            width: 50px;
            height: 50px;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            border: 2px solid rgb(49, 97, 255);
            border-radius: 10px;
            padding: 4px;
            background-color: rgba(0, 0, 0, 0.3);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }

        @media (min-width: 768px) {
            #shopIconBtn {
                width: 60px;
                height: 60px;
            }
        }

        #shopIconBtn:hover,
        #shopIconBtn:active {
            transform: scale(1.15);
            box-shadow: 0 0 15px gold;
        }

        .shop-icon-wrapper::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.2s ease;
            pointer-events: none;
            z-index: 100;
        }

        .shop-icon-wrapper:hover::after,
        .shop-icon-wrapper:active::after {
            opacity: 1;
        }


        /* --- Animationen & Effekte --- */
        .enemy-animation { /* Wird bereits vom enemy-container genutzt */ }
        .enemy-animation.hit {
            animation: strongShake 0.35s ease-out;
            filter: brightness(1.4) saturate(1.6);
        }
        
        .enemy-animation.defeat {
            opacity: 0;
            transform: translateY(-80px) scale(0.6) rotate(-20deg);
            transition: transform 0.6s cubic-bezier(0.68, -0.6, 0.27, 1.6), opacity 0.5s ease-out;
            filter: grayscale(100%) brightness(0.5);
        }
        
        .card-animation { /* Klasse für Karten, die animiert werden */ }
        .card-animation.played {
            transform: translateY(-200px) scale(0.2) rotate(35deg);
            opacity: 0;
            transition: transform 0.5s cubic-bezier(0.4, 0.8, 0.7, 0.2), opacity 0.4s ease-out;
        }
        
        .player-status .status-effect, .item-icon {
            animation: popIn 0.3s ease-out;
        }
    
        @keyframes strongShake {
            0% { transform: translate(0, 0) rotate(0); filter: brightness(1.4) saturate(1.6); }
            15% { transform: translate(-1px, 0) rotate(-0.2deg); }
            30% { transform: translate(1px, 0) rotate(0.2deg); }
            45% { transform: translate(-1px, 0) rotate(-0.2deg); }
            60% { transform: translate(1px, 0) rotate(0.2deg); }
            75% { transform: translate(-1px, 0) rotate(-0.2deg); }
            90% { transform: translate(1px, 0) rotate(0.2deg); }
            100% { transform: translate(0, 0) rotate(0); filter: brightness(1); }
        }
    
        @keyframes gentleBob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-4px); }
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            70% { transform: scale(1.1); opacity: 1; }
            100% { transform: scale(1); }
        }
    
        /* --- Spieler Status Effekte & Items --- */
        .player-status {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
            margin-top: 6px;
            margin-bottom: 8px;
            flex-wrap: wrap;
            font-size: 0.75em;
            color: #fff;
            min-height: 25px;
            width: 100%;
        }

        @media (min-width: 768px) {
            .player-status {
                gap: 8px;
                margin-top: 8px;
                margin-bottom: 10px;
                font-size: 0.8em;
                min-height: 30px;
            }
        }
        
        .player-status .status-effect {
            background-color: rgba(255, 255, 255, 0.1);
            padding: 3px 6px;
            border-radius: 10px;
            border: 1px solid var(--border-color);
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.4);
            display: inline-flex;
            align-items: center;
            gap: 3px;
            position: relative; /* Für Tooltip-Positionierung */
        }

        .status-effect[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            max-width: none;
            word-break: normal;
            overflow-wrap: normal;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
            /* Tooltip NICHT standardmäßig anzeigen */
            visibility: hidden;
        }

        /* Tooltip nur bei Hover/Touch anzeigen */
        .status-effect[data-tooltip]:hover::after,
        .status-effect[data-tooltip].status-effect-tooltip-visible::after {
            opacity: 1;
            visibility: visible;
        }

        .item-icon {
            width: 24px;
            height: 24px;
            image-rendering: pixelated;
            vertical-align: middle;
            border: 2px solid var(--player-color);
            border-radius: 6px;
            box-shadow: 0 0 5px var(--glow-player);
            background-color: rgba(0,0,0,0.3);
            display: inline-block;
        }

        @media (min-width: 768px) {
            .item-icon {
                width: 28px;
                height: 28px;
            }
        }
        
        /* Tooltip-Box */
        .item-icon-wrapper {
            position: relative;
            display: inline-block;
            margin-right: 6px;
        }

        .item-icon-wrapper::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 120%;
            left: 50%;
            transform: translateX(-50%);
            background: #333;
            color: #fff;
            padding: 4px 8px;
            border-radius: 5px;
            white-space: nowrap;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 10;
        }

        .item-icon-wrapper::before {
            content: '';
            position: absolute;
            bottom: 110%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .item-icon-wrapper:hover::after,
        .item-icon-wrapper:hover::before,
        .item-icon-wrapper:active::after,
        .item-icon-wrapper:active::before {
            opacity: 1;
        }

        .upgrade-option.superrare {
            position: relative;
            background: linear-gradient(
                270deg,
                #222,
                #332244,
                #098181,
                #442255,
                #223344,
                #222
            );
            background-size: 800% 800%;
            animation: darkRainbow 12s ease infinite;

            border: 2px solid #ffeb3b;
            box-shadow:
                0 0 10px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.4),
                inset 0 0 10px rgba(255, 235, 59, 0.2);
            
            color: #ffeb3b;
            font-weight: bold;
            text-shadow: 0 0 6px #ffeb3b;

            overflow: hidden;
        }

        /* Animation für den Regenbogen-Hintergrund */
        @keyframes darkRainbow {
            0%   { background-position: 0% 50%; }
            50%  { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        
        .card.superrare {
            position: relative;
            background: linear-gradient(
                270deg,
                #222,
                #332244,
                #098181,
                #442255,
                #223344,
                #222
            );
            background-size: 800% 800%;
            animation: darkRainbow 12s ease infinite;

            border: 2px solid #ffeb3b;
            box-shadow:
                0 0 10px #ffeb3b,
                0 0 20px rgba(255, 235, 59, 0.4),
                inset 0 0 10px rgba(255, 235, 59, 0.2);

            color: #ffeb3b;
            font-weight: bold;
            text-shadow: 0 0 6px #ffeb3b;
            overflow: hidden;
        }
        
        .status-effect[data-tooltip] {
            position: relative;
            cursor: help;
            display: inline-block;
        }

        .status-effect[data-tooltip]::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: #222;
            color: #fff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
            white-space: nowrap;
            max-width: none;
            word-break: normal;
            overflow-wrap: normal;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 1000;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.5);
        }

        .status-effect[data-tooltip]:hover::after,
        .status-effect[data-tooltip]:active::after,
        .status-effect[data-tooltip]:focus::after {
            opacity: 1;
        }
        
        .minion-box.hellhound {
            border: 2px solid crimson;
            box-shadow: 0 0 10px rgba(255, 50, 50, 0.7);
        }

        @keyframes gemPulse {
        0%   { text-shadow: 0 0 0px gold; }
        50%  { text-shadow: 0 0 25px gold, 0 0 40px gold; }
        100% { text-shadow: 0 0 0px gold; }
        }

        @keyframes gemShake {
        0% { transform: translate(-50%, -50%) scale(2) rotate(0deg); }
        25% { transform: translate(-52%, -50%) scale(2) rotate(-3deg); }
        50% { transform: translate(-48%, -50%) scale(2) rotate(3deg); }
        75% { transform: translate(-51%, -50%) scale(2) rotate(-2deg); }
        100% { transform: translate(-50%, -50%) scale(2) rotate(0deg); }
        }

        .card.pulse {
        animation: pulse-scale 0.3s ease;
        }
        @keyframes pulse-scale {
        0%   { transform: scale(1); }
        50%  { transform: scale(1.08); }
        100% { transform: scale(1); }
        }
        .mana-display {
            color: #42a5f5; /* normales Blau */
            transition: color 0.3s ease;
        }

        .mana-display.penalty {
            color: #ef5350; /* rot bei Vision-Effekt */
        }
        .card.vision-penalty {
            border: 2px solid #e53935;
        }
@keyframes lichReviveGlow {
    0% {
        box-shadow: 0 0 0px rgba(0, 255, 255, 0);
        transform: scale(0.6);
        opacity: 0.1;
        filter: brightness(0.6) saturate(0.5);
    }

    30% {
        box-shadow: 0 0 120px rgba(0, 255, 255, 1),
                    0 0 40px rgba(255, 255, 255, 0.9) inset;
        transform: scale(1.4);
        opacity: 1;
        filter: brightness(5.5) saturate(3.5);
    }

    60% {
        box-shadow: 0 0 80px rgba(0, 255, 255, 0.8),
                    0 0 25px rgba(255, 255, 255, 0.6) inset;
        transform: scale(1.2);
        filter: brightness(2.5) saturate(1.8);
    }

    100% {
        box-shadow: 0 0 0px rgba(0, 255, 255, 0);
        transform: scale(1);
        opacity: 1;
        filter: none;
    }
}

.lich-revive-effect {
    animation: lichReviveGlow 10s ease-in-out;
    border-radius: 16px;
    transition: all 10.5s ease;
}

/* Mobile-Optimierungen */
@media (max-width: 767px) {
    /* Eine Tap-to-select Funktionalität für Karten auf Touch-Geräten */
    .js-card-selected {
        transform: translateY(-15px) scale(1.08);
        border-color: var(--primary-color);
        z-index: 10;
    }
    
    /* Bessere Touch-Targets */
    button, 
    .card, 
    .upgrade-option, 
    .shop-item {
        min-height: 44px; /* Mindestgröße für Touch-Targets */
    }
    
    /* Verbesserte Touch-Feedback */
    .card:active,
    .upgrade-option:active,
    .shop-item:active:not(.purchased),
    button:active:not(:disabled) {
        transform: scale(0.98); /* Leichtes Eindrücken beim Tippen */
    }
    
    /* Text besser lesbar auf kleinen Bildschirmen */
    .card-name {
        font-size: 13px;
    }
    
    .card-description {
        font-size: 11px;
        padding: 8px;
    }
    
    /* Verbesserte Scrollbars für Touch */
    .message-log::-webkit-scrollbar,
    .shop-box::-webkit-scrollbar {
        width: 8px; /* Etwas breiter für Touch */
    }
}

.card.physical {
  background: linear-gradient(135deg, #502020, #301010); /* rötlich */
}

.card.special {
  background: linear-gradient(135deg, #203050, #102030); /* bläulich */
}



    </style>
</head>
<body>
    <!-- Firebase SDK -->
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
<script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>

    <h1>Sigma The Game</h1>

    <div id="gameContainer" class="game-container">
        <div class="stats-container">
            <div class="stats-column">
                <div>Runde: <span id="round">1</span></div>
                <div>Besiegt: <span id="defeatedEnemies">0</span></div>
            </div>
            <div class="stats-column">
                <div>Level: <span id="playerLevel">1</span></div>
                <div>XP: <span id="playerXP">0</span> / <span id="xpToNextLevel">100</span></div>
            </div>
            <div class="stats-column">
                 <div>Max Mana: <span id="playerMaxManaDisplay">3</span></div> <div>Handgröße: <span id="maxHandSizeDisplay">5</span></div>
            </div>
             <div class="stats-column">
                 <div>Lebensraub<span id="playerLifestealDisplay">0</span>%</div>
                 <div>Highscore: <span id="highScoreDisplay">0</span></div>
            </div>
        </div>

        <div class="battle-area-wrapper">
            <div class="battle-area">
                <!-- Spieleranzeige -->
                
                <div id="playerDisplay" class="player-display">
                    <!-- Spielername und Goldanzeige -->
                    <div class="player-header">
                        <div class="player-name">Spieler</div>
                        <div class="player-gold">💰 Gold: <span id="playerGoldDisplay">0</span></div>
                    </div>
                
                    <!-- Spielerbild -->
                    <div class="player-image" id="playerImage"></div>
                    <div id="petContainer"></div>
                
                    <!-- Statusanzeige (Effekte & Items) -->
                    <div class="player-status-container">
                        <div class="player-status" id="playerStatusDisplay"></div>
                        <div class="player-items" id="playerItemIcons"></div>
                    </div>
                
                    <!-- Spielerstatistiken -->
                    <div class="player-stats">
                
                        <div class="stat-text">🛡 Block: <span id="playerBlock" class="block-value">0</span></div>
                
                        <div class="stat-text">Leben: <span id="playerHealth">50</span>/<span id="playerMaxHealth">50</span></div>
                        <div class="health-bar" id="playerHealthBar">
                            <div class="health-fill" style="width: 100%;"></div>
                        </div>
                
                        <div class="stat-text">Mana: <span id="playerMana">3</span>/<span id="playerMaxMana">3</span></div>
                        <div class="mana-bar">
                            <div class="mana-fill" id="playerManaBar" style="width: 100%;"></div>
                        </div>
                
                    </div>
                </div>
                
        
                <!-- Gegneranzeige -->
                <div id="enemyContainer" class="enemy-container enemy-animation">
                    <div class="enemy-name" id="enemyName">Gegner</div>
                    <div class="monster-image" id="monsterImage"></div>
                    <div id="enemyMinions" class="enemy-minions"></div>
                    <div class="monster-traits" id="monsterTraits"></div>
        
                    <div class="enemy-stats-display">
                        <div class="stat-text">Leben: <span id="enemyHealth">10</span>/<span id="enemyMaxHealth">10</span></div>
                        <div class="health-bar" id="enemyHealthBar">
                            <div class="health-fill" style="width: 100%;"></div>
                        </div>
        
                        <div class="stat-text">Angriff: <span id="enemyAttack">2</span></div>
                    </div>
        
                    <div class="enemy-info" id="enemyInfo">Infos zum Gegner...</div>
                </div>
            </div>
        </div>
        

        <div class="card-hand-container" style="position: relative;">
            
            <div class="card-hand-toolbar">
                <button id="manaBoostBtn">Mana Boost & Zug beenden</button>
                <button id="endTurnBtn">Zug beenden</button>
              </div>
        
            <h2>Deine Karten (<span id="currentHandSize">0</span>/<span id="maxHandSizeDisplay2">5</span>)</h2>         
        
            <div class="card-hand-action-wrapper">
                <div id="cardHand" class="card-hand"></div>
            </div>
        </div>            

        <div id="messageLog" class="message-log">
            </div>
    </div>

    <div id="upgradeContainer" class="overlay-container upgrade-container">
        <div class="overlay-box upgrade-box">
          <h2 class="upgrade-title">Wähle ein Upgrade!</h2>
          <div class="upgrade-options" id="upgradeOptions">
            <!-- Upgrades werden hier eingefügt -->
          </div>
      
          <!-- Shop-Icon unten zentriert mit Tooltip -->
          <div id="shopIconContainer" style="margin-top: 20px; text-align: center;">
            <div class="shop-icon-wrapper" data-tooltip="Shop öffnen. Falls du ein Item Kaufst schließen sich die Upgrades!">
              <img 
                src="images/shop-chest.png" 
                alt="Shop öffnen" 
                id="shopIconBtn"
              />
            </div>
          </div>
        </div>
      </div>
      
    
<!-- Ändere einfach die ID -->
<div id="shopScreen" style="display: none;">
    <div class="overlay-box shop-box">
      <h3 id="shopTitle">🛒 Shop: Du hast <span id="shopGoldAmount"></span></h3>
      <div id="shopItems" class="shop-items"></div>
      <div class="shop-footer">
        <button id="skipShopBtn">Shop schließen</button>
      </div>
    </div>
  </div>
     
      
        </div>
      </div>
      
    
    <div id="gameOverContainer" class="game-over-container" style="display: none;"> <h2>Game Over!</h2>
        <div class="highscore">Besiegte Gegner: <span id="finalScore">0</span></div>
        <div class="highscore">Höchste Runde: <span id="finalRound">0</span></div>
        <div class="highscore">Endlevel: <span id="finalLevel">0</span></div>
        <button id="restartBtn">Neues Spiel</button>
    </div>

    <script>
        // --- Firebase Initialisierung ---
        const firebaseConfig = {
            apiKey: "AIzaSyCSn9mCvNT6JZgXy5ZTIOeVhri4FQRvn9E",
            authDomain: "sigma-the-game.firebaseapp.com",
            databaseURL: "https://sigma-the-game-default-rtdb.europe-west1.firebasedatabase.app",
            projectId: "sigma-the-game",
            storageBucket: "sigma-the-game.appspot.com",
            messagingSenderId: "346310580482",
            appId: "1:346310580482:web:a7e6f835eb4dd541964a1b"
            };


            firebase.initializeApp(firebaseConfig);
            const db = firebase.firestore();

        // --- Spielkonstanten ---
        const CARD_TYPES = [
            // ... (deine Kartendefinitionen bleiben hier unverändert) ...
                 { id: 1, name: 'Schwert', icon: '⚔️', description: 'Ein einfaches Schwert.', power: 5, effect: 'damage', manaCost: 2, weight: 5, tags: ['sword'], type: 'physical' },
                 { id: 2, name: 'Schild', icon: '🛡️', description: 'Erhalte 5 Block', power: 5, effect: 'block', manaCost: 2, weight: 1 },
                 { id: 3, name: 'Heilung', icon: '❤️', description: 'Heilt 8 Leben', power: 8, effect: 'heal', manaCost: 3, weight: 1 },
                 { id: 4, name: 'Gift', icon: '☠️', description: 'Vergiftung (3 Schaden, 3 Rd.)', power: 3, duration: 3, effect: 'poison', manaCost: 2, weight: 1 },
                 { id: 5, name: 'Blitz', icon: '⚡', description: '12 Schaden, Paralysiert Gegner zu 45% (Halbiert den Angriff 2 Runden)', power: 12, effect: 'damage_paralyze', manaCost: 4, weight: 2, type: 'special' },
                 { id: 6, name: 'Großer Schlag', icon: '💥', description: 'Fügt 15 Schaden zu', power: 15, effect: 'damage', manaCost: 4, weight: 2, type: 'physical' },
                 { id: 7, name: 'Meditieren', icon: '🧘', description: 'Ziehe 1 Karte', power: 1, effect: 'draw', manaCost: 0, weight: 1 },
                 { id: 8, name: 'Vampirbiss', icon: '🧛', description: '8 Schaden, heilt 8', power: 8, healAmount: 8, effect: 'lifesteal', manaCost: 4, weight: 2, type: 'physical' }, // Direkte Heilung statt %
                 { id: 9, name: 'Manatrank', icon: '🧪', description: 'Erhalte 2 Mana', power: 2, effect: 'gain_mana', manaCost: 0, weight: 3 },
                 { id: 10, name: 'Fokus', icon: '🎯', description: 'Ziehe 2 Karten', power: 2, effect: 'draw', manaCost: 1, weight: 1 },
                 { id: 11, name: 'Heilige Macht', icon: '✨', description: 'Fügt 25 Schaden zu', power: 25, effect: 'damage', manaCost: 6, weight: 1, type: 'special' },
                 { id: 12, name: 'Genesung', icon: '💖', description: 'Heilt 15 Leben', power: 15, effect: 'heal', manaCost: 5, weight: 1 },
                 {id: 13, name: 'Feuerball', icon: '🔥', description: 'Fügt 12 Schaden zu. 50% Chance auf Verbrennung (5 Schaden für 2 Runden).', power: 12, effect: 'firearrow', manaCost: 5, weight: 2, type: 'special'},
                 {id: 14, name: 'Gambler’s Luck', icon: '🎲', description: 'Gegner nimmt 5 Schaden und du erhältst 100 Gold (Ignoriert Block) oder Du nimmst 5 Schaden.', power: 5, effect: 'gamble', manaCost: 0, weight: 1, type: 'special'},
                 { id: 15, name: 'Kraft Sammeln', icon: '🔋', description: 'Heilt dich um dein gesamtes Mana.<br><br>Einmaliger Schadensboost i.H.v. Manakosten -1', power: 0, effect: 'power_surge', manaCost: 'X', weight: 1 },
                 {id: 16, name: 'Klingenwirbel', icon: '🌀', description: 'Greift mehrere Gegner gleichzeitig an. (Ignoriert Block.)', power: 8, effect: 'whirlwind', manaCost: 3, weight: 2, type: 'physical'},
                 {id: 17, name: 'Todesklinge', icon: '⚔️', description: 'Die stärkste aller Schwerter. 25 Schaden.', power: 25, effect: 'damage', manaCost: 4, weight: 1, tags: ['sword'], rarity: 'superrare', type: 'physical'},
                 {id: 18, name: 'Mana Oase', icon: '🧪', description: 'Erhalte 5 Mana', power: 5, effect: 'gain_mana', manaCost: 0, weight: 1, rarity: 'superrare'},
                 {id: 19, name: 'Blutrausch', icon: '🧛', description: '20 Schaden, heilt 12', power: 20, healAmount: 12, effect: 'lifesteal', manaCost: 7, weight: 1, rarity: 'superrare', type: 'physical'},
                 {id: 20, name: 'Unwetter', icon: '🌩️', description: 'Paralysiere den Gegner (Halbiert den Angriff 2 Runden)', power: 0, effect: 'paralyze', manaCost: 1, weight: 2 },
                 {id: 21, name: 'Ansturm', icon: '🐗', description: 'Ein Rücksichtsloser Angriff, 15 schaden aber 5 Schaden Rückstoß', power: 15, selfDamage: 5, effect: 'damage_selfhit', manaCost: 3, weight: 1, type: 'physical' },
                 {id: 22, name: 'Tornado', icon: '🌪️', description: 'Kann 2-3x treffen je 5 Schaden. Umgeht Block', power: 5, effect: 'multi_hit', hits: 3, minHits: 2, manaCost: 3, weight: 2, type: 'special' },
                 {id: 23, name: 'The Knive', icon: '🗡️', description: 'Verursacht Blutungen. The Knive doppelten Schaden bei Blutungen', power: 12, effect: 'bleed', manaCost: 4, weight: 3, type: 'physical' },
                 {id: 24, name: 'Biohazard', icon: '☣️', description: 'Verursacht Schwere Vergiftung.(7 Schaden, 3 Rd.)', power: 7, duration: 3, effect: 'poison', manaCost: 4, weight: 1 },
                 { id: 25, name: 'Grande Schild', icon: '🔰', description: 'Erhalte 15 Block', power: 15, effect: 'block', manaCost: 4, weight: 1 },
                 {id: 26, name: 'Rage', icon: '💢', description: 'Kann bis zu 3-5x treffen je 5 Schaden. Umgeht Block', power: 5, effect: 'multi_hit', hits: 5, minHits: 3, manaCost: 5, weight: 2, type: 'physical' },
                 {id: 27, name: 'Slash', icon: '🥏', description: 'Ein schwacher aber effizienter Angriff', power: 2, effect: 'damage', manaCost: 0, weight: 2, type: 'physical' },
                 {id: 28, name: 'Konter', icon: '💫', description: 'Beendet den Zug bis der Gegner dir Schaden zufügt. Kontert mit 120% des erlittenen Angriffs.', effect: 'counter', manaCost: 5, weight: 1 },
                 { id: 29, name: 'Seelenriss', icon: '👻', description: '10 Schaden. Wenn tödlich, heile 20% Max-Leben.', power: 10, effect: 'soul_rip', manaCost: 4, weight: 1, type: 'special' },
                 { id: 30, name: 'Mewing', icon: '🧏', description: 'Du machte nächste Runde keinen schaden, aber dannach doppelten.', power: 0, effect: 'mewing', manaCost: 3, weight: 1, tags: ['buff'] },
                 { id: 31, name: 'Sigma', icon: '🗿', description: 'Falls du in dieser Runde tödlichen Schaden erleidest, überlebst du mit 1 HP.', power: 0, effect: 'sigma', manaCost: 3, weight: 1 },
                 { id: 32, name: 'Anomalie', icon: '🧿', description: 'Verwandelt sich in eine zufällige Karte. Diese bleibt nur für einen einzigen Einsatz.', power: 0, effect: 'anomaly', manaCost: 1, weight: 1 },
                 { id: 33, name: 'Magie', icon: '🔮', description: 'Leichte Magie.', power: 7, effect: 'damage', manaCost: 2, weight: 5, type: 'special' },
                 { id: 34, name: 'Manatrank', icon: '🔵', description: 'Erhalte 2 Mana.', power: 2, effect: 'gain_mana', manaCost: 0, type: 'special', weight: 1, rarity: 'superrare' },
                 { id: 35, name: 'Heiltrank', icon: '🔴', description: 'Heilt 5 Leben.', power: 5, effect: 'heal', manaCost: 0, type: 'special', weight: 1, rarity: 'superrare' },
                 { id: 36, name: 'Schadenstrank', icon: '⚫', description: 'Fügt 5 Schaden zu.', power: 5, effect: 'damage', manaCost: 0, type: 'special', weight: 1, rarity: 'superrare' },
        ];
        
        
        window.cards = CARD_TYPES;
        localStorage.setItem('allCards', JSON.stringify(CARD_TYPES));

        // --- Bildpfade ---
        const IMAGE_FOLDER = 'images/';
        const ENEMY_PIXEL_PLACEHOLDERS = {
            // ... (deine Bildpfade bleiben hier unverändert) ...
                'Goblin': IMAGE_FOLDER + 'Goblin.png',
                'Ork': IMAGE_FOLDER + 'Ork.png',
                'Troll': IMAGE_FOLDER + 'Troll.png',
                'Dämon': IMAGE_FOLDER + 'Demon.png', // Umlaut vermieden
                'Baby Drache': IMAGE_FOLDER + 'BabyDrache.png', // Leerzeichen vermieden
                'Nekromant': IMAGE_FOLDER + 'Nekromant.png', // Umlaut vermieden
                'Riesen Spinne': IMAGE_FOLDER + 'Spinne.png', // Leerzeichen vermieden
                'Eiskönig': IMAGE_FOLDER + 'Eiskönig.png', // Umlaut vermieden
                'Erzengel': IMAGE_FOLDER + 'Erzengel.png',
                'Dracula': IMAGE_FOLDER + 'Drakula.png',
                'Alchemie Kobold': IMAGE_FOLDER + 'alchemiekobold.png',
                'Drache': IMAGE_FOLDER + 'Drache.png',
                'Verfluchter Ritter': IMAGE_FOLDER + 'CursedKnight.png',
                'Gepanzertes Skelett': IMAGE_FOLDER + 'armorskelett.png',
                'Donnerschlange': IMAGE_FOLDER + 'snake.png',
                'Charged Golem': IMAGE_FOLDER + 'golem.png',
                'Gargoyle': IMAGE_FOLDER + 'gargoyle.png',
                'hund': IMAGE_FOLDER + 'hund.png',
                'Teufel': IMAGE_FOLDER + 'teufel.png',
                'Rainbow': IMAGE_FOLDER + 'rainbow.png',
                'Yagdril': IMAGE_FOLDER + 'yagdril.png',
                'Spinnenkönigin': IMAGE_FOLDER + 'spinnenboss.png',
                'Yokai': IMAGE_FOLDER + 'yokai.png',           
                'Wutferkel': IMAGE_FOLDER + 'pig.png',  
                'Bagdos Krieger': IMAGE_FOLDER + 'krieger.png',  
                'Schleim': IMAGE_FOLDER + 'schleim.png',  
                'mini_slime': IMAGE_FOLDER + 'mini_slime.png',  
                'Leecher': IMAGE_FOLDER + 'leecher.png',  
                'Bagdos Magier': IMAGE_FOLDER + 'magier.png',  
                'Bagdos Riese': IMAGE_FOLDER + 'riese.png',  
                'Bagdos Leibgarde': IMAGE_FOLDER + 'leibgarde.png',  
                'Bagdo': IMAGE_FOLDER + 'bagdoboss.png',  
                'Leviathan': IMAGE_FOLDER + 'Leviathan.png',  
                'awakened': IMAGE_FOLDER + 'awakened.png', 
        };

        console.log("selectedSkinRaw:", localStorage.getItem('selectedSkinPath'));

        const selectedSkin = localStorage.getItem('selectedSkinPath');
            // wenn selectedSkin schon ein kompletter Pfad ist (z.B. "images/players/hoodie.png")
            const PLAYER_PIXEL_IMAGE = selectedSkin
            ? selectedSkin
            : `${IMAGE_FOLDER}players/Spieler.png`;


    
        // --- Gegnertypen ---
        const ENEMY_TYPES = [
            // ... (deine Gegnertypen bleiben hier unverändert) ...
                { name: 'Goblin', health: 20, attack: 5, levelMin: 1, levelMax: 4, xp: 35, gold: 60, pixelImageKey: 'Goblin', gemChance: 1, description: 'Ein kleiner, flinker Goblin.', traits: ['Keine Fähigkeit'] },
                { name: 'Schleim', health: 20, attack: 6, levelMin: 1, levelMax: 4, xp: 65, gold: 85, pixelImageKey: 'Schleim', gemChance: 1, description: 'Ein fieser Schleim.', traits: ['Teilung'] },
                { name: 'Gepanzertes Skelett', health: 25, attack: 4, levelMin: 2, levelMax: 6, xp: 55, gold: 75, pixelImageKey: 'Gepanzertes Skelett', gemChance: 2, description: 'Ein ehmaliger stolzer Soldat.', traits: ['Rüstung', 'Defense'] },
                { name: 'Leecher', health: 30, attack: 6, levelMin: 2, levelMax: 6, xp: 55, gold: 75, pixelImageKey: 'Leecher', gemChance: 2, description: 'Blutsüchtiger Mini Dämonen.', traits: ['Vamp'] },
                { name: 'Wutferkel', health: 35, attack: 8, levelMin: 3, levelMax: 6, xp: 65, gold: 80, pixelImageKey: 'Wutferkel', gemChance: 2, description: 'Ein Wildes wütendes Schwein', traits: ['Rücksichtslos'] },
                { name: 'Ork', health: 35, attack: 5, levelMin: 3, levelMax: 7, xp: 60, gold: 65, pixelImageKey: 'Ork', gemChance: 4, description: 'Ein brutaler Ork-Krieger.', traits: ['Stark'] },
                { name: 'Riesen Spinne', health: 40, attack: 6, levelMin: 4, levelMax: 9, xp: 65, gold: 80, pixelImageKey: 'Riesen Spinne', gemChance: 4, description: 'Spuckt lähmendes Gift.', traits: ['Giftig'] }, 
                { name: 'Bagdos Krieger', health: 45, attack: 7, levelMin: 5, levelMax: 9, xp: 68, gold: 85, pixelImageKey: 'Bagdos Krieger', gemChance: 5, description: 'Ein Lakeie Bagods.', traits: ['Krieger'] }, 
                { name: 'Troll', health: 47, attack: 8, levelMin: 5, levelMax: 9, xp: 70, gold: 100, pixelImageKey: 'Troll', gemChance: 5, description: 'Regeneriert 3 Leben pro Runde.', traits: ['Regeneration', 'Massiv'], regen: 3 }, 
                { name: 'Donnerschlange', health: 45, attack: 9, levelMin: 6, levelMax: 10, xp: 120, gold: 105, pixelImageKey: 'Donnerschlange', gemChance: 5, description: 'Eine lähmende Donnerschlange', traits: ['Statisch', 'Special Defense'] },
                { name: 'Bagdos Magier', health: 45, attack: 9, levelMin: 6, levelMax: 11, xp: 120, gold: 105, pixelImageKey: 'Bagdos Magier', gemChance: 5, description: 'Bagdos treuster Magier', traits: ['Feueratem', 'Vision'] },
                { name: 'Nekromant', health: 50, attack: 7, levelMin: 8, levelMax: 12, xp: 80, gold: 120, pixelImageKey: 'Nekromant', gemChance: 6, description: 'Schwächt dich oder ruft Diener.', traits: ['Untotenbeschwörer'] }, // Effekte müssen implementiert werden
                { name: 'Eiskönig', health: 65, attack: 10, levelMin: 9, levelMax: 13, xp: 100, gold: 130, pixelImageKey: 'Eiskönig', gemChance: 6, description: 'Verlangsamt dich mit Kälte.', traits: ['Eis-Elementar', 'Frost-Aura', 'Special Defense'] }, // Effekte müssen implementiert werden
                { name: 'Alchemie Kobold', health: 60, attack: 10, levelMin: 10, levelMax: 15, xp: 110, gold: 140, pixelImageKey: 'Alchemie Kobold', gemChance: 7, description: 'Der Albtraum jeder Medizin (fast jeder).', traits: ['Giftig', 'Antiheal'] }, // Effekte müssen implementiert werden
                { name: 'Baby Drache', health: 65, attack: 13, levelMin: 11, levelMax: 15, xp: 130, gold: 170, pixelImageKey: 'Baby Drache', gemChance: 7, description: 'Speit Feuerstöße.', traits: ['Verspielt', 'Feueratem'] }, // Effekte müssen implementiert werden
                { name: 'Charged Golem', health: 75, attack: 12, levelMin: 12, levelMax: 16, xp: 170, gold: 180, pixelImageKey: 'Charged Golem', gemChance: 7, description: 'Mächtiger Elementar Golem.', traits: ['Statisch', 'Regeneration'], regen: 3 }, // Effekte müssen implementiert werden
                { name: 'Dracula', health: 68, attack: 10, levelMin: 13, levelMax: 17, xp: 190, gold: 190, pixelImageKey: 'Dracula', gemChance: 8, description: 'Dein Blut macht ihn stärker.', traits: ['Vamp', 'Stark'] }, // Effekte müssen implementiert werden
                { name: 'Dämon', health: 85, attack: 13, levelMin: 14, levelMax: 18, xp: 280, gold: 210, pixelImageKey: 'Dämon', gemChance: 9, description: 'Feuer und Schatten. Resistent.', traits: ['Höllen Krallen'] }, // Effekte müssen implementiert werden
                { name: 'Verfluchter Ritter', health: 85, attack: 10, levelMin: 15, levelMax: 19, xp: 360, gold: 250, pixelImageKey: 'Verfluchter Ritter', gemChance: 10, description: 'Ein wandelnde Geisterrüstung', traits: ['Defense', 'Rüstung', 'Krieger']}, // Effekte müssen implementiert werden
                { name: 'Bagdos Riese', health: 120, attack: 12, levelMin: 16, levelMax: 20, xp: 400, gold: 300, pixelImageKey: 'Bagdos Riese', gemChance: 10, description: 'Ein Dummer aber leider auch starker Riese', traits: ['Stark', 'Dämlich'] }, // Effekte müssen implementiert werden
                { name: 'Erzengel', health: 110, attack: 13, levelMin: 16, levelMax: 20, xp: 400, gold: 300, pixelImageKey: 'Erzengel', gemChance: 10, description: 'Ein mächtiger gefallener Engel.', traits: ['Segen', 'Fliegend', 'Defense'] }, // Effekte müssen implementiert werden
                { name: 'Gargoyle', health: 105, attack: 15, levelMin: 17, levelMax: 21, xp: 450, gold: 320, pixelImageKey: 'Gargoyle', gemChance: 11, description: 'Einst da um die Menschen zu beschützen. Jetzt ein unbändiges Monster', traits: ['Gepanzerte Schuppen', 'Tank'] }, 
                { name: 'Drache', health: 130, attack: 16, levelMin: 18, levelMax: 22, xp: 650, gold: 330, pixelImageKey: 'Drache', gemChance: 12, description: 'Ein mächtiger, alter Drache.', traits: ['Feueratem', 'Fliegend', 'Gepanzerte Schuppen'] }, 
                { name: 'Teufel', health: 95, attack: 7, levelMin: 19, levelMax: 24, xp: 750, gold: 380, pixelImageKey: 'Teufel', gemChance: 13, description: 'Der Herrscher der Unterwelt.', traits: ['Höllenwache'] },
                { name: 'Spinnenkönigin', health: 130, attack: 14, levelMin: 20, levelMax: 25, xp: 750, gold: 390, pixelImageKey: 'Spinnenkönigin', gemChance: 14, description: 'Eine Spinne die selbst der Teufel fürchtet.', traits: ['Antiheal', 'Giftig'] },
                { name: 'Rainbow', health: 150, attack: 13, levelMin: 21, levelMax: 26, xp: 900, gold: 400, pixelImageKey: 'Rainbow', gemChance: 16, description: 'Meister über alle Elemente', traits: ['Frost-Aura', 'Giftig', 'Feueratem', 'Statisch'] },
                { name: 'Bagdos Leibgarde', health: 180, attack: 17, levelMin: 21, levelMax: 26, xp: 900, gold: 400, pixelImageKey: 'Bagdos Leibgarde', gemChance: 16, description: 'Lässt seinen Meister nie im stich', traits: ['Rüstung', 'Tank', 'Defense'] },
                { name: 'Yokai', health: 110, attack: 16, levelMin: 22, levelMax: 28, xp: 1100, gold: 450, pixelImageKey: 'Yokai', gemChance: 16, description: 'Ein hochrangiger fliegender Yokai-Demon', traits: ['Fliegend', 'Höllenkrallen','Untotenbeschwörer'] },
                { name: 'Yagdril', health: 150, attack: 28, levelMin: 23, levelMax: 100, xp: 1200, gold: 500, pixelImageKey: 'Yagdril', gemChance: 18, description: 'Ein Wesen dessen Macht unbeschreiblich ist', traits: ['Fliegend', 'YinYang'] },
                { name: 'Leviathan', health: 160, attack: 20, levelMin: 24, levelMax: 100, xp: 1300, gold: 520, pixelImageKey: 'Leviathan', gemChance: 23, description: 'Das Symbol des Schreckens', traits: ['Antiheal', 'Vision', 'Special Defense'] },
                { name: 'Bagdo', health: 220, maxHealth: 200, attack: 30, levelMin: 25, levelMax: 100, xp: 1500, gold: 600, pixelImageKey: 'Bagdo', gemChance: 25, description: 'Der gefallene Lichking', traits: ['Entfesselung', 'Lichking', 'Defense'] },
        ];
    
        // --- Upgrade-Typen ---
        const UPGRADE_TYPES = [
            // ... (deine Upgrade-Typen bleiben hier unverändert) ...
                 { type: 'newCardSpecific', title: 'Neue Karte wählen', description: 'Wähle 1 von 3 neuen Karten.', rarity: 'common' }, // Komplexer zu implementieren
                 { type: 'upgradeSwordPower', title: 'Schwertstärke +1', description: 'Erhöhe die Stärke deiner Schwerter um +1.', rarity: 'common' },
                 { type: 'upgradeHealth', title: 'Max Leben +8', description: 'Erhöhe dein maximales Leben um 8.', rarity: 'common' },
                 { type: 'healPercent', title: 'Heilung 50%', description: 'Stelle 50% deines max. Lebens wieder her.', rarity: 'common' },
                 { type: 'blackMarketGold', title: 'Schwarzmarkt', description: 'Entferne 1 Karte nach Wahl dauerhaft und erhalte dafür ein Gold Angebot', rarity: 'common' },
                 { type: 'upgradeMana', title: 'Max Mana +1', description: 'Erhöhe dein maximales Mana um 1.', rarity: 'rare' }, // Seltener
                 { type: 'swapCard', title: 'Kartentausch', description: 'Lösche eine Karte aus deinem Deck und wähle eine neue.', rarity: 'rare' }, 
                 { type: 'increaseHandSize', title: 'Handgröße +1', description: 'Du kannst 1 Karte mehr halten.', rarity: 'rare' },
                 { type: 'regenManaPassive', title: 'Mana-Regen +1', description: 'Du erhältst pro Runde +1 zusätzliches Mana zurück.', rarity: 'rare' },
                 { type: 'regenManaPassive3', title: 'Mana-Regen +3', description: 'Du erhältst pro Runde +3 zusätzliches Mana zurück.', rarity: 'superrare' },
                 { type: 'newUltraCardSpecific', title: 'Eine Ultra Karte wählen', description: 'Wähle 1 von 3 Ultra Karten.', rarity: 'superrare' }, // Komplexer zu implementieren
                 { type: 'fuseCards', title: '🧬 Kartenfusion',  description: 'Fusioniere zwei Karten aus deinem Deck zu einer neuen.', rarity: 'common'},
        ];
    
        // --- XP & Level Konstanten ---
        const BASE_XP_TO_LEVEL_UP = 50;
        const LEVEL_UP_FACTOR = 1.25;
    
        // --- Spielzustand (state object) ---
        let state = {};
        let cardUniqueCounter = 0; // Für eindeutige Karten-IDs im Spielverlauf
        let cardsPlayedThisTurn = 0;
    
        // --- DOM-Elemente ---
        // (IDs wurden teilweise angepasst für Klarheit)
        const roundElem = document.getElementById('round');
        const defeatedEnemiesElem = document.getElementById('defeatedEnemies');
        const playerHealthElem = document.getElementById('playerHealth');
        const playerMaxHealthElem = document.getElementById('playerMaxHealth');
        const playerHealthBarElem = document.getElementById('playerHealthBar').querySelector('.health-fill');
        const playerManaElem = document.getElementById('playerMana');
        const playerMaxManaElem = document.getElementById('playerMaxMana');
        const playerMaxManaDisplayElem = document.getElementById('playerMaxManaDisplay');
        const playerManaBarElem = document.getElementById('playerManaBar'); // Korrigiert: Direkt das Mana-Fill Element holen
        const playerBlockElem = document.getElementById('playerBlock');
        const playerLevelElem = document.getElementById('playerLevel');
        const playerXPElem = document.getElementById('playerXP');
        const xpToNextLevelElem = document.getElementById('xpToNextLevel');
        const playerLifestealDisplayElem = document.getElementById('playerLifestealDisplay');
        const highScoreDisplayElem = document.getElementById('highScoreDisplay');
    
        const enemyNameElem = document.getElementById('enemyName');
        const enemyHealthElem = document.getElementById('enemyHealth');
        const enemyMaxHealthElem = document.getElementById('enemyMaxHealth');
        const enemyHealthBarElem = document.getElementById('enemyHealthBar').querySelector('.health-fill');
        const enemyAttackElem = document.getElementById('enemyAttack');
        window.enemyContainerElem  = document.getElementById('enemyContainer');
        const monsterImageElem = document.getElementById('monsterImage');
        const playerImageElem = document.getElementById('playerImage');
        const enemyInfoElem = document.getElementById('enemyInfo');
        const monsterTraitsElem = document.getElementById('monsterTraits');
    
        const cardHandElem = document.getElementById('cardHand');
        const currentHandSizeElem = document.getElementById('currentHandSize');
        const maxHandSizeDisplayElem = document.getElementById('maxHandSizeDisplay');
        const maxHandSizeDisplayElem2 = document.getElementById('maxHandSizeDisplay2');
    
        const endTurnBtn = document.getElementById('endTurnBtn');
        const manaBoostBtn = document.getElementById('manaBoostBtn');
        const messageLogElem = document.getElementById('messageLog');
    
        const upgradeContainerElem = document.getElementById('upgradeContainer');
        const upgradeOptionsElem = document.getElementById('upgradeOptions');
        const upgradeTitleElem = upgradeContainerElem.querySelector('.upgrade-title');
    
        const gameOverContainerElem = document.getElementById('gameOverContainer');
        const finalScoreElem = document.getElementById('finalScore');
        const finalRoundElem = document.getElementById('finalRound');
        const finalLevelElem = document.getElementById('finalLevel');
        const restartBtn = document.getElementById('restartBtn');
        const playerDisplay = document.getElementById('playerDisplay');

    
        // --- Event-Listener ---
        endTurnBtn.addEventListener('click', () => endTurn());
        manaBoostBtn.addEventListener('click', manaBoost);
        restartBtn.addEventListener('click', () => {
        window.location.href = 'index.html'; // Weiterleitung ins Hauptmenü
        });
        document.addEventListener('DOMContentLoaded', initGame); // Spiel beim Laden starten
    
        // --- Hilfsfunktionen ---
        function getRandomInt(min, max) {
            min = Math.ceil(min);
            max = Math.floor(max);
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
    
        // Fisher-Yates Shuffle Algorithmus zum Mischen von Arrays
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Tausche Elemente
            }
        }


        //Gem chance
        function handleGemDrop(enemy) {
        const chance = enemy.gemChance || 0;
        const roll = Math.random() * 100;

        if (roll < chance) {
            addGems(1);
            logMessage(`💎 Du hast 1 Edelstein vom ${enemy.name} erhalten!`, 'gem');
            animateGemDrop();
            updateGemDisplay(); 
        }
        }

         //Gems speichern   
         function getGems() {
                return parseInt(localStorage.getItem('gems') || '0', 10);
                }

                function setGems(amount) {
                localStorage.setItem('gems', amount);
                }

                function addGems(amount) {
                const current = getGems();
                setGems(current + amount);
                }

         function updateGemDisplay() {
                const gemElem = document.getElementById('gemDisplay');
                if (gemElem) {
                    gemElem.innerHTML = `💎 <strong>${getGems()}</strong>`;
                }
                }

        const gemDisplay = document.createElement('div');
            gemDisplay.id = 'gemDisplay';
            gemDisplay.innerHTML = `💎 <strong>${getGems()}</strong>`;
            gemDisplay.style = `
            position: fixed;
            top: 15px;
            left: 15px;
            z-index: 999;
            background: rgba(0, 0, 0, 0.5);
            padding: 6px 12px;
            border-radius: 8px;
            font-size: 16px;
            color: gold;
            font-family: 'Orbitron', sans-serif;
            box-shadow: 0 0 8px rgba(255, 206, 0, 0.5);
            `;
            document.body.appendChild(gemDisplay);

            //Gem Animation
        function animateGemDrop() {
            const gem = document.createElement('div');
            gem.textContent = '💎';
            gem.style.position = 'fixed';
            gem.style.left = '50%';
            gem.style.top = '50%';
            gem.style.transform = 'translate(-50%, -50%) scale(2)';
            gem.style.fontSize = '48px';
            gem.style.opacity = '1';
            gem.style.zIndex = 9999;
            gem.style.pointerEvents = 'none';
            gem.style.animation = 'gemPulse 0.4s ease, gemShake 0.6s ease';

            document.body.appendChild(gem);

            const target = document.getElementById('gemDisplay');
            const targetRect = target.getBoundingClientRect();

            // Starte Flug nach kurzer Verzögerung
            setTimeout(() => {
                gem.style.transition = 'all 1.2s ease';
                gem.style.left = `${targetRect.left + targetRect.width / 2}px`;
                gem.style.top = `${targetRect.top + targetRect.height / 2}px`;
                gem.style.transform = 'translate(-50%, -50%) scale(0.5)';
                gem.style.opacity = '0';
            }, 700);

            setTimeout(() => {
                gem.remove();
            }, 1800);
        }


        // Hilfsfunktion für gewichtete Upgrade-Auswahl
        function getWeightedUpgrades(pool, superRareWeight = 1, rareWeight = 10, commonWeight = 50) {
            const weighted = [];

            for (const upg of pool) {
                let weight;
                switch (upg.rarity) {
                    case 'superrare':
                        weight = superRareWeight;
                        break;
                    case 'rare':
                        weight = rareWeight;
                        break;
                    default: 
                        weight = commonWeight;
                }

                for (let i = 0; i < Math.round(weight); i++) {
                    weighted.push(upg);
                }
            }

            shuffleArray(weighted);
            return weighted;
        }


        function getThreeUniqueNewCards() {
            const forbiddenCardIds = [17, 18, 19, 21, 22, 23, 24, 34, 35, 36];
            const ownedCardIds = new Set(state.player.deck.map(card => card.id));
            const unlockedIds = state.unlockedCardIds;

            const availableCards = CARD_TYPES.filter(card =>
                !ownedCardIds.has(card.id) &&
                !forbiddenCardIds.includes(card.id) &&
                !unlockedIds.has(card.id) // <- NEU: noch nicht freigeschaltet
            );

            shuffleArray(availableCards);
            return availableCards.slice(0, Math.min(3, availableCards.length));
        }
   
        // Funktion zum Erstellen einer eindeutigen Karteninstanz
    function createCardInstance(cardType) {
            cardUniqueCounter++;

            let newCard = {
                ...cardType,
                uniqueId: cardUniqueCounter,
                basePower: cardType.power, // merken, falls Schwertbonus dazukommt
                tags: cardType.tags || []
            };

            const isSword = (cardType.name === 'Schwert' || (cardType.tags && cardType.tags.includes('sword')));
            if (isSword && state.player.swordPenalty) {
                newCard.basePower = (cardType.power || 0) - state.player.swordPenalty;
            }

            // Bonus anwenden, falls es ein Schwert ist
            if ((newCard.name === 'Schwert' || newCard.tags.includes('sword')) && typeof newCard.power === 'number') {
                // Nur Basiswert setzen, KEIN zusätzlicher Bonus!
                newCard.basePower = newCard.power; // neuer Standardwert
            }


            return newCard;
        }

        function getThreeUniqueUltraCards() {
                const ultraCardIds = [17, 18, 19];
                const ownedCardIds = new Set(state.player.deck.map(card => card.id));
                const ultraCards = CARD_TYPES.filter(card =>
                    ultraCardIds.includes(card.id) && !ownedCardIds.has(card.id)
                );
                console.log("Ultra-Karten zur Auswahl:", ultraCards);
                shuffleArray(ultraCards);
                return ultraCards.slice(0, 3);
            }


         // Funktion zum Loggen von Nachrichten im Spiel
    window.logMessage = function(message, type = 'system') {
        const messageDiv = document.createElement('div');
        messageDiv.classList.add('message', type);
        messageDiv.textContent = message;

        const messageLogElem = document.getElementById('messageLog');
        if (!messageLogElem) return;

        messageLogElem.appendChild(messageDiv);
        messageLogElem.scrollTop = messageLogElem.scrollHeight;
    };
    
        // --- Kern Initialisierungsfunktion ---
function initGame() {
    console.log('Gibt es shopContainerElem?', document.getElementById('shopContainer'));
    

    if (typeof upgradeContainerElem !== 'undefined') upgradeContainerElem.style.display = 'none';
    if (typeof shopContainerElem !== 'undefined') shopContainerElem.style.display = 'none';
    if (typeof gameOverContainerElem !== 'undefined') gameOverContainerElem.style.display = 'none';

    const savedStarterDeck = JSON.parse(localStorage.getItem('starterDeck') || '[]');
    if (savedStarterDeck.length !== 5) {
        alert("Bitte wähle dein Starterdeck zuerst aus.");
        showStarterDeckSelection();
        return;
    }

    const playerName = localStorage.getItem('playerName') || 'Spieler';
    const selectedPassive = localStorage.getItem('selectedPassive') || 'swordfighter';

    console.log("🧠 Geladene Passive:", selectedPassive);
    console.log("Initialisiere Spiel...");
    cardUniqueCounter = 0;

    state = {
        round: 1,
        defeatedEnemies: 0,
        player: {
            level: 1,
            xp: 0,
            xpToNextLevel: BASE_XP_TO_LEVEL_UP,
            maxHealth: 50,
            health: 50,
            maxMana: 10,
            mana: 10,
            block: 0,
            deck: [],
            hand: [],
            discardPile: [],
            maxHandSize: 5,
            lifestealFlat: 0,
            gold: 0,
            statusEffects: [],
            swordBonus: 0,
            zeitklingeKills: 0,
            zeitklingeBonus: 0,
            tempManaCostPenalty: 0
        },
        currentEnemy: null,
        gameOver: false,
        turnInProgress: false,
        highScore: parseInt(localStorage.getItem('pixelKartenspielHighScore') || '0')
    };

    const savedWonCards = JSON.parse(localStorage.getItem('wonCards') || '[]');
    state.wonCards = new Set(savedWonCards);

    const combinedUnlocked = new Set([...savedStarterDeck, ...savedWonCards]);
    state.unlockedCardIds = combinedUnlocked;

    const starterCardIds = savedStarterDeck;
    state.player.deck = [];

    starterCardIds.forEach(id => {
    const base = window.cards.find(c => c.id === id);
        const count = base.weight || 1;
        for (let i = 0; i < count; i++) {
            state.player.deck.push(createCardInstance(base));
        }
    });

    // Wenn Hexenmeister gewählt wurde, füge Tränke hinzu
    if (selectedPassive === 'warlock') {
    const bonusPotionIds = [34, 35, 36];
    bonusPotionIds.forEach(id => {
        const base = window.cards.find(c => c.id === id);
        if (base) {
        state.player.deck.push(createCardInstance(base));
        }
    });
    logMessage("🧪 Hexenmeister: 3 Tränke wurden deinem Deck hinzugefügt.", "system");
    }

    shuffleArray(state.player.deck);
    state.player.name = playerName;

    switch (selectedPassive) {
       case 'warlock':
            state.player.maxHandSize = 6,
            state.player.maxMana = 12;
            state.player.mana = 12;
            break;
        case 'swordfighter':
            state.player.swordBonus = 3;
            state.player.isSwordmaster = true;
            break;
        case 'goldboy':
            state.player.gold = 2500;
            break;
        case 'dragonscale':
            state.player.immuneToStatus = true;
            state.player.hasDragonscale = true;
            break;
        case 'shieldmaster':
            state.player.isShieldmaster = true;
            state.player.swordPenalty = 1;
            state.player.block = 3;
            logMessage('🛡️ Schildmeister: Du startest mit 3 Block.', 'block');
            break;
        case 'martyr':
            state.player.isMartyr = true;
            break;
        case 'undead':
            state.player.passive = 'undead';
            state.player.hellhound = {
                damage: 4,
                icon: 'images/hellhound.png'
            };
            break;
    }

window.CARD_TYPES = window.cards.slice();
console.log("✅ FINALER CARD_TYPES:", window.CARD_TYPES.map(c => c.id));

    playerImageElem.style.backgroundImage = `url(${PLAYER_PIXEL_IMAGE})`;
    playerImageElem.style.backgroundColor = '#444';

    messageLogElem.innerHTML = '';
    logMessage("Neues Spiel gestartet. Viel Glück!", "system");
    updateUIDisplay();
    updatePetDisplay();
    updateHandUI();
    loadEnemy();
    drawCards(3);
    updateEnemyUI();

    gameOverContainerElem.style.display = 'none';
    upgradeContainerElem.style.display = 'none';
    endTurnBtn.disabled = false;
    manaBoostBtn.disabled = false;
    state.turnInProgress = false;

    console.log("Spiel initialisiert. Aktueller Status:", state);
    logMessage(`🧠 Aktive Passive: ${selectedPassive}`, 'system');
    console.log("✅ CARD_TYPES enthält IDs:", CARD_TYPES.map(c => c.id));

    db.collection("highscores")
        .orderBy("score", "desc")
        .limit(10)
        .get()
        .then(snapshot => {
            const list = document.getElementById('leaderboardList');
            if (!list) return;

            list.innerHTML = '';
            snapshot.forEach(doc => {
                const entry = doc.data();
                const li = document.createElement('li');
                li.textContent = `${entry.name}: ${entry.score} besiegte Gegner (Lvl ${entry.level})`;
                list.appendChild(li);
            });
        })
        .catch(err => {
            console.warn("⚠️ Highscore-Liste konnte nicht geladen werden:", err);
        });
}

    
        // --- UI Update Funktionen ---


        // Aktualisiert alle allgemeinen UI-Anzeigen (Stats, Runde etc.)
        function updateUIDisplay() {
            // 🩸 Gesundheit
            playerHealthElem.textContent = state.player.health;
            playerMaxHealthElem.textContent = state.player.maxHealth;
            playerHealthBarElem.style.width = `${Math.max(0, (state.player.health / state.player.maxHealth)) * 100}%`;

            // 🔷 Mana
            playerManaElem.textContent = state.player.mana;
            playerMaxManaElem.textContent = state.player.maxMana;
            playerMaxManaDisplayElem.textContent = state.player.maxMana;

            const manaFill = playerManaBarElem;
            if (manaFill) {
                const manaPercent = state.player.maxMana > 0 ? (state.player.mana / state.player.maxMana) * 100 : 0;
                manaFill.style.width = `${manaPercent}%`;

                // 🌡️ Färbung: rot wenn Karten teurer sind (z. B. Vision)
                if (state.player.tempManaCostPenalty > 0) {
                    console.log("ManaPenalty ist", state.player.tempManaCostPenalty);
                    manaFill.style.backgroundColor = '#e53935'; // rot
                } else {
                    manaFill.style.backgroundColor = '#42a5f5'; // normal blau
                }
            } else {
                console.error("❗ Mana-Fill Element (#playerManaBar) nicht gefunden.");
            }

            // 🛡️ Block, Level, XP
            playerBlockElem.textContent = state.player.block;
            playerLevelElem.textContent = state.player.level;
            playerXPElem.textContent = state.player.xp.toLocaleString();
            xpToNextLevelElem.textContent = state.player.xpToNextLevel.toLocaleString();

            // 🧛 Lebensraub-Anzeige
            playerLifestealDisplayElem.textContent = state.player.lifestealFlat;

            // 💰 Gold
            document.getElementById('playerGoldDisplay').textContent = state.player.gold.toLocaleString();

            // 🎴 Handgröße
            currentHandSizeElem.textContent = state.player.hand.length;
            maxHandSizeDisplayElem.textContent = state.player.maxHandSize;
            maxHandSizeDisplayElem2.textContent = state.player.maxHandSize;

            // 📊 Runde, Highscore
            roundElem.textContent = state.round;
            defeatedEnemiesElem.textContent = state.defeatedEnemies;
            highScoreDisplayElem.textContent = state.highScore.toLocaleString();

            // 🃏 Kartenverfügbarkeit aktualisieren (abhängig von Mana etc.)
            updateCardAvailability();

            // ☠️ Status-Effekte anzeigen
            updatePlayerStatusDisplay();
        }


        function updatePlayerStatusDisplay() {
                const container = document.getElementById('playerStatusDisplay');
                container.innerHTML = ''; // alten Inhalt löschen

                    // Entferne Frost-Aura-Effekt (blauer Hintergrund) wenn er nicht mehr aktiv ist
                if (!state.player.frozen) {
                    document.getElementById('playerDisplay').style.backgroundColor = '';  // Normaler Zustand
                }

                if (state.player.statusEffects?.length > 0) {
                    state.player.statusEffects.forEach(effect => {
                        const span = document.createElement('span');
                        span.classList.add('status-effect', effect.type);

                        // Symbol und Text
                        let icon = '';
                        switch (effect.type) {
                            case 'poison':
                                icon = '☠️';
                                span.style.color = '#ce93d8'; // lila
                                span.textContent = `${icon} ${effect.power} (${effect.duration})`;
                                break;

                            case 'burn':
                                icon = '🔥';
                                span.style.color = '#ff7043'; // orange/rot
                                span.textContent = `${icon} ${effect.power} (${effect.duration})`;
                                break;

                            case 'paralyze':
                                icon = '⚡';
                                span.style.color = '#ffeb3b'; // Gelb
                                span.textContent = `${icon} (${effect.duration})`;
                                break;

                            case 'antiheal':
                                icon = '❌';
                                span.style.color = '#6a1b9a'; // Dunkellila
                                span.textContent = `${icon} Anti Heal`;
                                break;

                            default:
                                icon = '❓';
                                span.textContent = `${icon} (${effect.duration})`;
                        }

                        // Tooltip hinzufügen
                        span.setAttribute('data-tooltip', getEffectDescription(effect.type, effect.duration, effect.power));
                        
                        container.appendChild(span);
                    });
                }

                //Kurze damage buffs (Kraft sammeln)
                if (state.player.tempAttackBonus) {
                    const span = document.createElement('span');
                    span.classList.add('status-effect', 'buff');
                    span.textContent = `+${state.player.tempAttackBonus} Angriff`;
                    container.appendChild(span);
                }

                // 🔥 Märtyrer-Bonus anzeigen (außerhalb der Schleife!)
                if (state.player.isMartyr) {
                    const lostPercent = 1 - (state.player.health / state.player.maxHealth);
                    const martyrBonus = Math.floor(10 * lostPercent); // Repräsentativer Basiswert, z. B. für 5 Schaden
                    const span = document.createElement('span');
                    span.classList.add('status-effect');
                    span.textContent = `⚔ Märtyrer +${martyrBonus}`;
                    span.title = `Bonus-Schaden durch fehlendes Leben (${Math.floor(lostPercent * 100)} % verloren)`;
                    container.appendChild(span);
                }
                updateEnemyUI();
            }

        function getEffectDescription(type, duration, power = 0) {
                switch (type) {
                    case 'poison':
                        return `Vergiftung: Verliert ${power} Leben pro Runde. (${duration} Runden)`;
                    case 'antiheal':
                        return `Heilung blockiert!)`;
                    case 'burn':
                        return `Verbrennung: Verliert ${power} Leben pro Runde. (${duration} Runden)`;
                    case 'paralyze':
                        return `Paralyse: Du kannst nur 2 Karten pro Runde spielen. (${duration} Runden)`;
                    default:
                        return `${type} (${duration} Runden)`;
                }
            }
 
        window.updateEnemyUI = function() {
            if (!state.currentEnemy) {
                enemyNameElem.textContent = 'Kein Gegner';
                enemyHealthElem.textContent = '0';
                enemyMaxHealthElem.textContent = '0';
                enemyHealthBarElem.style.width = '0%';
                enemyAttackElem.textContent = '0';
                monsterImageElem.style.backgroundImage = 'none';
                monsterImageElem.style.backgroundColor = '#555';
                enemyInfoElem.textContent = '';
                monsterTraitsElem.innerHTML = '';
                document.getElementById('enemyMinions').innerHTML = '';
                return;
            }

            const enemy = state.currentEnemy;

            // Gegner-Grunddaten
            enemyNameElem.textContent = enemy.name;
            enemyHealthElem.textContent = enemy.health;
            enemyMaxHealthElem.textContent = enemy.maxHealth;
            enemyHealthBarElem.style.width = `${Math.max(0, (enemy.health / enemy.maxHealth)) * 100}%`;
            let baseAttack = enemy.attack || 0;
            let modifier = enemy.attackModifier != null ? enemy.attackModifier : 1;
            let displayedAttack = Math.floor(baseAttack * modifier);
            if (enemy.statusEffects?.some(e => e.type === 'paralyze')) {
                displayedAttack = Math.floor(displayedAttack / 2);
            }
            enemyAttackElem.textContent = displayedAttack;
            enemyAttackElem.style.color = enemy.statusEffects?.some(e => e.type === 'paralyze') ? '#ffeb3b' : '#fff';
            enemyInfoElem.textContent = enemy.description || '';

            // Bild
            const imagePath = ENEMY_PIXEL_PLACEHOLDERS[enemy.pixelImageKey];
            monsterImageElem.style.backgroundImage = imagePath ? `url(${imagePath})` : 'none';
            monsterImageElem.style.backgroundColor = imagePath ? 'transparent' : '#555';

            // Traits mit Tooltip
            const traitDescriptions = {
                'Keine Fähigkeit': 'Keine speziellen Effekte.',
                'Stark': 'Verdoppelt Angriff nach 3 Runden.',
                'Giftig': '30% Chance, den Spieler zu vergiften (2 Schaden für 3 Runden).',
                'Regeneration': 'Regeneriert jede Runde Leben.',
                'Massiv': 'Immun gegen Gift.',
                'Untotenbeschwörer': 'Beschwört einmalig zwei Skelette. Diese werden von direktem Damage zuerst angegriffen',
                'Eis-Elementar': 'Bekommt doppelten schaden durch Feuerattacken.',
                'Frost-Aura': '20% Chance, den Spieler einzufrieren.',
                'Höllen Krallen': '45% Chance auf kritischen Treffer. (Kritischer Treffer = 1,5x Schaden)',
                'Verspielt': '20% Chance, den Angriff zu verpassen.',
                'Feueratem': '30% Chance auf Brennen (5 Schaden für 2 Runden).',
                'Fliegend': 'Ignoriert Block zu 50%.',
                'Gepanzerte Schuppen': 'Immun gegen alle Statuseffekte.',
                'Lebensraub': 'Heilt sich um 50% seine schadens.',
                'Segen': 'Heilt sich einmal um 50% seiner Leben.',
                'Rüstung': 'Stellt jede Runde 5 Block her',
                'Vamp': 'Heilt sich um 50% des verursachten Schadens',
                'Krieger': 'Ein erfahrener Krieger trifft auch manchmal doppelt',
                'Statisch': 'Angriffe Paralysieren dich zu 45% (Paraylse = 2 Karte nur Spielbar)',
                'Höllenwache': 'Beschwört einen sehr starken Höllenhund',
                'Antiheal': 'Vehindert jegliche Heilung (Ausgenommen: Lotus Trank)',
                'Vision': 'Erhöht deine Manakosten um 1',
                'Rücksichtslos': 'Fügt sich bei jedem Angriff selbst Schaden in Höhe von 50 % seines Angriffs zu.',
                'YinYang': 'Yin: 40 Shield / Yang: 2x Angriff. Verändert sich zufällig',
                'Teilung': 'Teil sich in einen Mini-Schleim nach dem Tod',
                'Dämlich': 'Zu dumm um den Genger zu treffen. Macht sich gelgentlich selber 10 schaden',
                'Tank': 'Erleidet weniger Schaden, je weniger Leben er hat (bis zu 50 % Reduktion).',
                'Entfesselung': 'Greift dich erst nach 2 Runden an',
                'Lichking': 'Wird nach dem Tot mit 50% Leben wiederbelebt und bekommt einen Schadensboost',
                'Defense': 'Physische Attacken machen halben Schaden und Spezielle doppelten',
                'Special Defense': 'Spezielle Attacken machen halben Schaden und Physische doppelten',
            };
                monsterTraitsElem.innerHTML = '';
                if (enemy.traits?.length) {
                    enemy.traits.forEach(trait => {
                        const span = document.createElement('span');
                        span.classList.add('monster-trait');

                        if (trait === 'Lichking') {
                            span.style.backgroundColor = '#00e0e0';  // Türkis
                            span.style.color = '#002020';           // Dunkle Schrift
                            span.style.border = '1px solid #00cccc';
                        }

                        if (trait === 'YinYang') {
                            const yinYangState = enemy.yinYangState || 'yin'; // Sicherer Fallback
                            if (yinYangState === 'yin') {
                                span.style.backgroundColor = '#fff';
                                span.style.color = '#000';
                                span.textContent = 'Yin';
                            } else {
                                span.style.backgroundColor = '#000';
                                span.style.color = '#fff';
                                span.textContent = 'Yang';
                            }
                        } else {
                            span.textContent = trait;
                        }

                        span.setAttribute('data-tooltip', traitDescriptions[trait] || 'Keine Beschreibung verfügbar.');
                        monsterTraitsElem.appendChild(span);
                    });
                }

                //Block enemy
            const enemyBlockElem = document.getElementById('enemyBlock');
                if (!enemyBlockElem) {
                    const blockDiv = document.createElement('div');
                    blockDiv.id = 'enemyBlock';
                    blockDiv.style.color = '#00bcd4';
                    blockDiv.style.fontWeight = 'bold';
                    blockDiv.style.marginTop = '4px';
                    enemyHealthElem.parentElement.appendChild(blockDiv);
                }
                document.getElementById('enemyBlock').textContent = `🛡 ${state.currentEnemy.block || 0}`;

            // Status-Effekte
            if (enemy.statusEffects?.length) {
            enemy.statusEffects.forEach(effect => {
                const span = document.createElement('span');
                span.classList.add('monster-trait', 'status-effect');

                let icon = '❓';
                let bgColor = '#777';
                let textColor = '#fff';
                let tooltip = `${effect.type} (${effect.duration})`;
                let text = `${icon} (${effect.duration})`;

                switch (effect.type) {
                    case 'poison':
                        icon = '☠️';
                        bgColor = '#6a1b9a';
                        tooltip = `Vergiftung – erleidet ${effect.power} Schaden pro Runde`;
                        text = `${icon} ${effect.power} (${effect.duration})`;
                        break;

                    case 'burn':
                        icon = '🔥';
                        bgColor = '#ff7043';
                        tooltip = `Verbrennung – erleidet ${effect.power} Schaden pro Runde`;
                        text = `${icon} ${effect.power} (${effect.duration})`;
                        break;

                    case 'paralyze':
                        icon = '⚡';
                        bgColor = '#ffeb3b';
                        textColor = '#000';
                        tooltip = `Paralyse – halbiert den Angriff (${effect.duration} Runden)`;
                        text = `${icon} (${effect.duration})`;
                        break;

                    case 'bleed':
                        icon = '🩸';
                        bgColor = '#8B0000'; // Dunkelrot
                        tooltip = `Blutung – 2x schaden durch The Knive`;
                        text = `${icon} (∞)`;
                        break;

                }

                span.style.backgroundColor = bgColor;
                span.style.color = textColor;
                span.setAttribute('data-tooltip', tooltip);
                span.textContent = text;
                monsterTraitsElem.appendChild(span);
            });
        }

            // Minions anzeigen
            const minionContainer = document.getElementById('enemyMinions');
            minionContainer.innerHTML = '';

            if (enemy.minions?.length) {
                enemy.minions.forEach(minion => {
                    const minionDiv = document.createElement('div');
                    minionDiv.classList.add('minion-box');

                    // Bildpfad korrekt abrufen
                    const imgPath = ENEMY_PIXEL_PLACEHOLDERS[minion.pixelImageKey] || 'images/Skelett.png';

                    // Besondere Klasse für Höllenhund
                    if (minion.pixelImageKey === 'hund' || minion.pixelImageKey === 'hund') {
                        minionDiv.classList.add('hund');
                    }

                    minionDiv.innerHTML = `
                        <div class="minion-image" style="background-image: url(${imgPath});"></div>
                        <div>${minion.health} / ${minion.maxHealth}</div>
                        <div>⚔ ${minion.attack}</div>
                    `;

                    minionContainer.appendChild(minionDiv);
                });
            }
        }
    
        // Aktualisiert die Anzeige der Handkarten
 window.updateHandUI = function() {
    cardHandElem.innerHTML = ''; // Alte Karten entfernen
    state.player.hand.forEach(card => {
        const cardDiv = createCardElement(card); // Eigene Funktion für Kartenerstellung
        cardHandElem.appendChild(cardDiv);
    });
    updateCardAvailability(); // Verfügbarkeit nach dem Neuzeichnen prüfen
    currentHandSizeElem.textContent = state.player.hand.length;
    updatePlayerStatusDisplay();
}


    
function createCardElement(card) {
    const cardDiv = document.createElement('div');
    cardDiv.classList.add('card', 'card-animation');
    cardDiv.dataset.uniqueId = card.uniqueId;
    
if (card.type === 'physical') {
  cardDiv.classList.add('physical');
} else if (card.type === 'special') {
  cardDiv.classList.add('special');
}


    if (card.rarity === 'rare') cardDiv.classList.add('rare');
    if (card.rarity === 'superrare') cardDiv.classList.add('superrare');

    const EFFECT_ICONS = {
        damage: '💥',
        block: '🛡️',
        heal: '❤️',
        lifesteal: '💥',
        poison: '☠️',
        damage_paralyze: '💥',
        whirlwind: '💥',
        firearrow: '💥',
        gamble: '💥',
        damage_selfhit: '💥',
        multi_hit: '💥',
        bleed: '🩸',
        zeitklinge_damage: '💥',
    };

    let powerHint = '';
    let formattedPower = '';

    if (typeof card.power === 'object' && card.power !== null) {
        const enhanced = {};

        for (const [eff, val] of Object.entries(card.power)) {
            let result = val || 0;

            if (eff === 'damage') {
                if (card.name.includes('Schwert') || card.name === 'Schwert') {
                    if (state.player?.swordBonus) {
                        result += state.player.swordBonus;
                        powerHint += `+${state.player.swordBonus} durch Schwertkämpfer `;
                    }
                    if (state.player?.isShieldmaster) {
                        result -= 1;
                        powerHint += `-1 durch Schildmeister `;
                    }
                }
            }

            if (result > 0) {
                enhanced[eff] = result;
            }
        }

        formattedPower = Object.entries(enhanced)
            .map(([eff, val]) => `<span style="font-size: 16px;">${EFFECT_ICONS[eff] || eff}</span> ${val}`)
            .join(' / ');
    } else {
        let base = card.basePower ?? card.power ?? 0;

        if (card.effect === 'damage' && (card.name.includes('Schwert') || card.name === 'Schwert')) {
            if (state.player?.swordBonus) {
                base += state.player.swordBonus;
                powerHint += `+${state.player.swordBonus} durch Schwertkämpfer `;
            }
            if (state.player?.isShieldmaster) {
                base -= 1;
                powerHint += `-1 durch Schildmeister `;
            }
        }

        if (base > 0) {
            formattedPower = `<span style="font-size: 20px;">${EFFECT_ICONS[card.effect] || ''}</span> ${base}`;
        }
    }

    cardDiv.innerHTML = `
            <div class="card-mana">${getEffectiveManaCost(card)}</div>
        <div class="card-name">${card.name}</div>
            <div class="card-icon">
            ${card.icon.endsWith('.png') 
                ? `<img src="${card.icon}" style="width: ${card.name === 'Zeitklinge' ? '72px' : '42px'}; height: ${card.name === 'Zeitklinge' ? '72px' : '42px'}; image-rendering: pixelated;" alt="${card.name}">` 
                : card.icon}
            </div>
        <div class="card-description">
            ${card.description}
            ${card.name === 'Schwert' && state.player?.isShieldmaster 
                ? `<br><span style="color:orange;">-1 wegen Schildmeister</span>` 
                : ''}
        </div>
        <div class="card-power" title="${powerHint.trim()}">${formattedPower}</div>
    `;

 cardDiv.addEventListener('click', () => {
    if (
        cardDiv.classList.contains('disabled') ||
        state.player.frozen ||
        state.turnInProgress ||
        state.player.isCountering
    ) return;

    playCard(card.uniqueId);
});

    return cardDiv;
}


function getEffectiveManaCost(card, forDisplay = false) {
    if (card.manaCost === 'X') {
        // Kraft Sammeln zeigt immer "X" an, zählt aber intern als 1
        return forDisplay ? 'X' : 1;
    }

    let cost = typeof card.manaCost === 'number' ? card.manaCost : parseInt(card.manaCost) || 0;

    if (!forDisplay) {
        cost += state.player.tempManaCostPenalty || 0;
    }

    return cost;
}


    
        // Aktualisiert den 'disabled'-Status der Karten basierend auf Manakosten
        function updateCardAvailability() {
            const cards = document.querySelectorAll('.card');

            cards.forEach(cardElem => {
                const card = state.player.hand.find(c => c.uniqueId == cardElem.dataset.uniqueId);
                if (!card) return;

                let manaCost = getEffectiveManaCost(card);

                const hasEnoughMana = state.player.mana >= manaCost;
                const shouldDisable = 
                    (manaCost > 0 && !hasEnoughMana) ||
                    state.player.frozen ||
                    state.turnInProgress ||      // 🆕 Zug blockiert
                    state.player.isCountering;  // 🆕 Konter aktiv

                if (shouldDisable) {
                    cardElem.classList.add('disabled');
                } else {
                    cardElem.classList.remove('disabled');
                }
            });

            endTurnBtn.disabled = state.turnInProgress;
            manaBoostBtn.disabled = state.turnInProgress || cardsPlayedThisTurn > 0 || state.player.frozen;
        }

        
        //Pet
        function updatePetDisplay() {
            const container = document.getElementById('petContainer');
            container.innerHTML = '';

            // Normales Pet anzeigen
            if (state.player.activePet) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('pet-tooltip-wrapper');

                const img = document.createElement('img');
                img.src = state.player.activePet.icon;
                img.alt = state.player.activePet.name;
                img.classList.add('pet-image');

                const tooltip = document.createElement('div');
                tooltip.classList.add('pet-tooltip');
                tooltip.textContent = getPetDescription(state.player.activePet.effect);

                wrapper.appendChild(img);
                wrapper.appendChild(tooltip);
                container.appendChild(wrapper);
            }

            // Teufelshund anzeigen (falls vorhanden)
            if (state.player.hellhound) {
                const wrapper = document.createElement('div');
                wrapper.classList.add('pet-tooltip-wrapper');

                const img = document.createElement('img');
                img.src = state.player.hellhound.icon;
                img.alt = 'Teufelshund';
                img.classList.add('pet-image');

                const tooltip = document.createElement('div');
                tooltip.classList.add('pet-tooltip');
                tooltip.textContent = `Teufelshund: ${state.player.hellhound.damage} Damage.`;

                wrapper.appendChild(img);
                wrapper.appendChild(tooltip);
                container.appendChild(wrapper);
            }
        }


        function getPetDescription(effect) {
                switch (effect) {
                    case 'gawa':
                        return 'Macht 5 extra Schaden.';
                    case 'lulu':
                        return '2 Schaden, +1 Mana Regeneration';
                    case 'cassa':
                        return '1 Schaden, +3 Block pro Runde.';
                    default:
                        return 'Ein treuer Begleiter.';
                }
            }



        function updateYinYangState(enemy) {
                if (!enemy.traits?.includes('YinYang')) return;

                if (enemy.yinYangTurnsRemaining > 0) {
                    enemy.yinYangTurnsRemaining--; // Zustand bleibt noch bestehen
                    return;
                }
                // Zustand wechseln
                const newState = Math.random() < 0.5 ? 'yin' : 'yang';
                enemy.yinYangState = newState;

                if (newState === 'yin') {
                    enemy.attackModifier = 0.5;
                    enemy.block = 40;
                    logMessage(`${enemy.name} geht in den Yin-Zustand: Verteidigung +20 Block, halber Angriff.`, 'enemy');
                } else {
                    enemy.attackModifier = 1;
                    enemy.block = 0;
                    logMessage(`${enemy.name} geht in den Yang-Zustand: voller Angriff, keine Verteidigung.`, 'enemy');
                }
                // Zustand bleibt mindestens 1 Gegnerzug lang bestehen
                enemy.yinYangTurnsRemaining = 1;
            }


        // Lädt einen neuen Gegner basierend auf dem Spielerlevel
        function loadEnemy() {

            const possibleEnemies = ENEMY_TYPES.filter(enemy =>
                state.player.level >= enemy.levelMin && state.player.level <= enemy.levelMax
            );
    
            let enemyTemplate;
            if (possibleEnemies.length > 0) {
                const randomIndex = getRandomInt(0, possibleEnemies.length - 1);
                enemyTemplate = possibleEnemies[randomIndex];
            } else {
                // Fallback: Wenn kein passender Gegner gefunden wird (z.B. am Ende der definierten Gegner)
                console.warn("Kein passender Gegner für Level", state.player.level, "gefunden. Lade letzten Gegner.");
                enemyTemplate = ENEMY_TYPES[ENEMY_TYPES.length - 1];
            }
    
            // WICHTIG: Eine *Kopie* des Gegners erstellen, um das Original nicht zu ändern!
                    state.currentEnemy = {
                        ...enemyTemplate,
                        health: enemyTemplate.health, // Startleben setzen
                        maxHealth: enemyTemplate.health, // MaxLeben speichern
                        poisonTurns: 0,
                        statusEffects: [],
                        minions: [],
                        block: 0,
                        yinYangState: null,
                        yinYangTurnsRemaining: 0,
                        attackModifier: 1
                    };

                    if (state.currentEnemy.traits?.includes('YinYang')) {
                        updateYinYangState(state.currentEnemy);
                    }
                            // Vision-Effekt setzen oder entfernen
                if (enemyTemplate.traits?.includes('Vision')) {
                    state.player.tempManaCostPenalty = 1;
                    logMessage(`👁️ Vision: Deine Handkarten kosten in dieser Runde +1 Mana!`, 'debuff');
                } else if (!state.player.frozen) {
                    state.player.tempManaCostPenalty = 0;
                }


        
            console.log("Gegner geladen:", state.currentEnemy.name);
            enemyContainerElem.classList.remove('defeat', 'hit'); // Animation-Klassen zurücksetzen
            enemyContainerElem.style.opacity = 1;
            enemyContainerElem.style.transform = 'none';
            updateEnemyUI(); // Anzeige aktualisieren
            updateHandUI();
            updateUIDisplay(); // damit wird die rote Farbe bei Vision sofort angezeigt
        }


        window.drawCards = function(numCards) {
            let drawnCount = 0;

            while (drawnCount < numCards) {
                const handCount = state.player.hand.filter(c => c.name !== 'Donner-Zauber' && c.name !== 'Lotus Trank').length;
                if (handCount >= state.player.maxHandSize) {
                    logMessage(`Hand ist voll. Ziehen gestoppt.`, 'discard');
                    break;
                }

                // Deck leer → Mische Ablagestapel
                if (state.player.deck.length === 0) {
                    if (state.player.discardPile.length === 0) {
                        logMessage("Deck und Ablagestapel sind leer. Keine Karte gezogen.", 'system');
                        break;
                    }
                    logMessage("Deck leer. Mische Ablagestapel...", 'system');
                    state.player.deck = [...state.player.discardPile];
                    state.player.discardPile = [];
                    shuffleArray(state.player.deck);
                }

                const card = state.player.deck.pop();
                state.player.hand.push(card);
                drawnCount++;
            }

            if (drawnCount > 0) {
                updateHandUI();
                updateUIDisplay();
            }

            return drawnCount;
        }

    
        // --- Platzhalter für weitere Spiellogik (wird später benötigt) ---
function getEffectiveManaCost(card) {
    // Falls es eine "X"-Kostenkarte ist, nicht beeinflussen
    if (card.manaCost === 'X') return 'X';

    let cost = card.manaCost;
    if (state.player.tempManaCostPenalty) {
        cost += state.player.tempManaCostPenalty;
    }
    return cost;
}


 function playCard(uniqueCardId) {
    if (state.gameOver || state.turnInProgress) return;

    const paralyzeEffect = state.player.statusEffects?.find(e => e.type === 'paralyze');
    if (paralyzeEffect && cardsPlayedThisTurn >= 2) {
        logMessage("⚡ Du bist paralysiert und kannst diese Runde nur 2 Karten spielen!", 'system');
        return;
    }

    const cardIndex = state.player.hand.findIndex(c => c.uniqueId === uniqueCardId);
    if (cardIndex === -1) {
        console.error("Karte zum Spielen nicht in der Hand gefunden:", uniqueCardId);
        return;
    }
    const card = state.player.hand[cardIndex];

        const isPowerSurge = card.name === 'Kraft Sammeln';

        let requiredMana;
        if (isPowerSurge) {
            requiredMana = 1; // Fix für Kraft Sammeln
        } else {
            requiredMana = getEffectiveManaCost(card); // Funktion berücksichtigt Vision
        }


    if (requiredMana > 0 && state.player.mana < requiredMana) {
        logMessage(`Nicht genug Mana für ${card.name}! (${requiredMana} benötigt)`, 'player');
        const cardElement = cardHandElem.querySelector(`.card[data-unique-id="${uniqueCardId}"]`);
        if (cardElement) {
            cardElement.classList.add('shake');
            setTimeout(() => cardElement.classList.remove('shake'), 250);
        }
        return;
    }

    if (isPowerSurge && state.usedPowerSurgeThisTurn) {
        logMessage(`🔋 Kraft Sammeln kann nur einmal pro Runde genutzt werden.`, 'system');
        return;
    }

    state.turnInProgress = true;
    updateCardAvailability();
    cardsPlayedThisTurn++;

    // Mana abziehen (außer für oneShot)
    if (!card.oneShot) {
        state.player.mana -= requiredMana;
    }

    const cardElement = cardHandElem.querySelector(`.card[data-unique-id="${uniqueCardId}"]`);
    if (cardElement) {
        cardElement.classList.add('played');
        setTimeout(() => {
            updateHandUI();
            updateUIDisplay();
        }, 300);
    } else {
        updateHandUI();
        updateUIDisplay();
    }

    logMessage(`Spieler spielt ${card.name}.`, 'player');

    // ➕ Fusionierte Karten mit mehreren Effekten
    if (card.effect.includes('_') && typeof card.power === 'object') {
        for (const [effect, value] of Object.entries(card.power)) {
            playSingleEffect(effect, value, card);
        }
    } else {
        // Falls durch Anomalie erzeugt → einmaliger Effekt
        if (card.generatedByAnomaly) {
            card.oneShot = true;
        }

       executeCardEffect(card); // normale Karte

    // ➕ Physischer Bonus-Schaden Schwertkämpfer
    if (card?.type === 'physical') {
        const bonus = 3;
        if (state.currentEnemy?.health > 0) {
            state.currentEnemy.health -= bonus;
            logMessage(`⚔️ Physischer Bonus: Gegner erleidet ${bonus} Extraschaden.`, 'player');
            enemyContainerElem.classList.add('hit');
            setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
        }
    }}
    // Spezialfall: Anomalie – Effekt hat Karte ersetzt, keine Ablage/Aktion mehr
    if (card.effect === 'anomaly') {
        state.turnInProgress = false;
        return;
    }

    // Spezialfall: Kraft Sammeln
    if (isPowerSurge) {
        state.usedPowerSurgeThisTurn = true;
    }

    // Ablage oder Entfernen bei oneShot
    state.player.hand.splice(cardIndex, 1);
    if (card.oneShot) {
        logMessage(`${card.name} verschwindet nach der Benutzung.`, 'system');
        playerInventory.delete('donner');
        playerInventory.delete('lotus');
        updatePlayerItemIcons();
    } else {
        state.player.discardPile.push(card);
    }

    updateUIDisplay();
    updateEnemyUI();

    setTimeout(() => {
        checkEnemyDefeat();
    }, 400);
}

  //Zentrale lifesteal funktion
window.applyLifesteal = function(damageDealt) {
    if (!damageDealt || damageDealt <= 0) return;

    if (state.player.hasAntiHeal) {
        logMessage(`❌ Lebensraub wird durch Anti-Heilung blockiert!`, 'debuff');
        return;
    }

    const maxHealable = state.player.maxHealth - state.player.health;
    if (maxHealable <= 0) return;

    const percent = state.player.lifestealPercent || 0;
    const flatRatio = state.player.lifestealFlat || 0;

    const healFromPercent = Math.floor(damageDealt * percent);
    
    let healFromFlat = Math.floor(damageDealt * flatRatio);
    if (flatRatio > 0 && damageDealt > 0 && healFromFlat < 1) {
        healFromFlat = 1; // 🩸 Immer mindestens 1 heilen bei Flat
    }

    const totalHeal = Math.min(healFromPercent + healFromFlat, maxHealable);

    if (totalHeal > 0) {
        state.player.health += totalHeal;

        const parts = [];
        if (healFromPercent > 0) parts.push(`${healFromPercent} (${Math.round(percent * 100)} %)`);
        if (healFromFlat > 0) parts.push(`${healFromFlat} (Flat)`);

        logMessage(`🩸 Lebensraub heilt dich um ${totalHeal} Leben (${parts.join(' + ')}).`, 'lifesteal');
    }
}


window.applyTankTraitReduction = function(target, incomingDamage, card = null) {
    let damage = incomingDamage;

    // ➤ Neue Typenlogik: Defense / Special Defense
    if (card) {
        // Typ wird kontert – Schaden wird verdoppelt
        if (card.type === 'special' && target.traits?.includes('Defense')) {
            damage *= 2;
            logMessage(`⚡ ${target.name} ist schwach gegen Spezialangriffe!`, 'enemy');
        }

        if (card.type === 'physical' && target.traits?.includes('Special Defense')) {
            damage *= 2;
            logMessage(`💥 ${target.name} ist schwach gegen physische Angriffe!`, 'enemy');
        }

        // Typ wird abgewehrt – Schaden wird reduziert
        if (card.type === 'physical' && target.traits?.includes('Defense')) {
            damage *= 0.5;
            logMessage(`🛡️ ${target.name} reduziert physischen Schaden!`, 'enemy');
        }

        if (card.type === 'special' && target.traits?.includes('Special Defense')) {
            damage *= 0.5;
            logMessage(`🔮 ${target.name} reduziert Spezialschaden!`, 'enemy');
        }
    }

    // ➤ Bestehende Tank-Logik
    if (!target.traits?.includes('Tank') || !target.maxHealth) return Math.floor(damage);

    const missingPercent = 1 - (target.health / target.maxHealth);
    const reductionFactor = Math.min(0.5, missingPercent * 0.5); // max 50%
    const reducedDamage = Math.floor(damage * (1 - reductionFactor));

    if (reductionFactor > 0) {
        logMessage(`🪖 ${target.name} reduziert den Schaden um ${Math.round(reductionFactor * 100)} %.`, 'enemy');
    }

    return reducedDamage;
}




// Refactored playSingleEffect for Fusion Effects
function playSingleEffect(effect, power, card) {
    const enemy = state.currentEnemy;
    if (!enemy) return;

    // Kombinierte Effekte aufteilen und rekursiv verarbeiten
    if (effect.includes('_') && typeof power === 'object') {
        const effects = effect.split('_');
        for (const e of effects) {
            playSingleEffect(e, power[e] || 0, card);
        }
        return;
    }

    let remaining = power;

    const hitAnimation = () => {
        enemyContainerElem.classList.add('hit');
        setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
    };

    const applyDragonscale = () => {
        if (state.player.hasDragonscale) {
            const target = enemy.minions?.[0] || enemy;
            applyDragonScaleBurn(target);
        }
    };

    const applyStatusEffect = (target, type, power = 4, duration = 3) => {
        const immunities = {
            poison: ['Gepanzerte Schuppen', 'Massiv'],
            burn: ['Gepanzerte Schuppen'],
            paralyze: ['Gepanzerte Schuppen']
        };
        const immune = immunities[type]?.some(trait => target.traits?.includes(trait));
        if (immune) {
            logMessage(`${target.name} ist immun gegen ${type}.`, 'enemy');
            return;
        }
        if (!target.statusEffects) target.statusEffects = [];
        const existing = target.statusEffects.find(e => e.type === type);
        if (existing) {
            existing.power = Math.max(existing.power, power);
            existing.duration = Math.max(existing.duration, duration);
            logMessage(`🌀 ${target.name} ist bereits betroffen – ${type} verstärkt/verlängert.`, 'effect');
        } else {
            target.statusEffects.push({ type, power, duration });
            logMessage(`🌀 ${target.name} ist nun betroffen: ${type} (${power}, ${duration} Runden).`, 'effect');
        }
        updateEnemyUI();
    };


    switch (effect) {
        case 'damage': {
            let base = applyDamageBonuses(remaining);
            if (card.name === 'Schwert' && state.player.swordBonus) base += state.player.swordBonus;
            if (card.name === 'Schwert' && state.player.isShieldmaster) {
                base -= 1;
                logMessage('⚠️ Schildmeister: Schwert macht 1 weniger Schaden.', 'system');
            }
            const block = Math.min(enemy.block || 0, base);
            if (block > 0) {
                enemy.block -= block;
                logMessage(`${enemy.name} blockt ${block} Schaden.`, 'block');
            }
            const dmg = base - block;
            if (dmg > 0) {
                const finalDmg = applyTankTraitReduction(enemy, dmg);
                enemy.health -= finalDmg;
                logMessage(`${enemy.name} erleidet ${finalDmg} Schaden.`, 'enemy');
                applyLifesteal(dmg);
            } else {
                logMessage(`${enemy.name} blockt den gesamten Schaden!`, 'block');
            }
            applyDragonscale();
            hitAnimation();
            break;
        }

        case 'poison':
        case 'burn':
        case 'paralyze':
            applyStatusEffect(enemy, effect, power);
            break;

            case 'lifesteal': {
                const block = Math.min(enemy.block || 0, remaining);
                if (block > 0) {
                    enemy.block -= block;
                    logMessage(`${enemy.name} blockt ${block} Schaden.`, 'block');
                }
                const dmg = remaining - block;

                if (dmg > 0) {
                    const finalDmg = applyTankTraitReduction(enemy, dmg);
                    enemy.health -= finalDmg;
                    logMessage(`${enemy.name} erleidet ${finalDmg} Schaden.`, 'enemy');
                    // ❌ Anti-Heal wird in applyLifesteal geprüft
                    applyLifesteal(dmg);
                }
                hitAnimation();
                break;
            }

        case 'draw':
            drawCards(remaining);
            logMessage(`📜 Du ziehst ${remaining} Karte(n).`, 'system');
            break;

        case 'gain_mana': {
            const gained = Math.min(remaining, state.player.maxMana - state.player.mana);
            state.player.mana += gained;
            logMessage(`🔷 Du erhältst ${gained} Mana.`, 'mana');
            break;
        }

        case 'block':
            state.player.block += remaining;
            logMessage(`🛡️ Du erhältst ${remaining} Block.`, 'block');
            break;

        case 'heal': {
            if (state.player.hasAntiHeal) {
                logMessage(`❌ Deine Heilung wird durch Anti-Heilung blockiert!`, 'debuff');
                break;
            }
            const heal = Math.min(remaining, state.player.maxHealth - state.player.health);
            state.player.health += heal;
            logMessage(`❤️ Du heilst ${heal} Leben.`, 'heal');
            break;
        }


        case 'multi_hit': {
            const hits = card.minHits && card.hits
                ? getRandomInt(card.minHits, card.hits)
                : 2 + Math.floor(Math.random() * 2);

            const basePower = card.power || 0;
            const bonusOnce = state.player.hasZeitklinge ? 5 : 0;

            for (let i = 0; i < hits; i++) {
                const bonus = i === 0 ? bonusOnce : 0;
                const totalPower = basePower + bonus;

                const rawDamage = applyDamageBonuses(totalPower); // Oder direkt: totalPower
                const block = card.ignoreBlock ? 0 : Math.min(enemy.block || 0, rawDamage);

                if (!card.ignoreBlock && block > 0) {
                    enemy.block -= block;
                    logMessage(`${enemy.name} blockt ${block} Schaden.`, 'block');
                }

                const dmg = rawDamage - block;
                if (dmg > 0) {
                    const finalDmg = applyTankTraitReduction(enemy, dmg);
                    enemy.health -= finalDmg;
                    logMessage(`Treffer ${i + 1}: ${enemy.name} nimmt ${finalDmg} Schaden.`, 'enemy');
                    applyLifesteal(dmg);
                }

                hitAnimation();
            }

            applyDragonscale();
            break;
        }

        case 'gamble': {
            if (Math.random() < 0.5) {
                enemy.health -= remaining;
                state.player.gold += 100;
                logMessage(`🍀 Glück! ${enemy.name} verliert ${remaining} Leben. +100 Gold!`, 'gold');
            } else {
                state.player.health -= remaining;
                logMessage(`💥 Pech! Du verlierst ${remaining} Leben.`, 'player');
            }
            break;
        }

        case 'damage_selfhit': {
            const block = Math.min(enemy.block || 0, remaining);
            if (block > 0) {
                enemy.block -= block;
                logMessage(`${enemy.name} blockt ${block} Schaden.`, 'block');
            }
            const dmg = remaining - block;
            if (dmg > 0) {
                const finalDmg = applyTankTraitReduction(enemy, dmg);
                enemy.health -= finalDmg;
                logMessage(`${enemy.name} erleidet ${finalDmg} Schaden durch Ansturm.`, 'enemy');
                applyLifesteal(dmg);
            }
            if (card.selfDamage) {
                state.player.health -= card.selfDamage;
                logMessage(`💢 Du erleidest ${card.selfDamage} Rückstoß-Schaden.`, 'player');
            }
            applyDragonscale();
            hitAnimation();
            break;
        }

        case 'whirlwind': {
            const targets = [enemy, ...(enemy.minions || [])];
            let totalDamageDealt = 0;

            targets.forEach(target => {
                const adjustedDamage = applyTankTraitReduction(target, remaining);
                target.health -= adjustedDamage;
                totalDamageDealt += adjustedDamage;
                logMessage(`🌀 ${target.name} erleidet ${adjustedDamage} Schaden durch Klingenwirbel.`, 'enemy');
            });

            enemy.minions = enemy.minions?.filter(m => m.health > 0) || [];
            applyLifesteal(totalDamageDealt);
            applyDragonscale();
            hitAnimation();
            break;
        }
        default:
            logMessage(`⚠️ Effekt ${effect} ist nicht bekannt.`, 'system');
    }
}



window.applyDragonScaleBurn = function(target) {
    if (!target.statusEffects) target.statusEffects = [];

    const alreadyBurning = target.statusEffects.some(e => e.type === 'burn');
    if (!alreadyBurning) {
        target.statusEffects.push({ type: 'burn', power: 6, duration: 2 });
        logMessage(`🔥 Drachenschuppen: ${target.name} wurde verbrannt!`, 'burn');
    }
}



        function dealDamage(target, amount) {
            const blockUsed = Math.min(target.block || 0, amount);
            const remaining = Math.max(0, amount - blockUsed);

            if (blockUsed > 0) {
                target.block -= blockUsed;
                logMessage(`${target.name} blockt ${blockUsed} Schaden.`, 'block');
            }

            if (remaining > 0) {
                target.health -= remaining;
                logMessage(`${target.name} erleidet ${remaining} Schaden.`, 'enemy');
            } else {
                logMessage(`${target.name} blockt den gesamten Schaden!`, 'block');
            }

            enemyContainerElem.classList.add('hit');
            setTimeout(() => enemyContainerElem.classList.remove('hit'), 300);
        }


        function tryApplyParalyze(target, chance = 1.0) {
                // Immun gegen Paralyse durch "Gepanzerte Schuppen"
                if (target.traits?.includes('Gepanzerte Schuppen')) {
                    logMessage(`🛡️ ${target.name} ist immun gegen Paralyse!`, 'enemy');
                    return;
                }

                // Bereits paralysiert?
                if (target.statusEffects?.some(e => e.type === 'paralyze')) {
                    logMessage(`⚡ ${target.name} ist bereits paralysiert.`, 'system');
                    return;
                }

                // Paralyse mit Chance anwenden
                if (Math.random() < chance) {
                    if (!target.statusEffects) target.statusEffects = [];
                    target.statusEffects.push({ type: 'paralyze', duration: 2 });
                    logMessage(`⚡ ${target.name} wird paralysiert!`, 'enemy');
                    updateEnemyUI();
                } else {
                    logMessage(`⚡ Der Paralyseversuch bei ${target.name} ist fehlgeschlagen.`, 'system');
                }
            }



        window.applyDamageBonuses = function(baseDamage) {
            let damage = baseDamage;

            if (state.player.tempAttackBonus) {
                damage += state.player.tempAttackBonus;
                logMessage(`💥 Kraftbonus: +${state.player.tempAttackBonus} Schaden!`, 'buff');
                state.player.tempAttackBonus = 0;
            }

            if (state.player.isMartyr) {
                const lostPercent = 1 - (state.player.health / state.player.maxHealth);
                const martyrBonus = Math.floor(damage * lostPercent);
                damage += martyrBonus;
                logMessage(`⚔️ Märtyrer: +${martyrBonus} Bonus-Schaden durch erlittenen Schmerz.`, 'system');
            }

            if (state.player.zeitklingeBonus) {
                const cappedBonus = Math.min(state.player.zeitklingeBonus, 13);
                damage += cappedBonus;
                logMessage(`🕰️ Zeitklingen-Bonus: +${cappedBonus} Schaden.`, 'buff');
            }

                        // Prüfe Mewing-Zustand
            if (state.player.mewingStage === 2) {
                damage = 0;
                logMessage(`😼 Mewing-Effekt aktiv: Diese Runde kein Schaden.`, 'system');
            } else if (state.player.mewingStage === 3) {
                damage *= 2;
                logMessage(`💪 Mewing-Effekt entfaltet sich: DOPPELTER Schaden!`, 'buff');
                state.player.mewingStage = 0; // Effekt verbraucht
            }

            return damage;
}


    
        function endTurn() {
             if (state.gameOver || state.turnInProgress) return;
             state.turnInProgress = true; // Verhindert Aktionen während des Zugendes/Gegnerzugs
             updateCardAvailability(); // Deaktiviert Karten/Buttons
    
             logMessage("Spieler beendet den Zug.", 'system');
    
             // 3. UI aktualisieren (leere Hand, kein Block)
             updateHandUI();
             updateUIDisplay();
    
             // 4. Gegnerzug starten (mit Verzögerung)
             setTimeout(enemyTurn, 600); // Kurze Pause
        }
    
        function manaBoost() {
            if (state.gameOver || state.turnInProgress || cardsPlayedThisTurn > 0) return;

            logMessage("Spieler nutzt Mana Boost. Mana wird vollständig aufgefüllt. Zug wird beendet.", 'mana');

            // Fülle Mana komplett auf
            state.player.mana = state.player.maxMana;


            updateUIDisplay(); // UI sofort aktualisieren
            

            // Jetzt Zug beenden – turnInProgress wird dort korrekt gesetzt
            setTimeout(() => {
                endTurn(); // wichtig: verzögert aufrufen
            }, 100); // kleine Pause für bessere UX
        }

    

// --- Gegnerzug-Logik ---
        function applyEnemyTraitEffectsBeforeAttack() {
                const enemy = state.currentEnemy;

                if (!enemy.traitRounds) enemy.traitRounds = 0;
                enemy.traitRounds++;

                // STARK – Verdoppelt nach 3 Runden
                if (enemy.traits?.includes('Stark') && enemy.traitRounds === 3) {
                    enemy.attack *= 2;
                    logMessage(`${enemy.name} wird wütend! Angriff verdoppelt auf ${enemy.attack}!`, 'enemy');
                }

                //YinYang
                if (enemy.traits?.includes('YinYang')) {
                    const current = enemy.yinYangState;
                    const next = Math.random() < 0.5 ? 'yin' : 'yang';

                    // Zustand nur ändern, wenn er sich unterscheidet
                    if (current !== next) {
                        enemy.yinYangState = next;

                        if (next === 'yin') {
                            enemy.block = 30;
                            enemy.attackModifier = 0.5;
                            logMessage(`${enemy.name} wechselt in den Yin-Zustand: 🛡️ 20 Block, ⚔️ -50 % Angriff.`, 'enemy');
                        } else {
                            enemy.block = 0;
                            enemy.attackModifier = 1.0;
                            logMessage(`${enemy.name} wechselt in den Yang-Zustand: ⚔️ voller Angriff, 🛡️ kein Block.`, 'enemy');
                        }
                    } else {
                        // Gleicher Zustand bleibt bestehen → Effekte erneut setzen
                        if (current === 'yin') {
                            enemy.block = 30;
                            enemy.attackModifier = 0.5;
                        } else {
                            enemy.block = 0;
                            enemy.attackModifier = 1.0;
                        }
                    }
                }

                // UNTOTENBESCHWÖRER – nur beim ersten Mal
                if (enemy.traits?.includes('Untotenbeschwörer') && !enemy.summoned) {
                    logMessage(`${enemy.name} beschwört zwei Skelette zur Unterstützung!`, 'enemy');

                    // Skelette definieren und zur Minion-Liste hinzufügen
                    enemy.minions.push(
                        {
                            name: 'Skelett',
                            health: 5,
                            maxHealth: 5,
                            attack: 3,
                            pixelImageKey: 'Skelett' // Bildname, z. B. 'Skelett.png'
                        },
                        {
                            name: 'Skelett',
                            health: 5,
                            maxHealth: 5,
                            attack: 3,
                            pixelImageKey: 'Skelett'
                        }
                    );

                    enemy.summoned = true;
                    updateEnemyUI(); // Anzeige sofort aktualisieren
                }


                if (enemy.traits?.includes('Höllenwache') && !enemy.summonedHellhound) {
                    logMessage(`${enemy.name} ruft einen höllischen Wachhund zur Hilfe!`, 'enemy');

                    enemy.minions.push({
                        name: 'Höllenhund',
                        health: 55,
                        maxHealth: 60,
                        attack: 16,
                        pixelImageKey: 'hund'
                    });

                    enemy.summonedHellhound = true;
                    updateEnemyUI();
                }

                // VERSPIELT – 20% verfehlt
                if (enemy.traits?.includes('Verspielt') && Math.random() < 0.2) {
                    logMessage(`${enemy.name} spielt herum und verfehlt seinen Angriff.`, 'enemy');
                    enemy.skipAttack = true;
                }

                // FLIEGEND – ignoriert Block (25%)
                if (enemy.traits?.includes('Fliegend') && Math.random() < 0.50) {
                    logMessage(`${enemy.name} greift aus der Luft an – dein Block wird ignoriert!`, 'enemy');
                    state.player.block = 0;
                }
            }

            function applyEnemyTraitEffectsAfterAttack(damage) {
                const enemy = state.currentEnemy;

                // GIFTIG
                if (
                    enemy.traits?.includes('Giftig') &&
                    Math.random() < 0.3 &&
                    !state.player.statusEffects?.some(e => e.type === 'poison')
                ) {
                    if (state.player.immuneToStatus) {
                        logMessage(`🛡️ Drachenschuppen schützt dich vor Vergiftung.`, 'system');
                    } else {
                        if (!state.player.statusEffects) state.player.statusEffects = [];
                        state.player.statusEffects.push({ type: 'poison', power: 4, duration: 3 });
                        logMessage(`☠️ Du wurdest vergiftet (4 Schaden für 3 Runden)!`, 'poison');
                    }
            }

                // FROST-AURA
                if (enemy.traits?.includes('Frost-Aura') && Math.random() < 0.20) {
                if (state.player.immuneToStatus) {
                    logMessage(`🛡️ Drachenschuppen schützt dich vor Vereisung durch Frost-Aura.`, 'system');
                } else {
                    state.player.frozen = true;
                    logMessage(`❄️ Du bist vereist und setzt nächste Runde aus!`, 'enemy');

                    // Visual Effect: Spielerfeld wird blau (vereist)
                    document.getElementById('playerDisplay').style.backgroundColor = 'rgba(0, 247, 255, 0.8)';
                }
            }

            // ❌ ANTIHEAL – Spieler kann sich 2 Runden nicht heilen
                if (enemy.traits?.includes('Antiheal')) {
                    if (state.player.hasAntiHeal) {
                        state.player.antiHealTurns = 2; // überschreibt oder setzt erneut auf 2
                    } else {
                        state.player.hasAntiHeal = true;
                        state.player.antiHealTurns = 2;
                        logMessage(`❌ ${enemy.name} belegt dich mit Anti-Heilung! Du kannst dich 2 Runden lang nicht heilen.`, 'debuff');
                    }
                }

                // FEUERATEM
                if (enemy.traits?.includes('Feueratem') && Math.random() < 0.3) {
                const alreadyBurning = state.player.statusEffects?.some(e => e.type === 'burn');
                if (!alreadyBurning) {
                    if (state.player.immuneToStatus) {
                        logMessage(`🛡️ Drachenschuppen schützt dich vor Feuer.`, 'system');
                    } else {
                        if (!state.player.statusEffects) state.player.statusEffects = [];
                        state.player.statusEffects.push({ type: 'burn', power: 5, duration: 2 });
                        logMessage(`🔥 Du brennst – 5 Schaden für 2 Runden!`, 'enemy');
                    }
                }
            }

            // ⚔️ NEU: KRIEGER-Trait – Chance auf Extra-Angriff mit Verzögerung
            if (enemy.traits?.includes('Krieger') && Math.random() < 0.3) {
                logMessage(`⚔️ ${enemy.name} holt zu einem weiteren Schlag aus...`, 'enemy');

                setTimeout(() => {
                    const bonusDamage = enemy.attack || 0;
                    const blockUsed = Math.min(state.player.block, bonusDamage);
                    const damageTaken = Math.max(0, bonusDamage - blockUsed);

                    if (blockUsed > 0) {
                        state.player.block -= blockUsed;
                        logMessage(`🛡️ Spieler blockt ${blockUsed} Schaden vom Zusatzschlag.`, 'block');
                    }

                    if (damageTaken > 0) {
                        state.player.health -= damageTaken;
                        logMessage(`💥 ${enemy.name} trifft erneut und verursacht ${damageTaken} Extraschaden!`, 'enemy');
                    } else {
                        logMessage(`${enemy.name}'s Zusatzschlag wird komplett geblockt.`, 'block');
                    }

                    updateUIDisplay();

                    if (state.player.health <= 0) {
                        gameOver();
                    }
                }, 600); // ≈ 0.6 Sekunden Verzögerung – angenehm sichtbar
            }
        }


            function enemyTurn() {

                state.turnInProgress = true;
                state.player.frozen = false;
                state.currentEnemy.damagedThisTurn = false;

            logMessage("🔁 Gegner ist am Zug...", 'enemy');

                // 🔓 ENTFESELUNG – Gegner setzt 2 Runden aus, dann voller Angriff
                if (state.currentEnemy.traits?.includes('Entfesselung')) {
                // Einmalige Initialisierung
                if (typeof state.currentEnemy.entfesselungTurns === 'undefined') {
                    state.currentEnemy.entfesselungTurns = 2;
                    state.currentEnemy.originalAttack = state.currentEnemy.attack;
                }

                if (state.currentEnemy.entfesselungTurns > 0) {
                    state.currentEnemy.entfesselungTurns--;
                    state.currentEnemy.attack = 0;
                    logMessage(`${state.currentEnemy.name} bereitet sich vor... (Entfesselung – ${state.currentEnemy.entfesselungTurns} Runden verbleiben)`, 'enemy');
                } else if (state.currentEnemy.attack === 0) {
                    // Entfesselung endet – einmalig zurückgeben
                    state.currentEnemy.attack = state.currentEnemy.originalAttack;
                    logMessage(`${state.currentEnemy.name} entfesselt seine volle Kraft!`, 'enemy');
                }
                }

                applyEnemyTraitEffectsBeforeAttack();

                // Wenn Minions vorhanden sind, greifen sie zuerst an
                if (state.currentEnemy.minions?.length) {
                    state.currentEnemy.minions.forEach(minion => {
                        let damage = minion.attack || 0;
                        const blockUsed = Math.min(state.player.block, damage);
                        let damageTaken = Math.max(0, damage - blockUsed);
                        if (state.player.damageReduction) {
                            const reduced = Math.floor(damageTaken * state.player.damageReduction);
                            damageTaken -= reduced;
                            logMessage(`🛡 Titan Hose schützt dich: ${reduced} Schaden reduziert.`, 'block');
                        }

                        if (blockUsed > 0) {
                            state.player.block -= blockUsed;
                            logMessage(`🛡️ Spieler blockt ${blockUsed} Schaden von ${minion.name}.`, 'block');
                        }

                        if (damageTaken > 0) {
                            state.player.health -= damageTaken;
                            logMessage(`💀 ${minion.name} fügt dir ${damageTaken} Schaden zu!`, 'enemy');
                        } else {
                            logMessage(`${minion.name} wird komplett geblockt.`, 'block');
                        }
                    });
                }


                if (state.currentEnemy.skipAttack) {
                    state.currentEnemy.skipAttack = false;
                    applyEnemyStatusEffectsAfterTurn();
                    updateUIDisplay();
                    setTimeout(startNewTurn, 800);
                    return;
                }

                // 🧠 Dämlich – 40% Chance, sich selbst zu verletzen
                if (state.currentEnemy.traits?.includes('Dämlich') && Math.random() < 0.4) {
                    state.currentEnemy.health -= 10;
                    logMessage(`🤪 ${state.currentEnemy.name} greift sich selbst an! -10 Leben.`, 'enemy');
                    updateEnemyUI();
                    // Kein Angriff diese Runde
                    applyEnemyStatusEffectsAfterTurn();
                    updateUIDisplay();
                    setTimeout(startNewTurn, 800);
                    return;
                }

                let baseAttack = state.currentEnemy.attack || 0;
                let damage = baseAttack;

                if (state.currentEnemy.attackModifier != null) {
                    damage = Math.floor(baseAttack * state.currentEnemy.attackModifier);
                }

                const paralyzeEffect = state.currentEnemy.statusEffects?.find(e => e.type === 'paralyze');
                if (paralyzeEffect) {
                    damage = Math.floor(damage / 2);
                    logMessage(`⚡ Paralyse reduziert den Angriff des Gegners auf ${damage}.`, 'enemy');
                }

                if (state.currentEnemy.traits?.includes('Höllen Krallen') && Math.random() < 0.45) {
                    damage = Math.floor(damage * 1.5);
                    logMessage(`💥 Kritischer Treffer! Schaden erhöht auf ${damage}.`, 'enemy');
                }

                const blockUsed = Math.min(state.player.block, damage);
                let damageTaken = Math.max(0, damage - state.player.block);
                if (state.player.damageReduction) {
                    const reduced = Math.floor(damageTaken * state.player.damageReduction);
                    damageTaken -= reduced;
                    logMessage(`🛡 Titan Hose schützt dich: ${reduced} Schaden reduziert.`, 'block');
                }

                if (blockUsed > 0) {
                    state.player.block -= blockUsed;
                    logMessage(`🛡️ Spieler blockt ${blockUsed} Schaden.`, 'block');
                }
                if (damageTaken > 0) {
                    state.player.health -= damageTaken;
                    logMessage(`💥 Spieler erleidet ${damageTaken} Schaden.`, 'player');

                        // 🩸 Rücksichtslos – Gegner verletzt sich selbst
                if (state.currentEnemy.traits?.includes('Rücksichtslos')) {
                    const selfDamage = Math.floor((state.currentEnemy.attack || 0) / 2);
                    if (selfDamage > 0) {
                        state.currentEnemy.health -= selfDamage;
                        logMessage(`🤕 ${state.currentEnemy.name} fügt sich ${selfDamage} Schaden zu (Rücksichtslos).`, 'enemy');
                        updateEnemyUI();

                        // Falls Selbstschaden tödlich war
                        if (state.currentEnemy.health <= 0) {
                            logMessage(`${state.currentEnemy.name} stirbt durch Rücksichtslosigkeit!`, 'system');
                            checkEnemyDefeat();
                            return;
                        }
                    }
                }

                    // ⚡ Paralyse durch "Statisch"-Trait
                    const hasStaticTrait = state.currentEnemy.traits?.includes('Statisch');
                    const alreadyParalyzed = state.player.statusEffects?.some(e => e.type === 'paralyze');

                    if (hasStaticTrait && !alreadyParalyzed && Math.random() < 0.45) {
                        if (state.player.immuneToStatus) {
                            logMessage(`🛡️ Drachenschuppen schützt dich vor Paralyse durch Statisch.`, 'system');
                        } else {
                            if (!state.player.statusEffects) state.player.statusEffects = [];
                            state.player.statusEffects.push({ type: 'paralyze', duration: 3 });
                            logMessage(`⚡ Du wurdest durch den statischen Angriff paralysiert!`, 'enemy');
                            updatePlayerStatusDisplay();
                        }
                    }


                    // 🪓 Dornen-Helm: Gegner erleidet Rückstoß
                if (state.player.hasThorns) {
                    const thornDamage = Math.floor(damageTaken * 0.3);
                    if (thornDamage > 0) {
                        state.currentEnemy.health -= thornDamage;
                        logMessage(`🪓 Dornen-Helm: ${state.currentEnemy.name} erleidet ${thornDamage} Rückstoß-Schaden!`, 'enemy');
                        updateEnemyUI();
                    }
                }

                    playerDisplay.classList.add('shake');
                    updatePlayerStatusDisplay();

                    // Nach Shake-Effekt Statusanzeige aktualisieren
                    setTimeout(() => {
                        playerDisplay.classList.remove('shake');
                    }, 250);
                } else {
                    logMessage("🧱 Angriff komplett geblockt!", 'block');
                }

                applyEnemyTraitEffectsAfterAttack(damage);

                if (
                    damageTaken > 0 &&
                    state.currentEnemy.traits?.includes('Vamp')
                ) {
                    const heal = Math.floor(damageTaken * 0.5);
                    const maxHealable = state.currentEnemy.maxHealth - state.currentEnemy.health;
                    const actualHeal = Math.min(heal, maxHealable);

                    if (actualHeal > 0) {
                        state.currentEnemy.health += actualHeal;
                        logMessage(`🩸 ${state.currentEnemy.name} saugt ${actualHeal} Leben durch Vamp!`, 'lifesteal');
                        updateEnemyUI();
                    }
                }

                
              // 🕊 Göttlicher Segen – Erzengel heilt sich einmalig bei unter 50 % Leben
                if (
                    (state.currentEnemy.name === 'Erzengel' || state.currentEnemy.name === 'Yagdril') &&
                    state.currentEnemy.traits.includes('Segen') &&
                    !state.currentEnemy.hasUsedBlessing &&
                    state.currentEnemy.health < state.currentEnemy.maxHealth / 2
                ) {
                    const missingHealth = state.currentEnemy.maxHealth - state.currentEnemy.health;
                    const healAmount = Math.floor(missingHealth / 2);
                    state.currentEnemy.health += healAmount;
                    state.currentEnemy.hasUsedBlessing = true;

                    logMessage(`🕊 ${state.currentEnemy.name} erhält einen göttlichen Segen!`, 'system');
                    logMessage(`✨ Heilt ${healAmount} Leben.`, 'heal');
                    updateEnemyUI();
                }


                if (state.player.isCountering) {
                    state.player.isCountering = false; // Verhindert Doppelkonter

                    setTimeout(() => {
                        const counterDamage = Math.round((state.currentEnemy.attack || 0) * 1.2);
                        state.currentEnemy.health -= counterDamage;
                        logMessage(`🔁 Du konterst mit ${counterDamage} Schaden!`, 'player');

                        updateEnemyUI();

                        if (state.currentEnemy.health <= 0) {
                            handleEnemyDefeated();
                            return;
                        }
                    }, 500); // 1 Sekunde Verzögerung
                }


                applyEnemyStatusEffectsAfterTurn();

                updateUIDisplay();

                if (state.player.health <= 0) {
                    if (state.player.hasSigmaShield) {
                        state.player.health = 1;
                        state.player.hasSigmaShield = false;
                        logMessage(`🛡 SIGMA schützt dich vor dem Tod! Du überlebst mit 1 HP.`, 'system');
                        setTimeout(startNewTurn, 800);
                    } else {
                        gameOver();
                    }
                } else {
                    setTimeout(startNewTurn, 800);
                }
            }


            // --- Status-Effekte beim Gegner auswerten ---
function applyEnemyStatusEffectsAfterTurn() {
    if (!state.currentEnemy || !state.currentEnemy.statusEffects) return;

    let totalPoisonDamage = 0;
    let totalBurnDamage = 0;

    for (let effect of state.currentEnemy.statusEffects) {
        const { type, power, duration } = effect;

        switch (type) {
            case 'poison':
            case 'burn': {
                const isPoison = type === 'poison';
                const damageLabel = isPoison ? 'Giftschaden' : 'Feuerschaden';

                logMessage(`${state.currentEnemy.name} erleidet ${power} ${damageLabel}.`, type);
                if (isPoison) totalPoisonDamage += power;
                else totalBurnDamage += power;
                break;
            }

            case 'paralyze':
                logMessage(`${state.currentEnemy.name} ist gelähmt und greift geschwächt an. (${duration} Runden übrig)`, 'effect');
                break;

            default:
                console.warn(`⚠️ Unbekannter Statuseffekt-Typ: ${type}`);
                break;
        }

        effect.duration -= 1;
    }

    // Gesamtschaden anwenden
    if (totalPoisonDamage > 0) state.currentEnemy.health -= totalPoisonDamage;
    if (totalBurnDamage > 0) state.currentEnemy.health -= totalBurnDamage;

    // Lifesteal durch Elementarschaden
    if (state.player.hasElementalLifesteal) {
        const totalElementalDamage = totalPoisonDamage + totalBurnDamage;
        if (totalElementalDamage > 0) {
            const heal = Math.floor(totalElementalDamage);
            setTimeout(() => {
                state.player.health = Math.min(state.player.maxHealth, state.player.health + heal);
                logMessage(`✨ Elementar-Amulett heilt dich um ${heal} Leben durch elementaren Schaden.`, 'heal');
                updateUIDisplay();
            }, 350);
        }
    }

    // Abgelaufene Effekte entfernen
    state.currentEnemy.statusEffects = state.currentEnemy.statusEffects.filter(e => e.duration > 0);

    // Regeneration
    if (state.currentEnemy.regen && state.currentEnemy.health < state.currentEnemy.maxHealth) {
        const heal = Math.min(state.currentEnemy.regen, state.currentEnemy.maxHealth - state.currentEnemy.health);
        if (heal > 0) {
            state.currentEnemy.health += heal;
            logMessage(`${state.currentEnemy.name} regeneriert ${heal} Leben.`, 'heal');
        }
    }

    updateEnemyUI();

    if (state.currentEnemy.health <= 0) {
        logMessage(`${state.currentEnemy.name} stirbt an Statuseffekten!`, 'system');
        checkEnemyDefeat();
    }
}

    
        // Beginnt eine neue Runde für den Spieler
        function startNewTurn() {
            if (state.gameOver) return; // Kein neuer Zug, wenn Spiel vorbei ist
            state.turnInProgress = false;

            //Sigma
             if (state.player.hasSigmaShield) {
             state.player.hasSigmaShield = false;
             }

            //Mewing
            if (state.player.mewingStage === 1) {
            state.player.mewingStage = 2;
            } else if (state.player.mewingStage === 2) {
            state.player.mewingStage = 3;
            }

            //Block erst jetzt zurücksetzen
            if (state.player.block > 0) {
                    logMessage(`Block (${state.player.block}) verschwindet.`, 'block');
                    state.player.block = 0;
                }

                if (state.player.isShieldmaster) {
                const level = state.player.level || 1; // Standardmäßig Level 1
                const baseBlock = 3;
                const bonusBlock = Math.floor(level / 3); // +1 alle 3 Level
                const totalBlock = Math.min(baseBlock + bonusBlock, 10); // Maximal 10 Block

                state.player.block += totalBlock;
                logMessage(`🛡️ Schildmeister: Du erhältst ${totalBlock} Block.`, 'block');
            }
                
            if (state.currentEnemy?.traits?.includes('Vision')) {
                state.player.tempManaCostPenalty = 1;
            } else {
                state.player.tempManaCostPenalty = 0;
            }
            if (!state.currentEnemy.traits?.includes('YinYang') || state.currentEnemy.yinYangState !== 'yin') {
                 state.currentEnemy.block = 0;
            }       

                 // RÜSTUNG: 5 Block pro Runde
            if (state.currentEnemy.traits?.includes('Rüstung')) {
                 state.currentEnemy.block = (state.currentEnemy.block || 0) + 5;
                logMessage(`${state.currentEnemy.name} erhält 5 Block durch Rüstung.`, 'block');
             }

            // ✅ Blutrüstung heilt 2 Leben
            if (state.player.hasBloodArmor && state.player.health < state.player.maxHealth) {
                
                // ❌ Antiheal blockiert Heilung
                if (state.player.hasAntiHeal) {
                    logMessage(`❌ Blutrüstung wird durch Anti-Heilung blockiert!`, 'debuff');
                } else {
                    const heal = Math.min(3, state.player.maxHealth - state.player.health);
                    if (heal > 0) {
                        state.player.health += heal;
                        logMessage(`🩸 Blutrüstung heilt ${heal} Leben.`, 'heal');
                    }
                }
            }

            //Antiheal
            if (state.player.hasAntiHeal) {
                state.player.antiHealTurns--;
                if (state.player.antiHealTurns <= 0) {
                    state.player.hasAntiHeal = false;
                    logMessage(`🩹 Die Anti-Heilung ist verschwunden.`, 'buff');
                }
            }

             // 1. Mana auffüllen
             const baseRegen = 1;
                const bonusRegen = state.player.passiveManaRegen || 0;
                state.player.mana = Math.min(
                state.player.mana + baseRegen + bonusRegen,
                state.player.maxMana
                );

                state.usedPowerSurgeThisTurn = false;
                
                // Danach wie gewohnt auffüllen, falls Platz
                const handCount = state.player.hand.filter(c => c.name !== 'Donner-Zauber').length;
                const missingCards = state.player.maxHandSize - handCount;

                if (missingCards > 0) {
                    drawCards(missingCards);
                }


             // PET-AKTION MIT ANIMATION
             if (state.player.activePet) {
                const pet = state.player.activePet;
                let damage = 0;
                let blockGain = 0;
                let manaGain = 0;
                let logText = '';

                switch (pet.effect) {
                    case 'gawa':
                        damage = 5;
                        logText = `🐾 ${pet.name} greift an – ${damage} Schaden.`;
                        break;
                    case 'lulu':
                        damage = 2;
                        manaGain = 1;
                        logText = `🦊 ${pet.name} wirkt Magie – ${damage} Schaden + ${manaGain} Mana.`;
                        break;
                    case 'cassa':
                        damage = 1;
                        blockGain = 3;
                        logText = `🐍 ${pet.name} verteidigt dich – ${damage} Schaden + ${blockGain} Block.`;
                        break;
                }

                const petImage = document.querySelector('#petContainer img:not([src*="hellhound"])');
                if (petImage) {
                    petImage.classList.add('wobble');
                    setTimeout(() => petImage.classList.remove('wobble'), 300);
                }

                setTimeout(() => {
                    state.currentEnemy.health -= damage;
                    state.player.block += blockGain;
                    state.player.mana = Math.min(state.player.maxMana, state.player.mana + manaGain);
                    logMessage(logText, blockGain ? 'block' : damage ? 'enemy' : 'system');
                    updateEnemyUI();
                    updateUIDisplay();
                    updatePetDisplay();
                    //FALLS KAPUTT
                if (state.currentEnemy.health <= 0) {
                        checkEnemyDefeat();
                    }
                }, 600);
            }

            // 🔥 HÖLLENHUND → jetzt immer separat prüfen!
            if (state.player.hellhound) {
                setTimeout(() => {
                    const hellhoundDamage = state.player.hellhound.damage || 4;
                    state.currentEnemy.health -= hellhoundDamage;
                    logMessage(`🔥 Dein Teufelshund greift an und verursacht ${hellhoundDamage} Schaden!`, 'enemy');

                    const hellhoundImage = document.querySelector('#petContainer img[src*="hellhound"]');
                    if (hellhoundImage) {
                        hellhoundImage.classList.add('wobble');
                        setTimeout(() => hellhoundImage.classList.remove('wobble'), 300);
                    }

                    updateEnemyUI();
                    if (state.currentEnemy.health <= 0) {
                        checkEnemyDefeat();
                    }
                }, 300); // etwas nach dem Pet
            }


            // Zähler zurücksetzen
            cardsPlayedThisTurn = 0;

            // Status-Effekte anwenden
            if (state.player.statusEffects?.length > 0) {
                for (let effect of state.player.statusEffects) {
                    if (effect.type === 'poison' || effect.type === 'burn') {
                        logMessage(`☠️ ${effect.type === 'burn' ? 'Verbrennung' : 'Vergiftung'} fügt dir ${effect.power} Schaden zu.`, 'player');
                        state.player.health -= effect.power;
                        if (state.player.health <= 0) {
                        state.player.health = 0;
                        gameOver(); // beendet das Spiel
                        return; // verhindert weiteren Code
                    }
                        effect.duration -= 1;
                    } else if (effect.type === 'paralyze') {
                        logMessage(`⚡ Du bist paralysiert und kannst nur 3 Karten spielen. (${effect.duration} Runden)`, 'system');
                        effect.duration -= 1;
                    }
                }

                // Entferne abgelaufene Effekte
                state.player.statusEffects = state.player.statusEffects.filter(e => e.duration > 0);
            }
            

            // Füge Anti-Heilung als echten Status-Effekt hinzu (bleibt sichtbar, solange aktiv)
            const antihealEffect = state.player.statusEffects.find(e => e.type === 'antiheal');
            if (state.player.hasAntiHeal) {
                if (!antihealEffect) {
                    state.player.statusEffects.push({
                        type: 'antiheal',
                        duration: state.player.antiHealTurns
                    });
                } else {
                    antihealEffect.duration = state.player.antiHealTurns; // aktualisieren
                }
            } else {
                // Anti-Heilung ist nicht mehr aktiv – aus Status-Effekten entfernen
                state.player.statusEffects = state.player.statusEffects.filter(e => e.type !== 'antiheal');
            }

            updatePlayerStatusDisplay();
    
              // TODO: Spieler-Statuseffekte anwenden (z.B. Gift erleidet Schaden)
    
             // 4. UI aktualisieren
             updateUIDisplay();
             updateHandUI(); // Gezogene Karten anzeigen
             updatePlayerItemIcons();
    
             // 5. Spieleraktionen wieder erlauben
             state.turnInProgress = false;
             updateCardAvailability(); // Aktiviert spielbare Karten/Buttons
             updateEnemyUI();
             updatePlayerItemIcons();
             updatePlayerStatusDisplay();
    
        }

    
        // Prüft, ob der aktuelle Gegner besiegt ist
 function checkEnemyDefeat() {
if (state.currentEnemy && state.currentEnemy.health <= 0) {
    if (state.currentEnemy.traits?.includes('Lichking') && !state.currentEnemy.hasResurrected) {
        state.currentEnemy.hasResurrected = true;
        state.currentEnemy.health = Math.floor(state.currentEnemy.maxHealth / 2);
        state.currentEnemy.attack += 20;

        logMessage(`⚔️ ${state.currentEnemy.name} erhält +20 Angriff nach der Wiederbelebung!`, 'enemy');
        logMessage(`💀 ${state.currentEnemy.name} erhebt sich als Lich!`, 'enemy');

        // 👑 Ändere Bild dauerhaft
        state.currentEnemy.pixelImageKey = 'awakened';

        const enemyElem = document.getElementById('enemyContainer') || enemyContainerElem;
        enemyElem.classList.add('lich-revive-effect');
        setTimeout(() => {
            enemyElem.classList.remove('lich-revive-effect');
        }, 1600);

        updateEnemyUI();

        // ✅ SPIEL FORTSETZEN
        setTimeout(() => {
            state.turnInProgress = false;
            startNewTurn();
        }, 800);

        return true; // verhindert restlichen Ablauf
    }




    // Normales Besiegt-Verhalten
    const defeatedName = state.currentEnemy.name;
    logMessage(`${defeatedName} besiegt!`, 'system');

            // 🧪 Teilung – Erzeugt Mini-Schleim statt neuen Gegner zu laden
        if (state.currentEnemy.traits?.includes('Teilung') && !state.currentEnemy.hasSplit) {
            const original = state.currentEnemy;

            // Markiere originalen Schleim als bereits geteilt
            original.hasSplit = true;

            const miniSlime = {
                name: 'Mini-Schleim',
                health: Math.floor(original.maxHealth / 2),
                maxHealth: Math.floor(original.maxHealth / 2),
                attack: Math.max(1, Math.floor((original.attack || 0) / 2)),
                traits: [], // Mini bekommt keine Traits
                pixelImageKey: 'mini_slime',
                description: 'Ein kleiner, aber zäher Schleim!',
                xp: Math.floor((original.xp || 50) / 2),
                gold: Math.floor((original.gold || 10) / 2),
                levelMin: original.levelMin,
                levelMax: original.levelMax
            };

            logMessage(`🧪 Der Schleim teilt sich in einen Mini-Schleim!`, 'enemy');

            // Ersetze den Gegner durch den Mini
            state.currentEnemy = miniSlime;
            updateEnemyUI();
            updateUIDisplay();
            startNewTurn();

            // Statt return true:
            setTimeout(() => {
            checkEnemyDefeat();
            }, 50);
            return;

        }

        state.defeatedEnemies++;

        // 🕰 Zeitklingenpassiv: alle 5 Kills → +1 Damage Bonus
        if (playerInventory.has('zeitklinge')) {
            state.player.zeitklingeKills += 1;

            if (state.player.zeitklingeKills % 6 === 0 && state.player.zeitklingeBonus < 13) {
                state.player.zeitklingeBonus++;
                logMessage(`🕰 Zeitklinge-Buff: +1 permanenter Schaden! (gesamt ${state.player.zeitklingeBonus})`, 'buff');
            }
        }

        // 💎 Gems check direkt hier:
        handleGemDrop(state.currentEnemy); // 👈 HIER!

        // 🔓 Unlocks
        if (defeatedName === 'Nekromant') {
            localStorage.setItem('unlockedGoldboy', 'true');
            logMessage('🗝️ Passive "Goldjunge" freigeschaltet!', 'system');
        }
        if (defeatedName === 'Drache') {
            localStorage.setItem('unlockedDragonscale', 'true');
            logMessage('🗝️ Passive "Drachenschuppen" freigeschaltet!', 'system');
        }
        if (defeatedName === 'Teufel') {
            localStorage.setItem('unlockedUndead', 'true');
            logMessage('🗝️ Passive "Totenbeschwörer" freigeschaltet!', 'system');
        }
        if (defeatedName === 'Bagdo') {
            localStorage.setItem('unlockedLichkingSkin', 'true');
            unlockSkin('skin_lichking');
            logMessage('🧊 Du hast den Lichkönig besiegt! Skin freigeschaltet.', 'system');
        }
  
            
            // 🏆 ACHIEVEMENT CHECK
            if (defeatedName) {
            const name = defeatedName.trim().toLowerCase();
            console.log("🧟 Besiegt:", name);

            if (name === 'drache') {
                unlockAchievement('dragonSlayer');
                let dragonKills = parseInt(localStorage.getItem('dragonKills') || '0', 10) + 1;
                localStorage.setItem('dragonKills', dragonKills);
                if (dragonKills >= 10) unlockAchievement('dragonHunter');
            } 
                else if (name === 'goblin') {
                let goblinKills = parseInt(localStorage.getItem('goblinKills') || '0', 10) + 1;
                localStorage.setItem('goblinKills', goblinKills);
                console.log("🪓 Goblins gesamt:", goblinKills);
                if (goblinKills >= 50) unlockAchievement('goblin100');
            }

            else if (name === 'bagdo') {
                unlockAchievement('bagdoDown');
            }
            }



        const xpGained = state.currentEnemy.xp || 50;
        gainXP(xpGained);

        const goldEarned = state.currentEnemy.gold || 0;
        state.player.gold += goldEarned;
        logMessage(`💰 Du erhältst ${goldEarned} Gold.`, 'system');
        updateUIDisplay();

        state.player.mana = state.player.maxMana;
        logMessage(`🔋 Dein Mana wurde vollständig aufgefüllt.`, 'mana');

        enemyContainerElem.classList.add('defeat');

        setTimeout(() => {
            state.currentEnemy = null;
            enemyNameElem.textContent = '🔍 Suche nach neuem Gegner...';
            enemyHealthElem.textContent = '-';
            enemyMaxHealthElem.textContent = '-';
            enemyHealthBarElem.style.width = '0%';
            enemyAttackElem.textContent = '-';
            monsterImageElem.style.backgroundImage = 'none';
            monsterImageElem.style.backgroundColor = '#333';
            enemyInfoElem.textContent = '';
            monsterTraitsElem.innerHTML = '';
            document.getElementById('enemyMinions').innerHTML = '';
        }, 400);

        setTimeout(() => {
            loadEnemy(); 
            state.turnInProgress = false;
            updateUIDisplay();
            updateEnemyUI();
            startNewTurn();
        }, 2000);

        return true;
    } else {
        state.turnInProgress = false;
        updateCardAvailability();
        return false;
    }
 }



    function unlockSkin(skinId) {
                const skins = new Set(JSON.parse(localStorage.getItem("unlockedSkins") || "[]"));
                skins.add(skinId);
                localStorage.setItem("unlockedSkins", JSON.stringify(Array.from(skins)));
            }

            // Verarbeitet erhaltene XP und prüft auf Level Up
            function gainXP(amount) {
                if (state.gameOver) return;
                state.player.xp += amount;
                logMessage(`+${amount} XP erhalten!`, 'xp');

                // Level Up prüfen (kann mehrmals passieren bei viel XP)
                while (state.player.xp >= state.player.xpToNextLevel && !state.gameOver) {
                    levelUp();
                }
                updateUIDisplay(); // XP-Balken aktualisieren
            }

            // Führt einen Level Up durch
     function levelUp() {
            state.player.level++; 
            state.player.maxHealth += 1; // 🎉 +1 Max-Leben bei jedem Level-Up

            // Heile 20 % des neuen Max-Lebens
            const healAmount = Math.floor(state.player.maxHealth * 0.2);
            state.player.health = Math.min(state.player.health + healAmount, state.player.maxHealth);

            state.player.xp -= state.player.xpToNextLevel;
            state.player.xpToNextLevel = Math.floor(BASE_XP_TO_LEVEL_UP * Math.pow(LEVEL_UP_FACTOR, state.player.level - 1));
            
            logMessage(`*** Level Up! Spieler erreicht Level ${state.player.level}! Max-Leben erhöht auf ${state.player.maxHealth} und heilt ${healAmount} Leben! ***`, 'system');
            
            updateUIDisplay();

            setTimeout(() => {
                showUpgradeScreen(); // z.B. Kartenwahl oder Bonuswahl
            }, 500);
        }
    
            function showUpgradeScreen() {
                state.turnInProgress = true;
                updateCardAvailability();

                // UI vorbereiten
                upgradeOptionsElem.innerHTML = '';
                upgradeTitleElem.textContent = `Level ${state.player.level}! Wähle ein Upgrade`;

                // Shop-Icon sicher wieder einblenden
                const shopIcon = document.getElementById('shopIconContainer');
                if (shopIcon) {
                    shopIcon.style.display = 'block';
                }

                // Immer dabei: feste Gold-Option
                const goldOption = {
                    type: 'gainGoldFixed',
                    title: 'Goldbeutel +350',
                    description: 'Erhalte 350 Gold.',
                    rarity: 'common'
                };
                
                // Upgrade-Pool filtern und gewichten
                const availableUpgrades = UPGRADE_TYPES.filter(upg => upg.type !== 'gain_gold');
                const weightedPool = getWeightedUpgrades(availableUpgrades, 1, 15, 50);
                const chosenUpgrades = [goldOption, ...weightedPool.slice(0, 2)];

                // Spezialoption für bestimmte Klassen
                if (state.player.passive === 'undead') {
                    chosenUpgrades.push({
                        type: 'hellhoundBoost',
                        title: '🍗 Totenkeule 🍗',
                        description: 'Dein Höllenhund verursacht +1 Schaden.',
                        rarity: 'rare'
                    });
                }


                // Upgrade-Optionen erzeugen
                chosenUpgrades.forEach(upgrade => {
                    const optionDiv = document.createElement('div');
                    optionDiv.classList.add('upgrade-option');

                    if (upgrade.rarity === 'rare') optionDiv.classList.add('rare');
                    if (upgrade.rarity === 'superrare') optionDiv.classList.add('superrare');

                    // Dynamischer Titel für Lifesteal
                    if (upgrade.type === 'lifesteal') {
                        const currentStacks = state.player.lifestealStacks || 0;
                        upgrade.title = `Lebensraub ${currentStacks + 1}`;
                    }

                    optionDiv.innerHTML = `
                        <h3>${upgrade.title}</h3>
                        <p>${upgrade.description}</p>
                    `;

                    optionDiv.addEventListener('click', () => {
                        applyUpgrade(upgrade);

                        // Shop-Icon nach Upgrade-Wahl ausblenden
                        if (shopIcon) {
                            shopIcon.style.display = 'none';
                        }
                    });

                    upgradeOptionsElem.appendChild(optionDiv);
                });

                // Upgrade-Screen anzeigen
                upgradeContainerElem.style.display = 'flex';
            }



    
          // Wendet das gewählte Upgrade an (PLATZHALTER - HIER MUSS DIE LOGIK REIN!)
         function applyUpgrade(upgrade) {
             logMessage(`Upgrade gewählt: ${upgrade.title}`, 'system');
         switch(upgrade.type) {  

        case 'blackMarketGold': {
                    logMessage(`🖤 Willkommen beim Schwarzmarkt! Verkaufe eine Karte *für dieses Spiel* gegen Gold.`, 'system');

                    upgradeOptionsElem.innerHTML = '';
                    upgradeTitleElem.textContent = 'Schwarzmarkt – Das heutige Angebot:';

                    const forbiddenCardIds = [1]; // Schwert darf niemals verkauft werden

                    // Karten im Deck, die NICHT das Schwert sind
                    const unlockedNonSwordCards = CARD_TYPES.filter(card =>
                        state.unlockedCardIds.has(card.id) &&
                        !forbiddenCardIds.includes(card.id)
                    );

                    if (unlockedNonSwordCards.length === 0) {
                        logMessage(`⚠️ Keine verkaufbaren Karten verfügbar.`, 'system');
                        return;
                    }

                    shuffleArray(unlockedNonSwordCards);
                    const offeredCards = unlockedNonSwordCards.slice(0, 3);

                    offeredCards.forEach(card => {
                        const sellPrice = getRandomInt(100, 600);

                        const cardDiv = document.createElement('div');
                        cardDiv.classList.add('card', 'card-choice');
                        if (card.rarity === 'rare') cardDiv.classList.add('rare');
                        if (card.rarity === 'superrare') cardDiv.classList.add('superrare');

                        cardDiv.innerHTML = `
                            <div class="card-mana">${card.manaCost}</div>
                            <div class="card-name">${card.name}</div>
                            <div class="card-icon">${card.icon}</div>
                            <div class="card-description">${card.description}</div>
                            <div class="card-power">${card.power ?? ''}</div>
                            <div class="sell-price">💰 ${sellPrice} Gold</div>
                        `;

                        cardDiv.querySelector('.sell-price').style.marginTop = '8px';
                        cardDiv.querySelector('.sell-price').style.fontWeight = 'bold';
                        cardDiv.querySelector('.sell-price').style.color = '#ffd700';

                        cardDiv.addEventListener('click', () => {
                            // Entferne nur aus Deck/Hand/Discard – unlocked bleibt!
                            ['deck', 'hand', 'discardPile'].forEach(pile => {
                                state.player[pile] = state.player[pile].filter(c => c.id !== card.id);
                            });

                            state.player.gold += sellPrice;
                            logMessage(`💸 ${card.name} wurde für ${sellPrice} Gold verkauft.`, 'gold');

                            upgradeContainerElem.style.display = 'none';
                            updateUIDisplay();
                            updateHandUI();
                            state.turnInProgress = false;
                        });

                        upgradeOptionsElem.appendChild(cardDiv);
                    });

                    // Ablehnen-Button
                    const cancelBtn = document.createElement('button');
                    cancelBtn.textContent = '❌ Angebote ablehnen';
                    cancelBtn.style.marginTop = '20px';
                    cancelBtn.style.padding = '6px 12px';
                    cancelBtn.style.fontSize = '14px';
                    cancelBtn.style.backgroundColor = '#444';
                    cancelBtn.style.color = '#fff';
                    cancelBtn.style.border = '1px solid #888';
                    cancelBtn.style.borderRadius = '6px';
                    cancelBtn.style.cursor = 'pointer';

                    cancelBtn.addEventListener('click', () => {
                        logMessage(`🚫 Du hast die Schwarzmarkt-Angebote abgelehnt.`, 'system');
                        upgradeContainerElem.style.display = 'none';
                        state.turnInProgress = false;
                    });

                    upgradeOptionsElem.appendChild(cancelBtn);
                    upgradeContainerElem.style.display = 'flex';
                    return;
                }


            case 'swapCard': {
                logMessage(`🔁 Wähle eine freigeschaltete Karte, die du dauerhaft entfernen möchtest.`, 'system');

                upgradeOptionsElem.innerHTML = '';
                upgradeTitleElem.textContent = 'Karte zum Entfernen wählen';

                const forbiddenCardIds = [1]; // Schwert darf nicht gelöscht werden

                const ownedCardIds = new Set(state.player.deck.map(c => c.id));
                const removableCards = CARD_TYPES.filter(card =>
                    state.unlockedCardIds.has(card.id) &&
                    !forbiddenCardIds.includes(card.id)
                );

                if (removableCards.length === 0) {
                    logMessage('⚠️ Keine entfernbare Karte verfügbar.', 'system');
                    return;
                }

                shuffleArray(removableCards);
                const choicesToRemove = removableCards.slice(0, 6);

                // Zeige Karten zur Auswahl
                choicesToRemove.forEach(card => {
                    const cardDiv = createCardElement(card);
                    cardDiv.addEventListener('click', () => {
                        // Entferne die Karte aus Deck, Hand, Ablage
                        ['deck', 'hand', 'discardPile'].forEach(pile => {
                            state.player[pile] = state.player[pile].filter(c => c.id !== card.id);
                        });

                        // Entferne aus freigeschaltetem Pool nur für diese Session
                        state.unlockedCardIds.delete(card.id);
                        logMessage(`❌ ${card.name} wurde dauerhaft aus deinem Deck entfernt.`, 'discard');

                        // Jetzt neue Karten anbieten (nicht besessen + nicht verboten)
                        const forbiddenCardIdsAdd = [17, 18, 19, 21, 22, 23, 24, 34, 35, 36]; // keine Ultra-Karten
                        const addableCards = window.cards.filter(c =>
                            !forbiddenCardIdsAdd.includes(c.id) &&
                            !state.unlockedCardIds.has(c.id)
                        );

                        if (addableCards.length === 0) {
                            logMessage(`⚠️ Keine neuen Karten mehr verfügbar zum Hinzufügen.`, 'system');
                            upgradeContainerElem.style.display = 'none';
                            return;
                        }

                        shuffleArray(addableCards);
                        const choicesToAdd = addableCards.slice(0, 6);

                        upgradeOptionsElem.innerHTML = '';
                        upgradeTitleElem.textContent = 'Neue Karte wählen';

                        choicesToAdd.forEach(newCard => {
                            const newCardDiv = createCardElement(newCard);
                            newCardDiv.addEventListener('click', () => {
                                const instance = createCardInstance(newCard);
                                state.player.deck.push(instance);
                                state.unlockedCardIds.add(newCard.id);

                                logMessage(`✨ ${newCard.name} wurde deinem Deck hinzugefügt und freigeschaltet.`, 'system');

                                upgradeContainerElem.style.display = 'none';
                                updateUIDisplay();
                                updateHandUI();
                                state.turnInProgress = false;
                            });
                            upgradeOptionsElem.appendChild(newCardDiv);
                        });
                    });

                    upgradeOptionsElem.appendChild(cardDiv);
                });

                upgradeContainerElem.style.display = 'flex';
                return;
            }

            case 'hellhoundBoost':
                if (state.player.hellhound) {
                    state.player.hellhound.damage += 1;
                    logMessage('🔥 Dein Teufelshund wird stärker – +1 Schaden!', 'system');
                    updatePetDisplay(); // 🧩 HIER HINZUFÜGEN
                }
                break;

              case 'upgradeSwordPower':
                    state.player.swordBonus = (state.player.swordBonus || 0) + 1;
                    logMessage(`Schwertbonus dauerhaft auf +${state.player.swordBonus} erhöht.`, 'system');
                    
                    // 👇 Optional: Nur zur Klarheit, keine Power-Dopplung
                    logMessage(`Vorhandene Schwerter behalten ihre Basisstärke. Bonus wird im Kampf berechnet.`, 'system');
                    
                    // Hand neu ziehen
                    state.player.discardPile.push(...state.player.hand);
                    state.player.hand = [];
                    drawCards(state.player.maxHandSize);
                    updateUIDisplay();
                    updateHandUI();
                    break;

              case 'newCardSpecific':
                    showCardChoice(getThreeUniqueNewCards()); // ✅ Lösung
                    return; // ganz wichtig, damit der Bildschirm nicht sofort verschwindet
                    case 'newUltraCardSpecific': {
                        const ultraChoices = getThreeUniqueUltraCards();

                        if (!ultraChoices || ultraChoices.length === 0) {
                            logMessage("❌ Keine Ultra-Karten verfügbar!", 'system');
                            break;
                        }

                        logMessage("🔮 Wähle eine ULTRA Karte!", 'system');
                        showCardChoice(ultraChoices, true);
                        return; // ganz wichtig
                    }
                case 'newCard':
                    const ownedCardIds = new Set(state.player.deck.map(card => card.id));
                    const possibleNewCards = CARD_TYPES.filter(card => !ownedCardIds.has(card.id));
                    if (possibleNewCards.length > 0) {
                        const randomCardType = possibleNewCards[getRandomInt(0, possibleNewCards.length - 1)];
                        const newCardInstance = createCardInstance(randomCardType);
                        state.player.deck.push(newCardInstance);
                        logMessage(`Neue Karte hinzugefügt: ${newCardInstance.name}`, 'system');
                        shuffleArray(state.player.deck);
                    } else {
                        logMessage(`Alle Karten bereits im Deck. Kein neues Upgrade möglich.`, 'system');
                    }
                    break;
                case 'regenManaPassive':
                        state.player.passiveManaRegen = (state.player.passiveManaRegen || 0) + 1;
                        logMessage(`Du regenerierst jetzt ${state.player.passiveManaRegen} zusätzliches Mana pro Runde.`, 'mana');
                        break;
                case 'regenManaPassive3':
                        state.player.passiveManaRegen = (state.player.passiveManaRegen || 0) + 3;
                        logMessage(`Du regenerierst jetzt ${state.player.passiveManaRegen} zusätzliches Mana pro Runde.`, 'mana');
                        break;                        
                 case 'upgradeHealth':
                     state.player.maxHealth += 8;
                     state.player.health += 8; // Auch heilen
                     logMessage(`Max Leben auf ${state.player.maxHealth} erhöht.`, 'system');
                     break;
                  case 'healPercent':
                      const healAmount = Math.floor(state.player.maxHealth * 0.5);
                       const actualHeal = Math.min(healAmount, state.player.maxHealth - state.player.health);
                      if(actualHeal > 0) {
                        state.player.health += actualHeal;
                        logMessage(`${actualHeal} Leben wiederhergestellt.`, 'heal');
                      } else {
                         logMessage(`Keine Heilung nötig (volles Leben).`, 'heal');
                      }
                      break;
                  case 'upgradeMana':
                      state.player.maxMana += 1;
                      state.player.mana += 1; // Optional: Auch aktuelles Mana erhöhen
                      logMessage(`Max Mana auf ${state.player.maxMana} erhöht.`, 'system');
                      break;
                  case 'increaseHandSize':
                      state.player.maxHandSize += 1;
                      logMessage(`Maximale Handgröße auf ${state.player.maxHandSize} erhöht.`, 'system');
                      break;
                  case 'addLifestealFlat': {
                        if (typeof state.player.lifestealFlat !== 'number') {
                            state.player.lifestealFlat = 0;
                        }

                        const lifestealIncrease = 0.20;
                        state.player.lifestealFlat += lifestealIncrease;

                        const display = Math.round(state.player.lifestealFlat * 100);
                        logMessage(`🧛 Bonus-Lebensraub (Flat) erhöht: +20 %. Aktuell: ${display} %`, 'lifesteal');
                        break;
                    }
                  case 'gainGoldFixed':
                    state.player.gold += 350;
                    logMessage(`Du erhältst 350 Gold. Aktuell: ${state.player.gold} Gold.`, 'system');
                    break;
                case 'fuseCards':
                        showFusionModal();
                    return;
                 // --- Implementiere andere Upgrades ---
                 default:
                     logMessage(`Upgrade-Typ '${upgrade.type}' noch nicht implementiert.`, 'system');
             }
    
    
             // Upgrade-Bildschirm ausblenden und Spiel fortsetzen
             upgradeContainerElem.style.display = 'none';
             state.turnInProgress = false; // Aktionen wieder erlauben
             updateUIDisplay(); // Stats aktualisieren
             updateCardAvailability();
         }

         function showCardChoice(cards, isSuperrare = false) {
            upgradeOptionsElem.innerHTML = '';
            upgradeTitleElem.textContent = isSuperrare ? 'Wähle eine ULTRA Karte' : 'Wähle eine neue Karte';

            if (!cards || cards.length === 0) {
                logMessage("❌ Es wurden keine Karten übergeben!", 'system');
                return;
            }

            cards.forEach(card => {
                const optionDiv = document.createElement('div');
                optionDiv.classList.add('upgrade-option');

                if (card.rarity === 'rare') {
                    optionDiv.classList.add('rare');
                }

                // 👉 WICHTIG: entweder ist die Karte superrare, oder wir erzwingen es per Flag
                if (card.rarity === 'superrare' || isSuperrare) {
                    optionDiv.classList.add('superrare');
                }

                optionDiv.innerHTML = `
                <h3>${card.name}</h3>
                <p>${card.description}</p>
                <div style="font-size: 24px; margin-top: 5px;">${card.icon}</div>
                <p style="margin-top: 4px; font-size: 12px; color: #ccc;"> Manakosten: ${card.manaCost}</p>
            `;

                optionDiv.addEventListener('click', () => {
                    const newCard = createCardInstance(card);
                    state.player.deck.push(newCard);
                    state.unlockedCardIds.add(card.id); 
                    shuffleArray(state.player.deck);
                    upgradeContainerElem.style.display = 'none';
                    state.turnInProgress = false;
                    updateUIDisplay();
                    updateCardAvailability();
                });

                upgradeOptionsElem.appendChild(optionDiv);
            });

            upgradeContainerElem.style.display = 'flex';
        }


    
        function gameOver() {
            logMessage("💀 GAME OVER!", 'enemy');
            console.log("💀 gameOver() wurde aufgerufen.");

            state.gameOver = true;
            state.turnInProgress = true;

            playerInventory.clear();

            finalScoreElem.textContent = state.defeatedEnemies;
            finalRoundElem.textContent = state.round;
            finalLevelElem.textContent = state.player.level;

            const isNewLocalRecord = state.defeatedEnemies > state.highScore;
            const playerName = (localStorage.getItem('playerName') || 'Unbekannt').substring(0, 15);

            // 🏆 Lokalen Highscore nur überschreiben, wenn besser
            if (isNewLocalRecord) {
                state.highScore = state.defeatedEnemies;
                localStorage.setItem('pixelKartenspielHighScore', state.highScore.toString());
                logMessage(`🌟 Neuer Highscore: ${state.highScore}!`, 'system');
            }

            // 💾 Immer bei Firebase speichern
            if (typeof db !== 'undefined') {
                db.collection("highscores").add({
                    name: playerName,
                    score: state.defeatedEnemies,
                    round: state.round,
                    level: state.player.level,
                    timestamp: firebase.firestore.FieldValue.serverTimestamp()
                }).then(() => {
                    console.log("✅ Highscore online gespeichert!");
                }).catch(err => {
                    console.warn("⚠️ Fehler beim Speichern im Highscore:", err);
                });
            } else {
                console.warn("❌ Firestore-DB nicht verfügbar.");
            }

            // Zeige Game Over Screen
            gameOverContainerElem.style.display = 'flex';

            // Verzögere Weiterleitung
            setTimeout(() => {
                window.location.href = 'index.html';
            }, 500); // Erhöht für Debug-Zwecke
        }

    </script>

    <script src="shop.js"></script>
    <script src="fusion.js"></script>
    <script src="lootbox.js"></script>
    <script src="achievements.js"></script>
<script type="module">
  import { cardEffects } from './cardEffects.js';

window.executeCardEffect = function(card) {
  console.log("🧪 Karte wird gespielt:", card); // ✅ Debug-Ausgabe
  const effect = card.effect;
  const handler = cardEffects[effect];

  if (typeof handler === 'function') {
    console.log("➡️ Effekt gefunden:", effect); // ✅ Debug-Ausgabe
    handler(card, state);
  } else {
    console.warn(`❓ Unbekannter Effekt: ${effect}`);
    logMessage(`Unbekannter Effekt: ${effect}`, 'system');
  }
};

</script>
</body>
</html>